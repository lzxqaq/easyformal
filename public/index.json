[{
      "id": "0",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程",
      "title": "SystemVerilog 详细教程",
      "content":"这里是 SystemVerilog 教程，致力于提供一个详细的、完整的 SystemVerilog 语法内容。\n数据类型 数组 结构体和联合体 用户自定义类型 运算符 控制流 函数 任务 SystemVerilog 循环 Scheduler schematic Processes Fine Grain Process Control Interface Constraint 类和面向对象 Coverage Assertion Interprocess communication Program Block Choosing-an-array Control-Flow-Interview-questions Data-type-Interview-questions Differences-between-macros-and-parameters Interface-Interview-Questions Processes-InterviewQuestions "},{
      "id": "1",
      "rootTitleIndex": "3",
      "rootTitle": "综合 Synthesis",
      "rootTitleIcon": "fa-solid fa-sitemap fa-lg",
      "rootTitlePath": "/synthesis/",
      "rootTitleTitle": "主页 / 综合 Synthesis",
      "permalink": "/synthesis/logic_synthesis/",
      "permalinkTitle": "主页 / 综合 Synthesis / 逻辑综合",
      "title": "逻辑综合",
      "content":"什么是逻辑综合？# 逻辑综合流程# 翻译：将 RTL 在约束下转换成通用门级电路（如 GTECH），该通用门级电路无时序和载荷信息 逻辑优化：对通用门级电路进行优化 门级映射：将优化过的通用门级电路，用工艺厂商的工艺库把电路映射出来，得到网表文件、时序约束信息、延时信息等。 综合优化技术：Datapath 优化 综合优化技术：自动打平 综合优化技术：边界优化 "},{
      "id": "2",
      "rootTitleIndex": "5",
      "rootTitle": "形式验证 Formal",
      "rootTitleIcon": "fa-solid fa-bug-slash fa-lg",
      "rootTitlePath": "/formal/",
      "rootTitleTitle": "主页 / 形式验证 Formal",
      "permalink": "/formal/model_checking/",
      "permalinkTitle": "主页 / 形式验证 Formal / 模型检查",
      "title": "模型检查",
      "content":"模型检查主要是检查RTL是否满足设计规范。一般使用基于断言的验证语言。相较于仿真，模型检查可以 100% 覆盖设计中所有可能出现的情况。在工业应用中的挑战在于需要根据规范写好断言。\nNo data available "},{
      "id": "3",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/01.data-types/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / 数据类型",
      "title": "数据类型",
      "content":"在Verilog中，所有数据类型都是 4 值的，即可以表示 0、1、X 和 Z。但是，在 test benches 的中，不需要这些4态变量。例如，要计算数据包的数量，我们需要一个 2 值变量。因此，System Verilog 引入了一类新的 2 值变量，即 0 和 1。\n数据类型列表# sr. no. data type 1. 4-state 2. 2-state 3. Arrays 4. Strings 5. Structures and Union 6. Enumerated 7. User defined Tabular column.1. data types 有符号和无符号数字\n无符号数：无符号数的符号不使用任何标志，即无符号数只能存储正数。\n无符号二进制数的范围从 0 到 ((2^n) - 1)，n 表示位数。\n有符号数：通过有符号数中的符号标志来区分正值和负值。有符号位的零有两种可能表示形式（正 (0) 和负 (1)）。\n有符号二进制数的范围从 -2^(n-1) 到 2^(n-1)-1，n表示位数。\n有符号二进制数在计算机系统中，一般用补码来表示：\n有符号二进制数的补码：\n正数的补码：与原码相同。 例如，+9的补码是00001001。 负数的补码：符号位为1，其余位为该数绝对值的原码按位取反；然后整个数加1。 例如，-7的补码：因为是负数，则符号位为“1”,整个为10000111；其余7位为-7的绝对值+7的原码 0000111按位取反为1111000；再加1，所以-7的补码是11111001。 已知一个数的补码，求原码：\n如果补码的符号位为“0”，表示是一个正数，所以补码就是该数的原码。 如果补码的符号位为“1”，表示是一个负数，求原码的操作可以是：符号位为1，其余各位取反，然后再整个数加1 有符号数和无符号数的示例\n考虑 3 位，即 n =3,\n无符号范围\n0 到 (2^(n) - 1，即 0 到 7 无符号位二进制数 十进制值 000 0 001 1 010 2 011 3 100 4 101 5 110 6 111 7 有符号范围\n-2^(n-1) 到 2^(n-1)-1，即 -4 到 3 有符号位二进制数 十进制数 000 0 001 1 010 2 011 3 100 -4 101 -3 110 -2 111 -1 在上面的例子中，最高位为符号位，最高位为 0 表示正，1 则表示负。\n对于上面的 100，1 是符号位，表示负。先对 00 取反得到 11，然后加 1 得到 100，即 4。所以有符号数 100 是 4。\n4 值数据类型列表# sr. no. data type 2-state/4-state bit signed/unsigned 1. reg 4 \u0026gt;=1 unsigned 2. wire 4 \u0026gt;=1 unsigned 3. logic 4 \u0026gt;=1 unsigned 4. integer 4 32 signed 5. time 4 64 unsigned 6. real 4 64 unsigned Tabular column.2. 4-state data type 4 值# 下面的表格列代表 4 种不同的状态。\n状态 描述 0 状态 0 1 状态 1 x or X 未知状态 (与 reg 有关) z or Z 高阻态 (与 wire 有关) Tabular column.3. value of 4-state 1. reg# reg 变量用于对锁存器、触发器和存储器等存储元件进行建模，它存储一个值并用于程序赋值。 reg 的默认值为 x。\n语法 : reg variable_name;\n2. wire# 连线是一种 Verilog 数据类型，用于连接元件以及连接由单个门或连续分配驱动的网络。导线的默认值为 z。\n语法 ： wire variable_name;\n3. tri# tri 类型可用于多个 driver 驱动一个 net 的情况。\n4. Logic# Logic 类型是 4 值类型，可以取值 0、1、x 和 z。Logic 类型，可以用来代替 wire 和 reg，因为 wire 数据类型没有多个 driver。\n默认情况下 Logic 类型是无符号的，其初始值为 x。z。Logic 类型可以在过程块和连续赋值语句中驱动。\n语法 : logic variable_name;\n示例 : logic [2:0] logic_data_type;\n5. integer# 整数是 4 态数据类型，整数可以是 0,1,x 和 z，表示 32 位有符号数。整数的默认值为 x。整数可以保存范围从 -2^31 到 (2^31)-1 的值。\n语法 : integer variable_name;\n示例 : integer integer_data;\n5. time# time 是用于模拟时间测量的特殊数据类型。它是 4 值类型，表示 64 位无符号整数，可以与 $time 系统函数结合使用来保存当前的仿真时间。\n语法 : time variable_name;\n示例 : time time_data; time_data = $time;\n6. real# 以 64 位实数实现的实数数据类型。实数可以用十进制记数法 (4.43) 或科学记数法 (42e8) 指定。 real 数据类型的默认值为 0。\n语法 : real variable_name;\n示例 : real real_data; real_data = 4.43;\nThe below figure shows the output of real data type.\nFigure.4. real output Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/data_type/two_and_four_state/real_data_type/data_type_real.sv Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/data_type/two_and_four_state/real_data_type/data_type_real.log 2 值数据类型列表# sr. no. data type 2-state/4-state bit signed/unsigned 1. bit 2 \u0026gt;=1 unsigned 2. byte 2 8 signed 3. shortint 2 16 signed 4. int 2 32 signed 5. longint 2 64 signed Tabular column.4. 2-state data type 1. bit# bit 可以是 0 或 1，代表单个位。bit 数据类型的默认值为 0。\n语法 ： bit variable_name;\n示例 ： bit single_data; bit [3:0] multi_bit_data;\n2. byte# byte 可以是 0 或 1，表示 8 位有符号整数。byte 的默认值为0。\n语法 ： byte variable_name;\n示例 ： byte byte_data;\n3. shortint# shortint 可以是 0 或 1，表示 16 位有符号整数。 shortint 的默认值为 0。\n语法 ： shortint variable_name;\n示例 ： shortint shortint_data;\n4. int# int 可以是 0 或 1，表示 32 位有符号整数。 int 的默认值是 0。\n语法 ： int variable_name;\n示例 ： int int_data;\n5. longint# longint 可以是 0 或 1，表示 64 位有符号整数。 longint 的默认值为 0。\n语法 ： longint variable_name;\n示例 ： longint longint_data;\n数据类型转换# 转换意味着将一种数据类型转换为另一种数据类型。 转换有两种类型：\n静态转换 动态转换 静态转换 ： 转换发生在编译时。因此，不会出现任何运行时错误。静态转换仅适用于固定数据类型。它不适用于面向对象的编程概念。\n语法 ：\ndata_type'(variable or expression or value);\n动态转换 : 转换发生在运行时。如果转换无效，则会报告错误。动态转换用于将分配的值转换为通常无效的变量。 $cast 是系统方法。 $cast 可以是函数或任务。\n语法 ：\n$cast(destination_variable, source_expression_or_variable);\n静态转换# 1. integer to int# 示例 ： int_data = int'(integer_data);\n2. shortint to int and longint# 示例 ： int_data = int'(shortint_data);\nlongint_data = longint'(shortint_data);\n3. int to longint# 示例 ： longint_data = longint'(int_data);\n4. real to int# 示例 ： int_data = int'(real_data);\n5. real to time# 示例 ： time_data = time'(real_data);\n6. logic to byte# 示例 ： byte_data = byte'(logic_data);\n7. bit to byte# 示例 ： byte_data = byte'(bit_data);\n枚举 enum# 枚举数据类型定义一组命名值。\n语法 ： enum enum_base_type(optional) { \u0026lt;enum_name_declaration\u0026gt; = constant_expr(optional)... }\u0026lt;enum_type_identifier\u0026gt;;\n示例 ： enum {MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY } days;\n除非指定为其他类型，否则枚举类型存储为“int”类型。 此类型会自动为列表中的每个名称赋予唯一值。 值默认为“int”类型，从 0 开始，然后递增 1。 如果没有为名称指定值，它将获取列表中前一个名称的值并加 1。 枚举函数：\nsl.no Method Description 1 first() 返回枚举的第一个成员的值 2 last() 返回枚举最后一个成员的值 3 next() 返回枚举的下一个成员的值 4 prev() 返回枚举中前一个成员的值 5 num() 返回给定枚举中的元素数量 6 name() 返回给定枚举值的字符串表示形式 Tabular column.5. enum methods typedef 枚举数据类型# 在 typedef 中可以给出类型名称，以便可以在许多地方使用相同的类型。在 typedef 中可以给出类型名称，以便可以在许多地方使用相同的类型。\n语法 ： typedef enum enum_base_type(optional) {\n\u0026lt;enum_name_declaration\u0026gt; = constant_expr(optional)...\n} \u0026lt;enum_type_identifier\u0026gt;;\n示例 ： typedef enum {MONDAY,\nTUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY } week_e;\nweek_e day;\nString# 字符串类型是可变长度的有序字符集合。字符串的长度是集合中字符的数量。\n语法 ：string variable_name =initial_value;\nExample: string str = \u0026quot;Manipal\u0026quot;;\n字符串的内存空间是动态分配的。 字符串变量的索引应从 0 到 N–1（其中 N 是字符串的长度）进行编号，以便索引 0 是字符串的第一个（最左边）字符，索引 N–1 是最后一个（最右边）字符字符串的。 未初始化或空字符串用特殊值 \u0026quot;\u0026quot; 表示。空字符串的长度为 0。 字符串运算符列表\nOperation Operator Description 等于 str1==str2 如果两个字符串相等则返回 1，否则返回 0 不等 str1!=str2 如果两个字符串不相等则返回 1，如果相等则返回 0 比较 str1 \u0026lt; str2, str1 \u0026lt;= str2, str1 \u0026gt; str2, str1 \u0026gt;= str2 如果相应条件为 true，则返回 1；如果为 false，则返回 0 级联 {str1, str2, \u0026hellip;, strN} 所有字符串将连接成一个结果字符串 复制 {N{str}} 将字符串复制 N 次 索引 str[index] 返回一个字节，即给定索引处的 ASCII 代码。如果给定索引超出范围，则返回 0 Tabular column.6.string operators String Methods cheat sheet\nFunction Description str.len() 返回字符串的长度。 str.putc() 修改字符串的一个字符 str.getc() 返回一个字符。 str.tolower() 返回字符串的小写字母。 str.toupper() 返回字符串的大写字母。 str.compare(s) 以 ascii 值形式返回字符串比较结果。 str.icompare(s) 以 ascii 值的形式返回不区分大小写的字符串比较结果。 str.substr(i,j) 返回主字符串的子字符串。 Tabular column.7. string methods "},{
      "id": "4",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/",
      "permalinkTitle": "主页 / 数字电路基础",
      "title": "数字电路基础",
      "content":" SystemVerilog 详细教程 数据类型 数组 结构体和联合体 用户自定义类型 运算符 控制流 函数 任务 SystemVerilog 循环 Scheduler schematic Processes Fine Grain Process Control Interface Constraint 类和面向对象 Coverage Assertion Interprocess communication Program Block Choosing-an-array Control-Flow-Interview-questions Data-type-Interview-questions Differences-between-macros-and-parameters Interface-Interview-Questions Processes-InterviewQuestions "},{
      "id": "5",
      "rootTitleIndex": "5",
      "rootTitle": "形式验证 Formal",
      "rootTitleIcon": "fa-solid fa-bug-slash fa-lg",
      "rootTitlePath": "/formal/",
      "rootTitleTitle": "主页 / 形式验证 Formal",
      "permalink": "/formal/theorem_proving/acl2/",
      "permalinkTitle": "主页 / 形式验证 Formal / 定理证明 / 一文了解定理证明器 ACL2",
      "title": "一文了解定理证明器 ACL2",
      "content":"ACL2 源码：https://github.com/acl2/acl2 ACL2 用户手册：https://www.cs.utexas.edu/users/moore/acl2/manuals/current/manual/index.html 简介# ACL2 是一个交互式定理证明器，基于 Common Lisp 编程语言，结合了 Formal 模型和用于证明这些模型属性的定理证明器。\n证明器：用户给它一个公式，它会为用户提供该公式的证明或告诉用户没有证明。\n交互式：ACL2 定理证明器可以自动查找证明。但大多数情况下，用户必须提供帮助（引导 ACL2 首先证明关键引理 Lemma）。\nCommon Lisp 是标准列表处理编程语言，ACL2 是其的一个子集。\nFormal 模型：ACL2 用于构建计算机硬件和软件的数学模型。\n工业应用# ACL2 被广泛用于学术界和工业界，它被用于验证微处理器、微码、Sun Java 虚拟机、操作系统内核、其他验证器和有趣算法模型的特性，如 AMD 使用 ACL2 验证了 AMD Athlon™ 的基本浮点运算符与 IEEE 754 规范的兼容性；IBM 使用 ACL2 对 IBM Power 4 上的浮点除法和平方根进行了验证。\nACL2 系统架构# 用户通过给出定义、定理和建议来与定理证明器进行交互。\n可以将其他事件的某些经过认证的文件中的所有规则包含在数据库中。此类经过认证的文件称为 books。数据库包含 ACL2“知道”的所有规则。\n证明通常建立在许多 books 的基础上，其中一些是专门针对该问题领域编写的，另一些则涉及常用领域，例如算术或列表处理。 ACL2 的发行版包括许多用户编写的 books。\n定理证明器# 当你给定理证明者一个要证明的目标公式时，它会尝试通过将其分解为子目标来证明它，每个子目标都必须被证明才能证明原始目标。这种目标的分解是通过 ACL2 中内置的各种证明技术来完成的。不同的证明技术以不同的方式分解公式。\n定理证明者的行为受到公理、定义和先前证明的定理的规则数据库的影响。\n大多数时候，用户只需通过确定要证明的 Lemma 来指导定理证明。（Lemma 只是用户认为在其他定理的证明中有用的定理。）\nACL2 使用流程# 你向 ACL2 提出待证的猜想 通常情况下，它无法证明（或你终止了它的尝试），但它会输出一些关键检查点 你查看了关键检查点，并确定一个已知的有帮助的事实 将你的知识形式化为公式，并说明 ACL2 应如何将公式转化为规则； 递归地应用上述步骤，让 ACL2 来证明你的公式并将其存储为你指定的规则类型 ACL2 工作原理# ACL2 使用六种内置证明技术来将目标公式分解为子目标。\n简化（Simplification） — 运用决策程序和先前证明的规则进行重写，实际上包括一系列其他你可控制的技术。简化是唯一能将公式减少为 0 个子目标（即证明它）而不仅仅是将其转换为其他公式的证明技术。大多数证明中主要的活动就是简化。你可以通过多种方式影响简化器对公式的处理。优秀的用户大部分时间都在思考如何控制简化器。\n析构消除（Destructor Elimination） — 通过用“构造”（如 (CONS A B)）替换变量（如 X）来摆脱“析构”（如 (CAR X) 和 (CDR X)）。你可以告诉 ACL2 新的析构器/构造器组合。\n施肥（Fertilization） — 使用等价假设，用目标中的一侧替换另一侧。在归纳时，ACL2 可能会决定使用其所谓的交叉施肥启发法来限制替换，如下所示：仅替换到结论的一侧，从而使用归纳假设为另一次归纳之前的可能泛化做好准备。请注意，仅在启用泛化时才使用交叉施肥：使用提示：do-not \u0026lsquo;（泛化）时，仅应用完全施肥。\n泛化（Generalization） — 用新变量替换一个项，并限制新变量具有某些项的性质。你可以控制对新变量施加的限制。这是一种启发式方法，为另一个归纳做准备。\n无关性消除（Elimination of Irrelevance） — 丢弃不必要的假设。这是一种为另一个归纳做准备的启发式方法。\n归纳（Induction） — 选择一个归纳方案来证明一个公式。归纳是由公式中出现的递归函数“建议”的。但是你可以通过项来控制什么样的归纳被提出。\n你还可以添加其他技术，称为 clause processors 子句处理器。\n依次尝试各种技术，首先是简化，最后是归纳。每种技术报告三个结果之一：它发现没有什么可以改变（即该技术不适用于该子目标），它决定中止证明尝试（通常是因为有理由相信证明失败），或者它将目标分解为 k 个子目标。\n最后一个结果有一个特殊情况：如果 k 为 0，则该技术证明了目标。每当 k 不为 0 时，该过程就会重新开始，并对 k 个子目标中的每一个进行简化。然而，它保存了所有子目标，归纳法是唯一可以尝试的证明技术。这样，你就可以在启动另一个归纳之前了解它在每个基本案例和一个归纳的归纳步骤上的执行情况。\n它会一直运行，直到你或其中一种证明技术中止证明尝试或直到所有子目标都得到证明。\n请注意，如果简化产生子目标，则该子目标将被重新简化。这个过程一直持续到子目标无法进一步简化为止。只有这样才能尝试下一个证明技术。据说这样的子目标在简化下是稳定的。\n"},{
      "id": "6",
      "rootTitleIndex": "3",
      "rootTitle": "综合 Synthesis",
      "rootTitleIcon": "fa-solid fa-sitemap fa-lg",
      "rootTitlePath": "/synthesis/",
      "rootTitleTitle": "主页 / 综合 Synthesis",
      "permalink": "/synthesis/logic_synthesis/datapath_optimization/",
      "permalinkTitle": "主页 / 综合 Synthesis / 逻辑综合 / 综合优化技术：Datapath 优化",
      "title": "综合优化技术：Datapath 优化",
      "content":"综合器使用属延迟算术简化、资源共享等技术优化 Datapath。\n"},{
      "id": "7",
      "rootTitleIndex": "3",
      "rootTitle": "综合 Synthesis",
      "rootTitleIcon": "fa-solid fa-sitemap fa-lg",
      "rootTitlePath": "/synthesis/",
      "rootTitleTitle": "主页 / 综合 Synthesis",
      "permalink": "/synthesis/logic_synthesis/ungrouping/",
      "permalinkTitle": "主页 / 综合 Synthesis / 逻辑综合 / 综合优化技术：自动打平",
      "title": "综合优化技术：自动打平",
      "content":" 自动打平将层次结构中的给定子模块合并到父模块中，它消除了层级边界，允许综合器通过减少层级来改善时序，并通过共享逻辑来改善面积。\n"},{
      "id": "8",
      "rootTitleIndex": "5",
      "rootTitle": "形式验证 Formal",
      "rootTitleIcon": "fa-solid fa-bug-slash fa-lg",
      "rootTitlePath": "/formal/",
      "rootTitleTitle": "主页 / 形式验证 Formal",
      "permalink": "/formal/equivalence_checking/",
      "permalinkTitle": "主页 / 形式验证 Formal / 等价性检查",
      "title": "等价性检查",
      "content":"等价性检查就是看两个design是否等价。针对的是同一个design的不同实现阶段。还有可以针对内部状态不match情况下的等价性检查，比如经过retimed, pipeline重排后的design。\nNo data available "},{
      "id": "9",
      "rootTitleIndex": "2",
      "rootTitle": "仿真 Simulation",
      "rootTitleIcon": "fa-solid fa-code-compare fa-lg",
      "rootTitlePath": "/simulation/",
      "rootTitleTitle": "主页 / 仿真 Simulation",
      "permalink": "/simulation/",
      "permalinkTitle": "主页 / 仿真 Simulation",
      "title": "仿真 Simulation",
      "content":" No data available "},{
      "id": "10",
      "rootTitleIndex": "3",
      "rootTitle": "综合 Synthesis",
      "rootTitleIcon": "fa-solid fa-sitemap fa-lg",
      "rootTitlePath": "/synthesis/",
      "rootTitleTitle": "主页 / 综合 Synthesis",
      "permalink": "/synthesis/high_level_synthesis/",
      "permalinkTitle": "主页 / 综合 Synthesis / 高阶综合",
      "title": "高阶综合",
      "content":" No data available "},{
      "id": "11",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/02.array/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / 数组",
      "title": "数组",
      "content":"数组是元素的集合，所有元素都具有相同的类型，并使用其名称和一个或多个索引进行访问。 Verilog 2001 要求数组的下限和上限必须是数组声明的一部分。 System Verilog 引入了紧凑数组声明样式，只需给出数组大小以及数组名称声明就足够了。\n下图显示了 System Verilog 中使用的不同类型的数组。 数组类型一览表列表：\n数组类型 描述 压缩数组(Packed Array) 先声明数组名称，后声明数组维度 非压缩数组(Unpacked Array) 先声明数组维度，后声明数组名称 动态数组(Dynamic Array) 内存将在运行时分配 关联数组(Associative Array) 仅在使用时分配内存并且使用任何索引类型对数组进行索引 队列(Queue) 它类似于 fifo，我们可以在运行时向队列添加和删除元素 数组的函数 它由数组定位函数、数组排序函数和数组缩减函数组成 静态数组# 在固定大小数组/静态数组中，数组大小在整个模拟过程中将保持不变，一旦声明数组就无需创建它。默认情况下，数组将初始化为值“0”。在这种类型的数组中，内存将在编译阶段被占用，并且我们无法在运行时重新分配内存。\n静态数组有两种类型\n压缩数组 非压缩数组. 压缩数组# 压缩数组（Packed Arrays）是一种在数组名称之前声明数组维度的数组。在此数组中的多个位存储在一个内存位置中。\n注意： 它可以由任何单个位数据类型 bit、logic 和 reg 组成。我们不能对压缩数组使用多位数据类型。\n语法： [data_type] [dimensions] [array_name];\n示例：\n1) bit [3:0]abc = 4'b0110\n2) logic [15:0]pqr = 16'h10fe\n3) reg [7:0]xyz = 8'd16\n一些注意事项：\n如果压缩数组被声明为带符号的，则被视为单个向量的数组应被带符号。数组的各个元素都是无符号的，除非它们是声明为有符号的命名类型。 压缩数组的最大大小可以受到限制，但至少应为 65536 (2^16) 位。 压缩数组是可综合的。 下图展示了二维压缩数组中数组元素的存储方式。对于位 [2:0][3:0]xyz 示例，数组元素从左到右将占用内存。\n压缩数组的应用：\n它们用于存储可以执行位选择和部分选择操作的数据包结构。\n非压缩数组# 非压缩数组（Unpacked Arrays）是在数组名称之后声明数组维度的数组。在此，多个位将存储在不同的存储位置中。\n语法： [data_type] [array_name] [dimension];\n示例：\nbyte a[8] = '{4,5,6,2,3,7,9,10}\nint abc[10] = $urandom_range(10,50);\n其中，$urandom_range是内置函数，它生成10到50之间的随机数。\n一些注意事项：\n它们可以是任何数据类型。 如果非压缩数组被声明为有符号，则这适用于数组的各个元素，因为整个数组不能被视为单个向量。 非压缩数组可以以模拟器选择的任何方式排列在内存中——不必是连续的。 它们可以是固定大小的数组、动态数组、关联数组或队列。 非压缩数组是不可综合的。 下图显示了数组元素如何存储在二维非压缩数组中。对于 int abc[2][3] 示例，数组元素从左到右将占用内存。\n非压缩数组的应用：\n它们用于对随机存取存储器 (RAM)、只读存储器 (ROM) 和一次访问一个元素的寄存器文件进行建模。\n混合多维数组# 压缩数组和非压缩数组的混合称为混合多维数组。\n语法： [data_type] [dimensions] [array_name] [dimensions];\n示例：\nlogic [2:0][3:0] mixed_array [2:0][3:0];\n一些注意事项：\n首先按从最左边到最右边的顺序引用所有非压缩数组 然后按从最左边到最右边的顺序引用所有压缩数组。 在给定的示例中，将从左到右分配内存，并且对于第一个非压缩数组维度将被考虑，如下图所示，然后考虑压缩数组维度。\n动态数组# 动态数组（Dynamic Arrays）是非压缩的数组，其大小可以在运行时设置或更改。动态数组的空间在运行时显式创建之前并不存在。\n语法： \u0026lt;data_type\u0026gt; array_name []\n示例：\nint abc[] = new[7];\nabc[7] = '{11,12,13,14,15,16,17};\n一些注意事项：\n未初始化的动态数组的默认大小为 0。 动态数组支持所有变量数据类型作为元素类型，包括数组。 动态数组中的越界访问会指向数据类型的默认值。 动态数组函数一览表\n函数 示例 描述 构造函数： new [value] abc.new[] 设置动态数组的大小并初始化其元素或在运行时更改数组的大小。如果该值为零，则数组将变为空。如果该值为负数，则表示错误。 函数： int size() abc.size() size() 方法返回动态数组的当前大小，如果数组尚未创建，则返回零 函数： void delete() abc.delete() delete() 方法清空数组，导致数组大小为零 动态数组的应用：\n可以在模拟期间分配和重新调整大小的动态数组将避免这种不必要的内存分配。\n关联数组# 关联数组（Associative Arrays）是一种非压缩数组数据类型。它在使用之前不会分配任何存储空间，并且用于访问元素的索引类型不限于整数。\n语法： \u0026lt;data_type\u0026gt; array_name [index_type]\n其中，索引类型是任何数据类型或其通配符“*”。\n示例：\nint abc[*];\nabc = '{ 1:20, 25:22, 38:66};\nstring pqr[string];\npqr = '{\u0026quot;fruits\u0026quot;:\u0026quot;mango\u0026quot; , \u0026quot;vegetables\u0026quot;:\u0026quot;cucumber\u0026quot; , \u0026quot;season\u0026quot;:\u0026quot;monsoon\u0026quot;};\n一些注意事项：\n关联数组的元素都是非压缩的。 模拟器可以将其存储为哈希（查找）表，以便极快地访问其元素。哈希表包含一组元素的数组。称为哈希函数的函数生成一个唯一键来计算该数组的索引，从中获得正确的数组元素值。 关联数组中的元素的访问方式与一维数组中的元素类似。 如果尝试读取无效（不存在）的关联数组条目，则模拟器将发出警告，并为 4 状态整数类型返回值“x”，或为 2-状态整数类型返回值“0”。状态积分类型。 使用“*”这个通配符会增加模拟时间，因此在声明数组时避免使用它。 关联数组方法一览表：\nFunction 示例 Description int num () abc.num() 返回关联数组中的条目数 int size () abc.size() 返回条目数，如果为空则返回0 void delete ([input index]) abc.delete(index) 指定索引时，将删除该索引处的条目，否则将删除整个数组 int exists (input index) abc.exists(index) 检查指定索引处是否存在元素；如果存在则返回 1，否则返回 0 int first (ref index) abc.first(index) 将第一个索引的值分配给给定的索引变量；对于空数组返回 0 int last (ref index) abc.last(index) 将最后一个索引的值分配给给定的索引变量；对于空数组返回 0 int next (ref index) abc.next(index) 查找值大于给定索引的最小索引 int prev (ref index) abc.prev(index) 查找值小于给定索引的最大索引 关联数组的应用：\n用于设计内容可寻址存储器 (CAM) 的关联数组。用于验证存储器的随机读取或写入测试可以使用关联数组来仅存储已写入地址的数据。这将比 Verilog 中通常使用的整个数组占用的内存少得多。\n队列# 队列是一种数据类型，用于以未压缩数组格式存储相同数据类型的可变大小有序集合，用于在数组两端插入元素和删除数组中的元素。它就像缓冲区一样，用于模拟先进先出（FIFO）和后进先出（LIFO）。\n语法: data_type name[$];\ndata_type - 队列元素的数据类型 name - 队列名称 [$] - 声明无界队列\n队列有两种类型\n有界队列# 队列有大小限制。我们需要在声明队列时提供最大值。\n语法: data_type name[$:255];\n这里 $ 是第一个成员，255 是最后一个成员\n无界队列# 队列没有大小限制。我们不提供队列的大小，它是可变大小的队列。\n语法: data_type name[$];\n这里 0 是第一个成员，$ 是最后一个成员\n队列的函数# 队列的函数一览表\nMethod Example Description function int size (); queue1.size(); 返回队列中的项目数 function void insert (input integer index, input element_t item); queue1.insert(int 0, 2); 在指定索引位置插入给定项目 function void delete ( [input integer index] ); queue1.delete(0); 删除指定索引位置的项目 function element_t push_front (input element_t item); queue1.push_front(\u0026ldquo;yelahanka\u0026rdquo;); 将给定元素插入队列的前面 function element_t push_back (input element_t item); queue1.push_back(\u0026ldquo;udupi\u0026rdquo;); 将给定元素插入到队列末尾 function void pop_front (); queue1.pop_front() 删除并返回队列的第一个元素 function void pop_back (); queue1.pop_back() 删除并返回队列的最后一个元素 数组的优点和缺点：# 数组类型 优点 缺点 固定大小的数组 1) 可以在运行时之前预先计算大小。 2) 内存在内存 bss 部分的 ROM 中分配，与非压缩数组相比，模拟时间更少。 1) 大小是固定的，我们无法扩展数组。 2) 内存浪费 动态数组 1) 连续内存分配 2) 我们可以使用循环从一个内存位置跳转到另一个内存位置。 3) 由于有序，我们可以轻松地在数组中移动 4) 与队列相比，执行时间更短 1) 我们无法在特定索引位置插入和删除值 2) 内存分配在堆内存中，因此与固定数组相比，模拟时间更长 关联数组 1) 内存友好 2) 任何数据类型都可用于索引 3) 我们可以在特定索引处插入和删除值 1) 内存分配不连续 2) 索引之间没有固定关系，因此遍历数组很困难 3) 跳转到数组中其他内存位置需要索引号或者键 队列 1) 我们可以插入和删除特定索引处的值 2) 我们可以在现有元素之间插入元素 3) 海量数据可轻松高效管理 4) 推入和弹出操作可以轻松执行，比关联数组更好 1) 与动态数组相比，执行时间更长 2) 与动态数组相比，它有点复杂，因为它会扩展/增加 数组的函数# 在 System Verilog 中，数组操作方法是用于搜索和排序的内置方法。数组操作方法迭代每个数组元素以计算 with 子句给出的表达式。对于某些方法来说，with 子句是必须的，而对于某些方法来说，with 子句是可选的。 “with”是指对现有数组进行条件评估。下图是数组操作方法的流程图\n数组操作函数一览表\n**非破坏性：**其输出存储在另一个数组中的数组不会影响原始数组\nMethod Example Description find() with condition(); array.find(check) with (check \u0026gt;=\u0026ldquo;oldtown\u0026rdquo;) 返回满足给定表达式的所有元素 find_index() with condition(); array.find_index(check) with (check ==\u0026ldquo;yelahanka\u0026rdquo;); 返回满足给定表达式的所有元素的索引 find_first() with condition(); array.find_first(check) with (check \u0026lt; \u0026ldquo;yelahanka\u0026rdquo; \u0026amp; check \u0026gt;= \u0026ldquo;newton\u0026rdquo; ); 返回满足给定表达式的第一个元素 find_first_index() with condition(); array.find_first_index(check) with (check \u0026lt; \u0026ldquo;yelahanka\u0026rdquo;); 返回满足给定表达式的第一个元素的索引 find_last() with condition(); array.find_last(check) with (check \u0026lt; \u0026ldquo;oldtown\u0026rdquo;); 返回满足给定表达式的最后一个元素 find_last_index() with condition(); array.find_last_index(check) with (check \u0026lt; \u0026ldquo;oldtown\u0026rdquo;); 返回满足给定表达式的最后一个元素的索引 function max(); array.max(); 返回值为最大值的元素 function min(); array.min(); 返回值为最小值的元素 function unique(); array.unique(); 返回作为唯一值的所有元素 function unique_index(); array.unique_index(); 返回作为唯一值的所有索引位置 function sum(); array.sum(); 返回所有元素的总和 function product(); array.product(); 回所有元素的乘积 function and(); array.and(); 回所有元素的按位与(\u0026amp;) function or(); array.or(); 返回数组中所有元素的按位或 function xor(); array.xor(); 返回数组中所有元素的按位 XOR(^) **破坏性：**其输出直接影响原始数组的数组\nMethod Example Description function reverse(); array.reverse(); 反转数组元素的顺序 function sort(); array.sort(); 升序对数组元素进行排序 function rsort(); array.rsort(); 按降序对数组元素进行排序 function shuffle(); array.shuffle(); 对数组元素进行混洗，使索引值按随机顺序排列 "},{
      "id": "12",
      "rootTitleIndex": "3",
      "rootTitle": "综合 Synthesis",
      "rootTitleIcon": "fa-solid fa-sitemap fa-lg",
      "rootTitlePath": "/synthesis/",
      "rootTitleTitle": "主页 / 综合 Synthesis",
      "permalink": "/synthesis/logic_synthesis/boundary_change/",
      "permalinkTitle": "主页 / 综合 Synthesis / 逻辑综合 / 综合优化技术：边界优化",
      "title": "综合优化技术：边界优化",
      "content":"边界优化是综合器跨层次边界进行优化的一种策略。 不同类型的边界优化如下：\n跨层级传播常量 跨层级传播相同或相反的信号 跨层级传播未连接的端口信息 推动反向器跨越层级 在子模块输入有很多常量（VCC 和 GND）的情况下，传播可以减少面积。如下图：\n"},{
      "id": "13",
      "rootTitleIndex": "5",
      "rootTitle": "形式验证 Formal",
      "rootTitleIcon": "fa-solid fa-bug-slash fa-lg",
      "rootTitlePath": "/formal/",
      "rootTitleTitle": "主页 / 形式验证 Formal",
      "permalink": "/formal/theorem_proving/",
      "permalinkTitle": "主页 / 形式验证 Formal / 定理证明",
      "title": "定理证明",
      "content":"Theorem proving 是一种验证RTL功能和model是否match的手段。它使用的是纯数学方法推导。\n一文了解定理证明器 ACL2 使用 ACL2 进行硬件验证 "},{
      "id": "14",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/03.structure-and-union/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / 结构体和联合体",
      "title": "结构体和联合体",
      "content":"结构体# 结构包含具有不同大小的不同数据类型，这些数据类型分组在一个结构体名称下。默认情况下，结构体最初是未压缩的形式，但我们可以使用“packed”关键字将其转换为压缩结构。结构与普通数组不同，因为数组仅使用相同类型和大小的元素，而结构体使用不同的数据类型。使用“struct”关键字声明的非压缩结构。\n下图显示了 System Verilog 中不同类型的结构体。\n结构体类型\n1.非压缩结构体 2.压缩结构体\n非压缩结构体# 非压缩结构是默认的结构语法，与普通结构体相同。不同的变量在结构内部保存不同的数据，称为结构成员。结构成员被视为自变量。当我们想给结构体的成员赋值时，可以使\u0026rsquo;structure name. variable\u0026rsquo;的方式访问。\n赋值给结构体成员：\nstructure name = \u0026lsquo;{value1, value2, value3};\n赋值的替代方法：\nstructure name = \u0026lsquo;{variable1 : value1 , variable2 : value2 , variable 3 : value3};\n该方法一步完成初始化。变量和值可以用冒号“.”分隔。\n语法：\nstruct{ list of different types of variables with sizes } structure name;\n示例：\nstruct{\nstring name;\nbit[15:0] salary;\nbyte id;\n} employee_s;\n下图显示了非压缩结构的数据对齐情况。\n\u0026lsquo;string\u0026rsquo; 为 sam 占用 24 位，这里 string 被视为 ascii 字符。然后 16 位表示位[15:0]，8 位表示字节。这里比特流大小是 48。未压缩的结构比压缩的结构具有更多的内存占用。\n压缩结构体# 压缩结构体可以使用 Packed 关键字显式完成。它以指定的顺序以连续形式存储结构体的所有成员。在 RTL 代码中，压缩结构体被视为单个向量，结构体中的每个数据类型都表示为位字段。整个结构体在内存中毫无间隙地压缩在一起。只有压缩数据类型（如 bit , logic and integer 数据类型）才允许在压缩结构体中使用。\n注意：如果结构体不能表示为向量，则无法压缩。\n语法：\ntypedef struct packed{\nlist of different types of variables with sizes\n} structure name;\n示例：\ntypedef struct packed{\nbyte id;\nbit[7:0]experience;\nlogic[15:0]salary;\n}employee_ details_s;\n下图展示了压缩结构体的数据对齐情况。\n“字节”占用 8 位，位[7:0] 为 8 位，逻辑[15:0] 为 16 位。这里比特流大小为 32 位。封装结构比非封装结构占用空间更小。\n压缩结构和非压缩结构的区别# 压缩结构 非压缩结构 struct Packed 关键字用于定义压缩结构 struct 关键字用于定义解包结构 由于单 bit 数据声明，内存占用更小 更大的内存占用，因为它包含所有数据类型 不能使用字符串数据类型，仅允许使用压缩数据类型和整数数据类型 可以使用所有数据类型。 它用在RTL代码中，因为它可以综合代码 它不在RTL代码中使用，因为它无法通过综合工具综合 整个结构体压缩在一起，没有内存间隙 未压缩结构体没有压缩 联合体# 联合体类似于结构体，但联合体共享内存位置。最大数据类型大小将是联合体中所有成员的内存大小。 “union”关键字用于定义联合体。它们有两种类型：压缩联合体和非压缩联合体。\n非压缩联合体# 非压缩联合体使用关键字“union”关键字。它使用 int、byte、bit、logic 等数据类型。整个联合成员只应采用最大的数据类型大小。在这种情况下，有时整个内存空间可能不会被所有联合体成员使用。一个变量的值更改也会影响联合体内的其他成员。\n语法：\nunion {\nlist of elements\n} Union_name\n示例：\nunion {\nint x;\nbyte y;\n} data_u;\n非压缩联合体的数据对齐：\n下图展示了非压缩联合体的数据对齐\n图显示“int”占用 32 位，“byte”占用 8 位。但在解压缩的联合体中，所有成员共享内存。这里“int”是最大的数据类型，因此联合体中的所有其他成员共享 32 位。\n压缩联合体# 压缩联合体由“union Packed”关键字定义。它仅使用相同类型的元素，例如具有相同大小的 \u0026lsquo;bit\u0026rsquo; 、 \u0026rsquo;logic\u0026rsquo; 、 \u0026lsquo;reg\u0026rsquo; 。这是压缩联合体的限制之一。\n语法：\ntypedef union packed {\nlist of different elements\n} Union_name;\n示例：\ntypedef union packed {\nbit [7:0];\nbit [7:0]; } abc_u ;\n非压缩联合体的数据对齐：\n下图展示了压缩联合体的数据对齐\n该图显示使用位数据类型和 8 位大小。在打包联合内部，所有成员应该是相同类型的元素和相同的大小。这里为所有联合成员分配了 8 位大小。\n结构体和联合体的区别# 结构体 联合体 struct关键字用于创建结构体变量 union关键字用于定义联合体变量 一次处理不同类型的元素 一次处理单一类型的元素 每个结构元素单独获取内存 每个元素分别地共享内存空间 其他元素改变时，元素的值不会改 元素值改变时，该元素值也会改变 结构体变量大小等于或大于元素之和 联合体变量的大小与最大数据类型的大小相同 "},{
      "id": "15",
      "rootTitleIndex": "3",
      "rootTitle": "综合 Synthesis",
      "rootTitleIcon": "fa-solid fa-sitemap fa-lg",
      "rootTitlePath": "/synthesis/",
      "rootTitleTitle": "主页 / 综合 Synthesis",
      "permalink": "/synthesis/",
      "permalinkTitle": "主页 / 综合 Synthesis",
      "title": "综合 Synthesis",
      "content":" 逻辑综合 综合优化技术：Datapath 优化 综合优化技术：自动打平 综合优化技术：边界优化 高阶综合 "},{
      "id": "16",
      "rootTitleIndex": "4",
      "rootTitle": "ECO",
      "rootTitleIcon": "fa-solid fa-eraser fa-lg",
      "rootTitlePath": "/eco/",
      "rootTitleTitle": "主页 / ECO",
      "permalink": "/eco/",
      "permalinkTitle": "主页 / ECO",
      "title": "ECO",
      "content":" No data available "},{
      "id": "17",
      "rootTitleIndex": "5",
      "rootTitle": "形式验证 Formal",
      "rootTitleIcon": "fa-solid fa-bug-slash fa-lg",
      "rootTitlePath": "/formal/",
      "rootTitleTitle": "主页 / 形式验证 Formal",
      "permalink": "/formal/",
      "permalinkTitle": "主页 / 形式验证 Formal",
      "title": "形式验证 Formal",
      "content":"形式验证，是指从数学上完备地证明或验证电路的实现方案是否确实实现了电路设计所描述的功能。\n形式验证主要是用来在覆盖所有可能的输入情况下检查是否与给定的规范一致。\n形式验证方法分为等价性验证、模型检验和定理证明等。SoC验证的形式化方法主要是等价性检查和模型检查。\n模型检查 等价性检查 定理证明 一文了解定理证明器 ACL2 使用 ACL2 进行硬件验证 "},{
      "id": "18",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/04.user-defined/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / 用户自定义类型",
      "title": "用户自定义类型",
      "content":"Typedef# Typedef 用于根据较长的数据类型规范创建新的标识符。它类似于alias命令。 Typedef 主要用于 System Verilog 中的复杂测试平台，因为它用代码中的标识符替换了较长的数据类型，如 int(unsigned longint,signed Shortint)、byte、bit[7:0]、logic[7:0]。 Typedef 在类、结构和枚举中使用，使数据类型声明更容易。\n语法：\ntypedef \u0026lt;base_type\u0026gt; \u0026lt;size\u0026gt; \u0026lt;type_name\u0026gt;;\n在类中的 Typedef# Typedef 在类中的主要用途是有时我们在声明类本身之前使用类变量。这时候就会导致代码出现一些编译错误。因此，为了避免编译错误，我们可以在类本身的声明之前使用“typedef 类变量”。\n语法：\ntypedef class class_name;\n示例\ntypedef class fruit2;\nclass fruit1; fruit2 f;\nendclass\nclass fruit2 fruit1 f;\nendclass\n在结构体中的 Typedef# 如果没有 Typedef，Structure 在大型复杂测试平台中可能会出现一些编译错误。 Typedef 还提供了使声明变得更加容易的功能。\n语法：\ntypedef struct {\ndatatype name;\ndatatype name;\n}structure_name;\n示例\ntypedef struct{\nstring name;\nbyte id;\nlongint age;\n} personal_ details_s;\n在枚举中的 Typedef# Typedef 用于当我们需要多个变量共享相同的枚举值时。如果没有 Typedef，我们将得到语法错误。枚举数据类型为所有值创建新变量。\n语法：\ntypedef enum { values } \u0026lt;type_ name\u0026gt;;\n示例\ntypedef enum { RORITO,\nFLAIRFX,\nREYNOLDS\n}pen_e;\n"},{
      "id": "19",
      "rootTitleIndex": "6",
      "rootTitle": "布局布线 P&amp;R",
      "rootTitleIcon": "fa-solid fa-network-wired fa-lg",
      "rootTitlePath": "/pr/",
      "rootTitleTitle": "主页 / 布局布线 P&amp;R",
      "permalink": "/pr/",
      "permalinkTitle": "主页 / 布局布线 P&R",
      "title": "布局布线 P&amp;R",
      "content":" No data available "},{
      "id": "20",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/05.operators/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / 运算符",
      "title": "运算符",
      "content":"运算符是代表特定数学或逻辑动作或过程的字符。\ns.No. Operator 1. 算术运算符 2. 关系运算符 3. 相等运算符 4. 逻辑运算符 5. 按位运算符 6. 移位运算符 7. 条件运算符 8. 约简运算符 9. 连接和复制运算符 1. 算术运算符# 我们使用算术运算符对变量执行基本数学函数。这些运算符应该已经很熟悉，因为它们大多是常见数学符号的复制。\n下表显示了 SystemVerilog 中算术运算符的完整列表。 2. 关系运算符# 关系运算符一览表\n运算符 描述 a \u0026lt; b a 小于 b a \u0026gt; b a 大于 b a \u0026lt;= b a 小于 或等于 b a \u0026gt;= b a 大于 或等于 b 这些运算符比较操作数并产生 1 位标量布尔值。\n0：如果关系为 false 1：如果关系为 true x：如果任何操作数具有未知的 x 位 3. 相等运算符# 相等运算符用于比较表达式。如果比较失败，则结果为 0，否则为 1。 等式运算符有两种类型。\n相等运算符一览表\n运算符 描述 a === b a 相等于 b, 包括 x 和 z a !== b a 不相等于 b, 包括 x 和 z a == b a 相等于 b, 结果可能是 unknown a != b a 不相等于 b, 结果可能是 unknown 如果逻辑相等 (==) 或逻辑不等 (!=) 的两个操作数都包含未知 (x) 或高阻抗 (z) 值，则比较结果将为未知 (x)。否则，要么是真，要么是假。\n如果大小写相等（===）或大小写不等（!==）的操作数包含未知（x）或高阻（z）值，则将逐位计算结果。\n4. 逻辑操作符# 逻辑运算符与按位运算符类似 在逻辑运算符中，这些表达式返回 1（真）或 0（假）。 为了更好地理解，只有三个逻辑运算符，请遵循下面的备忘单\n逻辑操作符cheat sheet\n5. 按位运算符# 位运算符对两个操作数执行按位运算。 它们获取一个操作数中的每一位，并与另一操作数中的相应位执行操作。如果一个操作数比另一个操作数短，它将在左侧用零扩展以匹配较长操作数的长度。\n按位运算符一览表\nOperator Description ~ negation \u0026amp; 和 | inclusive or ^ exclusive or ^~ or ~^ exclusive nor (equivalence) 6. 移位运算符# 有 2 种类型的移位运算符\n逻辑移位运算符 算术移位运算符 移位运算符一览表\nOperator Description \u0026laquo; shift left logical \u0026raquo; shift right logical \u0026laquo;\u0026lt; shift left arithmetic \u0026raquo;\u0026gt; shift right arithmetic 移位运算符实际上需要两个参数。第一个是我们要移动的信号的名称。第二个参数是我们要移动的位数。\n当我们使用逻辑移位运算符时，在信号移位所需位数后，所有空白位置都用 0 填充。\n7.条件运算符# 要使用条件运算符，我们在？之前写一个逻辑表达式。然后评估该运算符以确定它是 true 还是 false。根据表达式的真假，将输出分配给两个值之一。\n条件运算符的一般语法。\noutput = \u0026lt;condition\u0026gt; ? \u0026lt;true\u0026gt; : \u0026lt;false\u0026gt;\n8.归约运算符# 归约运算符是一元的。 它们对单个操作数执行按位运算以产生单位结果。\n归约运算符一览表\n运算符 描述 \u0026amp; and ~\u0026amp; nand | or ~| nor ^ xor ^~ or ~^ xnor 9.连接和复制运算符# 连接和复制运算符一览表\n运算符 描述 { } 连接运算符 {{ }} 复制运算符 连接运算符将两个或多个信号组合成一个向量。 连接使用大括号字符 { 和 } 表示， 用逗号分隔其中的表达式。 复制运算符用于将一组位复制 n 次。 "},{
      "id": "21",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/06.control-flow/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / 控制流",
      "title": "控制流",
      "content":" 条件语句# 条件语句用于检查块中的语句是否被执行。条件语句创建语句块。如果给出的表达式是 true，执行块中的语句集，如果表达式为 false，则 else 块语句将最后执行。\n条件语句一览表\nS.No Conditional Statement 1. if 2. if-else 3. if-else ladder 4. unique if 5. unique0 if 6. priority if 不同条件表达式之间的差异# 条件 if elseif unique if unique0 if priority if 只有一个条件表达式为真 执行 true 条件块内的语句集 执行 true 条件块内的语句集 执行 true 条件块内的语句集 执行 true 条件块内的语句集 多个条件表达式为真 执行第一个 true 条件块语句，不显示警告 执行第一个为真的条件块语句，显示警告 执行第一个为真的条件块语句，显示警告 执行第一个 true 条件块语句，不显示警告 没有 else，条件表达式都不为真 不执行 true 条件块内的语句, 不显示警告 不执行 true 条件块内的语句, 显示警告 不执行 true 条件块内的语句, 不显示警告 不执行 true 条件块内的语句, 显示警告 警告的目的# unique if、unique0 if 和priority if 是 SystemVerilog 中 if-else 条件语句的更新版本。这些条件语句显示警告，有助于检测死代码或未使用的条件语句。\n死代码# 死代码(Dead code)是对模拟或综合没有任何影响的代码。死代码的示例是从未使用的信号或从未触发的条件。\n死代码不会打扰模拟器或综合工具。然而，它会消耗任何阅读代码的人的精神能量。人们会尝试找出给定语句的目的，可能需要一段时间才能意识到他们正在处理死代码。这使得审查代码和重用代码的成本更高。一般来说，死代码是一种应该避免的技术债务。\ncase 语句# case 语句允许我们执行特定 case 表达式的代码。这将为长代码提供正确的结构，并降低代码的复杂性。\ncase 语句计算给定的表达式，并根据计算值（匹配特定条件）执行与其关联的语句。基本上，它用于根据不同的条件执行不同的操作。\nsystemVerilog case 语句以 case 关键字开始，以 endcase 关键字结束。多个语句的块必须分组在开始和结束语句中。\n流程图：\n语法：\ncase(condition) condition_1: Statements ; condition_2: Statements ; ........... conditon_N: Statements; default : Statements; endcase 没有条件为真的 case 语句\n示例：\nx = 2\u0026#39;b11; case(x) 00 : $display(\u0026#34;Value of x = %0b\u0026#34;, x); 01 : $display(\u0026#34;Value of x = %0b\u0026#34;,x); 10 : $display(\u0026#34;Value of x = %0b\u0026#34;,x); //11 : $display(\u0026#34;Value of x = %0b\u0026#34; ,x); default : $display(\u0026#34;Value of x is not found\u0026#34;); endcase 在上面的示例中，这里的表达式=“x”应该匹配案例项之一，但这里没有条件为真。在此，“11”值被赋予 x，因此案例项“11”与表达式 =“x”不匹配。然后默认执行 get。如果没有一个条件为真，则执行默认语句。这将在输出中显示“找不到 x 的值”。\n使用没有默认值的 Case 语句\n在 case 语句中，使用 default 语句。 default语句是可选的，一个case语句中只能有一个default语句。\n如果给定的 case 条件都不成立，则执行 default 语句中的语句。\n如果没有任何项目与条件匹配并且未给出默认语句，则执行将退出 case 块而不执行任何操作。\n流程图：\nFig -11: flow chart: case statement without default statement 语法：\ncase(condition) condition_1: Statements ; condition_2: Statements ; ........... conditon_N: Statements; endcase 示例：\nx = 2\u0026#39;b01; case(x) 00 : $display(\u0026#34;Value of x = %0b\u0026#34;, x); 01 : $display(\u0026#34;Value of x = %0b\u0026#34;,x); 10 : $display(\u0026#34;Value of x = %0b\u0026#34;,x); 11 : $display(\u0026#34;Value of x = %0b\u0026#34; ,x); endcase 在上面的示例中，使用了 case 语句，而没有使用 default 语句。当所有条件都不成立时，将使用默认语句。在这一条件为真时，它将打印 x 的值为“1”\n在此示例中，如果没有任何 case 条件为 true 或未给出默认语句，则执行将退出 case 块而不执行任何操作\n在 case 语句中使用范围语句并结合使用 inside 语句：\n在此，范围是使用 inside 语句在 case 语句中声明的。\n如果我们想在 case 语句中给出范围值，这将在 inside 语句的帮助下完成。\n语法：\ncase(condition) inside condition_1_[a:b]: Statements ; condition_2:_[c:d] Statements ; ........... conditon_N_[y:z]: Statements; endcase 示例：\ncase(x) inside [2:3] : $display(\u0026#34;Value of x = %0d\u0026#34;, x); [4:5] :$display(\u0026#34;Value of x = %0d\u0026#34;,x); [6:9] : $display(\u0026#34;Value of x = %0d\u0026#34;,x); [8:9] : $display(\u0026#34;Value of x = %0d\u0026#34; ,x); default : $display(\u0026#34;Value of x is not found\u0026#34;); endcase 在上面的示例中，我们使用 inside 语句在 case 语句中声明范围。在此，他们将通过使用内部语句从声明的范围中获取值。\n在 case 语句中使用 Break 语句：\n不允许在循环内使用 break 语句。在 case 语句中使用 break 时，会发生错误。\nSyntax\ncase(condition) inside condition_1: Statements ; condition_2: begin Statements ; break; end ........... conditon_N: Statements; endcase 示例：\ncase(x) 00 : $display(\u0026#34;Value of x = %0b\u0026#34;, x); 01 : begin $display(\u0026#34;Value of x = %0b\u0026#34;,x); break; end 10 : $display(\u0026#34;Value of x = %0b\u0026#34;,x); 11 : $display(\u0026#34;Value of x = %0b\u0026#34; ,x); default : $display(\u0026#34;Value of x is not find\u0026#34;); endcase 在上面的例子中，我们在 case 语句中使用了一个break语句。这将引发错误，即 case 语句中不允许使用 break 语句。\n使用 disable 关键字禁用任务内的嵌套循环\n在任务后面使用disable关键字只会禁用任务和命名块。禁用语句会停止执行指定的一组语句。\n示例：\ntask nes(); for (int i=1;i\u0026lt;=3;i++) begin for(int j=1;j\u0026lt;=3;j++) begin if(i==2) begin disable nes; end $display(\u0026#34;\\t i= %0d , j= %0d \u0026#34;,i,j); end end endtask endmodule:nested_loop 在上面的示例中，disable 关键字用于在特定迭代中禁用任务。在任务内部，我们声明了两个嵌套的“for”循环，其中我们使用 if 条件并使用禁用关键字从循环中移出。在任务内部，“if”条件已在迭代“2”处声明。在迭代“2”时，如果条件匹配，它将在禁用关键字的帮助下禁用该任务。\nThere are three updates for the case statement in the system Verilog and these are -\nunique case unique0 case priority case 1. unique case# In a unique case, if all the case condition is false, it will display a warning (no match is found for the case statement ) with no error.\nIf all the conditions are true or more than one condition is true, it will read the first right or matched case condition and will display the output with one warning and no error.\nSyntax :\nunique case(condition) condition_1: Statements ; condition_2: Statements ; ............ conditon_N: Statements; endcase 示例：\nall the conditions are false-\nx = 2\u0026#39;b01; unique case(x) 00 : $display(\u0026#34; Value of x is = %0b\u0026#34;, x); //01 : $display(\u0026#34; Value of x is = %0b\u0026#34;, x); 10 : $display(\u0026#34; Value of x is = %0b\u0026#34;, x); 11 : $display(\u0026#34; Value of x is = %0b\u0026#34;, x); endcase In the above example, the unique case statement is used. Here all the conditions are false, this will print the output with a warning and no error.\nOutput Snap:\nThe below figure shows the output of a unique case statement in which no conditions are true.\nFig - 18: Output: In a unique case, no conditions are true In the above output, all the condition is false so the unique case gives a warning with no error.\nGitHub Lab Code link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/conditional_statement/case_variants/unique_case/unique_none_true/unique_case.sv GitHub Lab Output link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/conditional_statement/case_variants/unique_case/unique_none_true/unique_case_op.log more than one condition is true\nIn a unique case, if all the case condition is false, it will display a warning (no match is found for the case statement ) with no error. If all the conditions are true or more than one condition is true, it will read the first right or matched case condition and will display the output with one warning and no error.\n流程图：\nFig -12: flow chart: unique case statement 示例：\nx = 2\u0026#39;b00; unique case(x) 00 : $display(\u0026#34;Value of x is =%0b\u0026#34; , x); 00 : $display(\u0026#34;Value of x is =%0b\u0026#34; , x); 01 : $display(\u0026#34;Value of x is =%0b\u0026#34; , x); 10 : $display(\u0026#34;Value of x is =%0b\u0026#34; , x); 11 :$display(\u0026#34;Value of x is =%0b\u0026#34; , x); endcase In the above example, a unique case statement is used. In the unique case, if more than one condition is true, it will read the first right or matched case condition and will display the output with one warning and no error. If these two condition is true, at the time of execution this will take the first matched condition and print the value of x = \u0026lsquo;0\u0026rsquo; with a warning(no error)\nOutput Snap:\nThe below figure shows the output of a unique case statement in which more than one condition is true.\nFig -19: Output: unique case in which more than one condition is true In the above output, a unique case statement is used. In this more than one condition is true, the unique case will read the first matched condition and will give the Value of x = \u0026lsquo;0\u0026rsquo; with a warning (no error).\nGitHub Code Lab link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/conditional_statement/case_variants/unique_case/unique_case_default/unique_case_default.sv GitHub Lab Output link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/conditional_statement/case_variants/unique_case/unique_case_default/unique_case_default_op.log unique case with default statement# In this, we will use the default statement inside the unique case statement. If none of the conditions is true inside the unique case statement then the default statement will get executed.\n流程图：\nFig -13: flow chart: unique case with default statement 语法：\nunique case(condition) condition_1: Statements ; condition_2: Statements ; ............ conditon_N: Statements; default : Statements; endcase 示例：\nx = 2\u0026#39;b01; unique case(x) 00 : $display(\u0026#34;Value of x is =%0b\u0026#34; , x); // 01 : $display(\u0026#34;Value of x is =%0b\u0026#34; , x); 10 : $display(\u0026#34;Value of x is =%0b\u0026#34; , x); 11 : $display(\u0026#34;Value of x is =%0b\u0026#34; , x); default :$display(\u0026#34;Value of x is =%0b\u0026#34; , x); endcase In the above example, the default statement is used inside the unique case statement.\nIn this, if no conditions of the case statement are true then the default statement will get executed.\nOutput Snap:\nThe below figure shows the output of a unique case statement by using the default statement.\nFig - 20: Output: no conditions are true, default statement gets executed In the above output, there is no condition is true inside the case statement, then the default statement is get executed and prints the \u0026lsquo;Value of x = 1\u0026rsquo; in the output.\nGitHub Code Lab link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/conditional_statement/case_variants/unique_case/unique_case_default/unique_case_default.sv GitHub Lab Output link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/conditional_statement/case_variants/unique_case/unique_case_default/unique_case_default_op.log 2. uniuqe0 case# In the unique0 case, if all the case condition is false, it will not display a warning with no error.\nIf all the conditions are true or more than one condition is true, it will read the first right or matched case condition and will display the output with one warning and no error.\nSyntax :\nunique0 case(condition) condition_1: Statements ; condition_2: Statements ; ........... conditon_N: Statements; endcase 示例：\nx = 2\u0026#39;b01; unique0 case(x) 00 : $display(\u0026#34; Value of x is = %0b\u0026#34;, x); 01 : $display(\u0026#34; Value of x is = %0b\u0026#34;, x); 10 : $display(\u0026#34; Value of x is = %0b\u0026#34;, x); 11 : $display(\u0026#34; Value of x is = %0b\u0026#34;, x); 01 : $display(\u0026#34; Value of x is = %0b\u0026#34;, x); endcase In the above example, the unique0 case is used. In these two conditions is true and unique0 will read the first right or matched condition and print the output Value of x = \u0026ldquo;1\u0026rdquo; with the warning.\nOutput Snap:\nThe below figure shows the output of the unique0 case statement in which two conditions are true.\nFig -21: Output: unique0 case in which two conditions are true In the above output, two conditions are true at a time this will make the case statement not unique, uniquq0 will read the first right matched condition and display the Value of x is 1 with the warning\nGitHub Code Lab link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/conditional_statement/case_variants/unique0_case/unique0_case.sv GitHub Lab Output link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/conditional_statement/case_variants/unique0_case/unique0_case_op.log 3. priority case# In this type of case statement, if more than one case condition is true, it will display the output without giving any error with no warning.\n流程图：\nFig -14: flow chart: priority case statement 语法：\npriority case(condition) condition_1: Statements ; condition_2: Statements ; ........... conditon_N: Statements; endcase 示例：\npqr = 5; priority case (pqr) 5 : $display (\u0026#34;Found to be 5\u0026#34;); 5 : $display (\u0026#34;Again found to be 5\u0026#34;); 7 : $display (\u0026#34;Found to be 7\u0026#34;); endcase In the above example, the priority case is used. In these two conditions is the right or matched condition so the priority case will read the first right condition and execute it and display the output with no warning and no error.\nOutput Snap:\nThe below figure shows the output of the priority case statement in which two conditions are true.\nFig -22: Output: priority case statement in which two conditions are true In the above output, more than one condition is true. priority case checks the first right matched condition, executes it, and displays the output without warning and error.\nGitHub Code Lab link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/conditional_statement/case_variants/priority_case/priority_case.sv GitHub Lab Output link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/conditional_statement/case_variants/priority_case/priority_case_op.log break# A break statement is used to terminate the loop immediately. When a break statement is encountered inside a loop, the loop iteration stops there. Generally, we use break after giving the condition in code using the if statement.\nWe can use break statements in any loop(for, foreach, forever, do-while, while, do-while,), for terminating the execution of a loop. It is always used inside the loop. The break statement ends the loop immediately when it is encountered.\n流程图：\nFig-:15 flow chart: break statement Syntax:\nbreak;\n示例：\nforeach(array[i]) if(i==2)begin $display(\u0026#34;----Calling break----\u0026#34;); break; end In the above example, a break statement is used inside the loop which terminates the loop when condition is true. In this break is used at index 2 so that the loop stops at index 2 and comes out of the loop.\nOutput Snap:\nThe below figure shows the output of using the break statement.\nFig -23 : Output: break statement gets executed at iteration 2 In the above output, a break statement is used inside the loop. The output shows the value for index 0 \u0026amp; 1, after this break statement is encountered and display \u0026ldquo;Calling break\u0026rdquo;\nGitHub Lab Code link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/break_continue/break/break.sv GitHub Lab Output link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/break_continue/break/break_op.log continue:# The continue statement is used to skip the current iteration of a loop. We can use the continue statement inside any type of loop such as for, while, and do-while loop. Basically, continue statements are used in situations when we want to continue the loop but do not want the particular iteration in the loop.\nUsing continue, we can skip the current iteration of a loop and jumps to the next iteration of the loop immediately\n流程图：\nFig - 16: flow chart: continue statement Syntax:\ncontinue;\n示例：\nforeach(array[i]) begin if(i==2)begin $display(\u0026#34;-----Calling Continue----\u0026#34;); continue; end In the above example, continue statement is used inside the loop that skips the current iteration of a loop. In the following loop continue is used at index 2 so that the loop skips the particular iteration at index 2 and goes for the next iteration.\nOutput Snap:\nThe below figure shows the output of using the continue statement.\nFig -24 : Output: continue statement executes at iteration 2 In the above output, the continue statement is used inside the loop. The output shows the value for iterations 0 \u0026amp; 1 and for iteration 2 continue statement is encountered and displays \u0026ldquo;Calling continue\u0026rdquo; and after this jumps to the next iteration immediately and prints the value for iterations 3 \u0026amp; 4\nGitHub Lab Code link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/break_continue/continue/continue.sv GitHub Lab output link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/break_continue/continue/continue_sv_op.log "},{
      "id": "22",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/07.functions/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / 函数",
      "title": "函数",
      "content":"函数的主要用途是编写一段可以随时调用n次的代码，只需调用函数名即可，不需要任何模拟时间来执行。\n函数是返回类型，仅返回函数声明中提到的单个值，如果未声明则返回一个位的值。\n语法：\ninitial begin function_name(arguments); end function \u0026lt;return_type(optional)\u0026gt; function_name(arguments);` statement1; statement2; . . statementN; endfunction 限制：\n函数内部的代码中不允许有#、@、wait等耗时语句 只能返回一个值 无法从函数中调用任务，因为任务允许有耗时的语句 调用函数有很多变体：\n调用以值作为参数的函数 调用以变量作为参数的函数 使用表达式中的值调用函数 C使用带位置参数的变量调用函数 调用自动函数 通过变量的引用调用带有变量的函数 调用返回类型为 void 的函数 通过传递数组来调用函数 调用具有默认值的变量的函数 从函数调用任务（使用 fork 和 join_none 的例外情况） 调用以值作为参数的函数# 示例：\nint result; initial begin result=sum(5,6); $display(\u0026#34;\\treturned from function and\u0026#34;); $display(\u0026#34;\\tstored the value of sum in result\u0026#34;); $display(\u0026#34;\\n\\t@ %0t ns, value of sum is %0d\u0026#34;,$time,result); end function int sum(int var1,var2); $display(\u0026#34;entered into function\u0026#34;); return var1+var2; endfunction 在上面的示例中，函数名称是 sum，其返回类型为 int，即它仅返回一个 int 值。\n流程图：\n调用以变量作为参数的函数# 示例：\nint result,a=5,b=6; initial begin $display(\u0026#34;\\tcalling the function\u0026#34;); result=sum(a,b); $display(\u0026#34;\\treturned from function and\u0026#34;); $display(\u0026#34;\\tstored the value of sum in result\u0026#34;); $display(\u0026#34;\\n\\t@ %0t ns, value of sum is %0d\u0026#34;,$time,result); end function int sum(input int a,b); $display(\u0026#34;entered into function\u0026#34;); return a+b; endfunction 流程图：\n使用表达式中的值调用函数# 示例：\ninitial begin $display(\u0026#34;\\n\\t@ %0t ns, value of sum is %0d\u0026#34;,$time,sum(5,6)); end function int sum(int var1,var2); $display(\u0026#34;entered into function\u0026#34;); return var1+var2; endfunction 使用带位置参数的变量调用函数# 示例：\ninitial begin result=sum(.var1(5),.var2(6)); $display(\u0026#34;\\treturned from function and\u0026#34;); $display(\u0026#34;\\tstored the value of sum in result\u0026#34;); $display(\u0026#34;\\n\\t@ %0t ns, value of sum is %0d\u0026#34;,$time,result); end function int sum(int var1,var2); $display(\u0026#34;entered into function\u0026#34;); return var1+var2; endfunction 调用自动函数# 语法：\nfunction automatic function_name(arguments); 示例：\nmodule func_automatic(); int result1,result2; function int factorial_static(int var1); if(var1\u0026gt;=2) result1=factorial_static(var1-1)*var1; else begin result1=1; end return result1; endfunction function automatic int factorial_automatic(int var1); if(var1\u0026gt;=2) result2=factorial_automatic(var1-1)*var1; else begin result2=1; end return result2; endfunction initial begin result1=factorial_static(5); result2=factorial_automatic(5); $display(\u0026#34;factorial_static:%0d\u0026#34;,result1); $display(\u0026#34;factorial_automatic:%0d\u0026#34;,result2); end endmodule: func_automatic 这里我们使用带有 automatic 关键字的函数，这意味着每当调用该函数时都会创建新的内存，而在 static 中，每当调用该函数时都会使用相同的内存。\n通过变量的引用调用带有变量的函数# 语法：\nfunction automatic data_type function_name(ref arguments); 流程图：\n示例：\nint result,addend,augend; initial begin addend=5; augend=6; $display(\u0026#34;\\tBefore calling function -\u0026gt; addend = %0d , augend = %0d\u0026#34;,addend,augend); $display(\u0026#34;\\tcalling the functions\u0026#34;); result=sum_without_ref(addend,augend); $display(\u0026#34;\\tafter calling function without ref -\u0026gt; addend = %0d, augend =%0d\u0026#34;,addend,augend); result=sum_with_ref(addend,augend); $display(\u0026#34;\\tafter calling function with ref -\u0026gt; addend = %0d, augend =%0d\u0026#34;,addend,augend); end function automatic int sum_with_ref(ref int var1,var2); int temp; $display(\u0026#34;\\n\\tentered into with ref function\u0026#34;); temp=var1; var1=var2; var2=temp; $display(\u0026#34;\\tswapped variables by using ref \u0026#34;); return var1+var2; endfunction : sum_with_ref function int sum_without_ref(input int var1,var2); int temp; $display(\u0026#34;\\n\\tentered into without ref function\u0026#34;); temp=var1; var1=var2; var2=temp; $display(\u0026#34;\\tswapped variables by without using ref \u0026#34;); return var1+var2; endfunction : sum_without_ref 当通过传递变量引用来调用函数时，需要提及关键字 automatic 和 ref，如上例所示。\n调用返回类型为 void 的函数# 语法：\n//type casting void\u0026#39;(function_name(arguments)); 或者\n//declaring the function as void type which doesn\u0026#39;t return any value. function void function_name(arguments); 示例：\ninitial begin display(\u0026#34;\\t ----output for function void return type-----\u0026#34;); display(\u0026#34;\\t passing string to function for displaying\u0026#34;); end function void display(string str); $display(\u0026#34;%s\u0026#34;,str); endfunction: display 通过传递数组来调用函数# 语法：\ndata_type array_name[size]; function automatic return_type function_name(ref data_type array_name); 示例：\nint array[5]; void\u0026#39;(fun_arr(array)); $display(\u0026#34;\\treturned from function\u0026#34;); $display(\u0026#34;\\n\\t@ %0t ns, Array elements = %0p\u0026#34;,$time,array); end function automatic int fun_arr(ref int arr[5]); $display(\u0026#34;\\tEntered the function\u0026#34;); foreach(arr[i])begin arr[i]=i+1; end $display(\u0026#34;\\t values assigned to array elements starts from 1\u0026#34;); return 0; endfunction 一般来说，我们不能从函数返回数组，但可以使用引用传递来传递数组，并且可以在函数中操作该数组。\n调用具有默认值的变量的函数# 语法：\nfunction_name() function \u0026lt;return_type\u0026gt; function_name(varable1=deafult_value,variable2=default_value) 示例：\ninitial begin $display(\u0026#34;\\t ----output for function passing by values through variables-----\u0026#34;); $display(\u0026#34;\\tcalling the function\u0026#34;); result=sum(); $display(\u0026#34;\\treturned from function and\u0026#34;); $display(\u0026#34;\\tstored the value of sum in result\u0026#34;); $display(\u0026#34;\\n\\t@ %0t ns, value of sum is %0d\u0026#34;,$time,result); end function int sum(input int var1=2,var2=3); $display(\u0026#34;\\n\\tentered into function \u0026#34;); return var1+var2; endfunction: sum 在此示例中，调用函数但不传递任何值或变量，那么在这种情况下，函数所需的两个变量将采用分配给它们的默认值，即在本例中为 2 \u0026amp; 3 得出的总和为 5。\n如果调用函数时没有值和变量，并且函数没有任何默认值，则模拟器将抛出错误。\n从函数调用任务# 一般来说，从函数调用任务是非法的，编译器会报错，但有一种特殊情况，可以使用 fork join_none 从函数调用任务，如下例所示。\n示例：\ninitial begin $display(\u0026#34;\\t@ %0t ns, In the initial block\u0026#34;,$time); $display(\u0026#34;\\tcalling function\u0026#34;); #1 void\u0026#39;(function_call); end function function_call; fork $display( \u0026#34;\\t@ %0t ns I\u0026#39;m in function\u0026#34;,$time); $display(\u0026#34;\\t@ %0t ns, calling task from func\u0026#34;,$time); task_call; join_none endfunction task task_call; #1 $display( \u0026#34;\\t@ %0t ns , I\u0026#39;m in task\u0026#34;,$time); #1 $display(\u0026#34;\\t@ %0t ns,leaving from task\u0026#34;,$time); endtask 流程图：\n"},{
      "id": "23",
      "rootTitleIndex": "5",
      "rootTitle": "形式验证 Formal",
      "rootTitleIcon": "fa-solid fa-bug-slash fa-lg",
      "rootTitlePath": "/formal/",
      "rootTitleTitle": "主页 / 形式验证 Formal",
      "permalink": "/formal/theorem_proving/acl2_hardware/",
      "permalinkTitle": "主页 / 形式验证 Formal / 定理证明 / 使用 ACL2 进行硬件验证",
      "title": "使用 ACL2 进行硬件验证",
      "content":"1. Vl# VL Verilog 工具包是一个大型 ACL2 库，用于处理SystemVerilog外部链接（以及 常规 Verilog外部链接）源代码，它作为许多 Verilog 工具的前端。它包含以下部分：\nVerilog 语法的内部表示（Vl-design、Vl-module、Vl-port、Vl-always 等） 用于将 Verilog 源代码解析为这种表示形式的加载器 可以简化这些设计的各种变换（Annotate、Elaborate等过程） 打印和其他报告生成功能 2. Sv# SV 是一个硬件验证库，具有基于向量的 表达式表示（svex）、与 gl 集成的高效符号模拟并支持许多 SystemVerilog 功能。它通常作为vl的后端。\nSV 的核心是基于一种符号表达式语言，该语言表示四值“bits”无限宽度向量 "},{
      "id": "24",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/08.tasks/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / 任务",
      "title": "任务",
      "content":"任务（task）几乎与函数类似，但任务可以计算多个变量并使用输出或 inout 语句返回它们，但不像函数那样必需，即任务不是返回类型，并且任务能够具有诸如 #、@、等待。任务也可以调用另一个任务和函数。\n语法：\ntask_name(arguments); task task_name(arguments); statement1; statement2; . . statementN; endtask 限制：\n任务不可综合 流程图\nautomatic task# 每当声明为 automatic task 时，每次调用该任务时，模拟器都会分配新的内存。一般来说，任务在模块内部是静态的，要使其自动执行，需要添加 automatic 关键字，如下所示。\n语法：\ntask automatic task_name() 示例：\ntask automatic factorial_automatic(int var1); #1; if(var1\u0026gt;=2) begin factorial_automatic(var1-1); result=result*var1; end else begin result=1; -\u0026gt;a; end endtask initial begin fork factorial_static(5); factorial_automatic(5); join fork wait(a.triggered); $display(\u0026#34;@ %0t ns , factorial_automatic:%0d\u0026#34;,$time,result); end 流程图：\n从任务中调用函数# 示例：\ninitial begin $display(\u0026#34;\\t ----output for func from task----\u0026#34;); $display(\u0026#34;\\t@ %0t ns, In the initial block\u0026#34;,$time); $display(\u0026#34;\\tcalling task\u0026#34;); task_sum; $display(\u0026#34;\\treturned to initial from function\u0026#34;); end task task_sum; #1 $display( \u0026#34;\\t@ %0t ns , I\u0026#39;m in task\u0026#34;,$time); $display(\u0026#34;\\tcalling func inside a task\u0026#34;); #1 void\u0026#39;(function_sum); $display(\u0026#34;\\treturned to task from function\u0026#34;); endtask function function_sum; $display( \u0026#34;\\t@ %0t ns I\u0026#39;m in function\u0026#34;,$time); endfunction 从函数中调用任务是非法的，但从任务中调用 func 是正常的，因为函数没有任何耗时的语句。\n流程图：\n全局任务# 如果一个任务是在模​​块和类之外声明的，则该任务被称为全局任务，默认的全局任务本质上是静态的。该全局任务可以从任何模块调用，通过以下示例可以更好地理解。\n示例：\ntask mul(input int var1,var2,output int res); #1 res=var1*var2; endtask module task1(); int multiplicand=5,multiplicator=6,result; initial begin $display(\u0026#34;\\t ----output of global task----\u0026#34;); mul(multiplicand,multiplicator,result); $display(\u0026#34;\\t @ %0t ns , %0d X %0d = %0d\u0026#34;,$time,multiplicand,multiplicator,result); end endmodule module task2(); int r; initial begin #2 mul(7,8,r); $display(\u0026#34;\\t @ %0t ns , 7 X 8 = %0d\u0026#34;,$time,r); end endmodule 禁用任务# 可以通过在任务名称中使用关键字 disable 来禁用任务，这会在调用禁用时停止该特定任务。\n示例：\nmodule disable_task(); initial begin $display(\u0026#34;\\t ----output of disable task----\u0026#34;); fork display_task(); #20 disable display_task.task_A; join end task display_task(); begin : task_A $display(\u0026#34;\\t @ %0t ns , task_A initiated\u0026#34;,$time); #30 $display(\u0026#34;\\t @ %0t ns , task_A finished\u0026#34;,$time); end :task_A begin : task_B $display(\u0026#34;\\t @ %0t ns , task_B initiated\u0026#34;,$time); #10 $display(\u0026#34;\\t @ %0t ns , task_B finished\u0026#34;,$time); end :task_B endtask endmodule "},{
      "id": "25",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/09.loops/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / SystemVerilog 循环",
      "title": "SystemVerilog 循环",
      "content":"循环只不过是将需要多次运行的语句包含在循环中，而不是重复编写这些语句。循环将根据条件语句运行多次，如果条件始终为真，则它会变成无限循环，系统将挂起。\n循环一览表# S.No. 循环变量 解释 1. while 根据条件重复语句集 2. do_while 先运行语句而不检查条件，行为就像 while 3. repeat 仅重复语句特定次数 4. for_loop 与 while 类似，但比 while 更紧凑 5. foreach 仅用于遍历数组的每个元素 6. forever 在整个模拟过程中重复这些语句 1. while# 在 while 循环中，首先我们需要检查条件，然后才能执行语句。我们需要在执行之前初始化条件中的变量。\nwhile 循环首先检查条件是否为真，如果为真则执行语句。如果条件为假，循环就在那里结束。\n语法 -\nwhile(condition)begin Statements; end 流程图：\n2. do-while# 在do-while循环中，首先执行一次条件，然后检查条件是否成立。如果条件为真，则执行该组语句，直到条件为假为止。如果条件为假，循环就在那里结束。\n语法 -\ndo begin Statements; end while(condition)begin Statements; end 流程图：\n3.repeat# 该循环用于将语句或操作重复固定给定的次数。\n语法 -\nrepeat(no. of times)begin statements; end 示例： -\n下面的示例显示了重复循环的工作原理。这里，重复循环内有三个语句。重复4次。\n代码快照\nmodule repeat_code; initial begin ; repeat(4)begin // Repeat the statements inside 4 times $display (\u0026#34;Good morning\u0026#34;); $display (\u0026#34;Keep shining\u0026#34;); $display (\u0026#34;--------------\u0026#34;); end end 流程图：\n4.for loop# For loop is simply a more compact form of while loop. In for loop assignment, there are three parts:\nInitialization - initialize the required variables for running the loop. condition - based on this condition the number of repetitions of for loop is dependent. modifier - incrementing/decrementing the variables. 语法:\nfor ( Initialization; condition; modifier ) begin statement1; statement2 . . statementN; end 示例：:\nfor (int i=1;i\u0026lt;=5;i++) begin $display(\u0026#34; Iteration %0d \u0026#34;,i); end $display(\u0026#34; out of loop \u0026#34;); In the above 示例：, i is the variable initialized and declared as 1, here i is the local scope only means we can\u0026rsquo;t use i out of for loop. In condition i should be less than or equal to 5 means for loop statements will be executed if the value of i is matched with condition or else comes out of the loop and the last part is the modifier which is incrementing i value by 1.\n流程图：\nFlowchart.4- for loop flowchart output:\nFig.6 - for loop output As per the flowchart initially, i is 1 so the condition satisfies and performs display statement and prints as \u0026ldquo;iteration 1\u0026rdquo; and then goes to modifier and increments i, check the condition again and so on till i=5, now after 5 i is incremented to 6 then checks condition which is failed so comes out of the loop.\nGithub lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/loops/for/for_loop/for_code.sv Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/loops/for/for_loop/for_loop_output.log Note: If you use a local scope variable outside then the compiler throughs an error as shown below.\nFig.7 - error of for loop local scope variable usage out of loop Nested for loop\n语法:\nfor ( Initialization ; condition; modifier ) begin statements; for ( Initialization ; condition ; modifier ) begin statements; end end 示例：:\nfor (int i=1;i\u0026lt;=2;i++) begin $display(\u0026#34;\\n\\t%0d Table:\\n\u0026#34;,i); for(int j=1,k=0;j\u0026lt;=10;j++) begin k=i*j; $display(\u0026#34;\\t %0d X %0d = %0d\u0026#34;,i,j,k); end end In the above 示例： we are using nested for loop to print tables, so took i as table number and j for going from 1-10 and k to store the value of multiplication. Here observe that j \u0026amp; k are used at the same initialization and you can do the same for conditions and modifiers also to have multi variables at a time.\noutput:\nFig.8 - nested for loop output In this i,j\u0026amp; k are used as i X j = k, so i is range from 1-2 and each has j from 1-10 and k is storing and printing using display statements.\nGitHub lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/loops/for/nested_for/table_for_loop.sv GitHub lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/loops/for/nested_for/tabe_for_loop_output.log Advantages:\nReadable 语法 will be easier(can mention all initialization,condition, modifier in a single place) limitations:\nvariables initialized are only local. 5.foreach# This loop is an upgraded version of for loop for traversing through each element of an array. This iterates through index 0 till the size of an array mentioned.\nforeach is a shorter version of the following for loop\nfor(int i=0;i\u0026lt;$size(array);i++) 语法:\nforeach(array[i]) begin statement1; statement2 .` . statementN; end 示例：:\nint array[5] foreach(array[i]) begin array[i]=i; $display(\u0026#34;\\tarray[%0d]=%0d\u0026#34;,i,array[i]); end $display(\u0026#34; out of loop \u0026#34;); In the above 示例：, a fixed array of size 5 is taken, using a foreach loop to traverse through each element, and executes the statements of the foreach loop from array[0] to array[4].\n流程图：\nFlowchart-5.foreach loop flowchart output:\nFig.9 - foreach loop output As per the flowchart initially checks for the size of the array, as it is \u0026gt;0, so proceeds to execution of foreach statements i.e., assigns array[0]=0 and displaying the same and then increments i value by 1 and repeats the same until array[4]. Then at array[5] condition is failing because the array size is 5 only (i.e., 0,1,2,3,4) comes out of loop.\nGithub lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/loops/foreach/foreach_loop/foreach_loop.sv Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/loops/foreach/foreach_loop/foreach_loop_log.log The same functionality of above program we can achieve by using for loop as following line replaced with foreach.\nfor(int i=0;i\u0026lt;$size(array);i++) The following is the snap of output of foreach using for loop output of foreach using for loop:\nFig.10 - foreach using for output Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/loops/foreach/foreach_using_for/foreach_using_for.sv Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/loops/foreach/foreach_using_for/foreach_using_for_log.log Note: we can use nested foreach similarly as used in nested for loop and can access multidimensional arrays.\nAdvantages:\n语法 is easier. Readable limitations:\nIt is only used for arrays Modifier is not accessible(if we want to store array only in even positions then foreach not good option) Cannot traverse through array in reverse fashion 6.forever# The forever loop name itself says that it will run forever i.e., throughout the simulation or forcefully shut down the forever loop.\nIt is similar to the always procedural block in System Verilog but generally, it\u0026rsquo;s not possible to use always in classes to achieve that concept we can make use of this forever loop.\nIf we use a forever loop without force stop the compiler will hang. There are two ways to stop forever, they are\n$finish;\nbreak;\nforever with $finish:# forever loop doesn\u0026rsquo;t have any conditions as the number of times to repeat the loop is infinite so no condition is needed. 语法:\nforever begin statement1; statement2 . . statementN; end 示例：:\nforever begin $display(\u0026#34;\\t @ %0d ns Iteration %0d\u0026#34;,$time,a); a++; #4; end initial begin #20 $display(\u0026#34;\\n\\t@ %0d ns Stopped using $finish\u0026#34;,$time); $finish; end In the above 示例：, forever is used which is having display statement and increment a and a 4ns delay for every repetition like that it will run forever but in another initial block there is $finish which will stop the simulation so this stops the forever also.\n流程图：\nFlowchart-6.forever with finish flowchart output:\nFig.11 - forever with finish output As the forever doesn\u0026rsquo;t have any condition it simply enters and displays a value and then a is incremented and a 4ns delay is introduced so for every 4ns the output is getting printed and at 20 ns $display and prints stopped using $finish is executed in second initial module as well as $finish is called in which will terminate the simulation.\nGithub lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/loops/forever/forever_loop_finish/forever_loop.sv Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/loops/forever/forever_loop_finish/forever_loop_output.log forever with break:# 语法:\nforever begin statement1; statement2 . . statementN; end 示例：:\nforever begin $display(\u0026#34;\\t @ %0d ns Iteration %0d\u0026#34;,$time,a); a++; #4; if(a\u0026gt;8) break; end $display(\u0026#34;\\n\\t@ %0d ns Stopped using break\u0026#34;,$time); end This is similar 示例： of forever with $finish but here we have used break condition instead of $finish based on a value greater than 8.\n流程图：\nFlowchart-4.forever using break flowchart output:\nFig.12 - forever with break output As the forever doesn\u0026rsquo;t have any condition it simply enters and displays a value and then a is incremented and a 4ns delay is introduced so for every 4ns the output is getting printed after a value greater than 8 then enters into if block which has a break which moves simulator to out of the loop.\nGithub lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/loops/forever/forever_loop_break/forever_loop.sv Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/loops/forever/forever_loop_break/forever_loop_output.log advantages:\nwe cant use always block inside an always or a class there this forever is used and can achieve the same job limitations:\nIf we don\u0026rsquo;t quit the forever then the simulator will hang. "},{
      "id": "26",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/10.scheduler-schematics/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / Scheduler schematic",
      "title": "Scheduler schematic",
      "content":"Scheduler schematic# The scheduling schematics are used to describe the element\u0026rsquo;s behavior and their interaction with each other. This interaction is described for event execution and its scheduling. It is important to note that Verilog and System Verilog is like a parallel programming language in terms of blocks or process executions.\nBefore going to the regions we have to know about simulation time and time slot.\nThe term simulation time is used to refer to the time value maintained by the simulator to model the actual time it would take for the system description being simulated.\nA time slot encompasses all simulation activity that is processed in the event regions for each simulation time. All simulation activity for a particular simulation time is executed until no further simulation activity remains for that time slot, that is, without advancing the simulation\ntime.\n\u0026ldquo;Note that execution of simulation events within a time slot may require multiple iterations through the simulation event regions for that same time slot.\u0026rdquo;\nEvents# Event is used for synchronization between two or more concurrently active processes. Initially, we need to declare the event and then it needs to be triggered by using the -\u0026gt; or -\u0026raquo; operator.\nProcesses can wait for the event by using the @ operator or wait(event_name.triggered). when both @ and wait comes at the same point then a race-around condition occurs in between both.\nCreate an event:-\nevent e; Triggering the event:-\n-\u0026gt;e; Wait for the event to be triggered:-\n@e; or wait(e.triggered); Event regions in verilog:# Fig-1: Verilog event regions. Event regions in system verilog:# Fig-2: System verilog event regions. Explinations.# Regions that are designed to implement correct RTL functionality:\n• Active regions (Active, Inactive and NBA regions).\nRegions that are designed to implement correct verification execution:\n• Preponed, Reactive regions (Reactive, Re-Inactive, Re-NBA) and Postponed regions.\nRegions that are designed to implement concurrent assertion checking:\n• Preponed, Observed, and Reactive regions.\nRegion that should be avoided:\n• Inactive region.\nLet\u0026rsquo;s discuss about all the regions of System Verilog\n1. preponed region# The function of this region is to sample values that are used by concurrent assertions. The Preponed region is executed only once in each time slot, immediately after advancing simulation time (there is no feedback path to re-execute the Preponed region).\nThere is some doubt as to whether an implementation actually must perform the sampling in the Preponed region or if the sampling may be done in the Postponed region of the previous time slot. Because both, Postponed and Preponed are read-only regions.\n\u0026ldquo;The values of variables used in assertions are sampled in the Preponed region of a time slot, and the assertions are evaluated during the Observed region.\u0026rdquo;\nSampled values are always defined with respect to a clocking expression. Therefore, it is only necessary to sample values in the Preponed region of the time slot in which the clocking expression is triggered, and not in every time slot.\n2. Active Region set# This Active region set includes i. Active region ii. Inactive region and iii. NBA region.\nThe Active region set is used to schedule blocking and non-blocking assignments included in the module.\nAll tasks and functions called from a module also scheduled in the active region set.\nThe Active region set is used to schedule the RTL and behavioral code.\nFig-3: The blocks of Active region set. i. Active region# The Active region holds the current active region set events being evaluated and can be processed in any order.\nThe function of this region is to evaluate and execute all current module activity in any order:\n• Execute all module blocking assignments.\n• Execute all module continuous assignments.\n• Evaluate the Right-Hand-Side (RHS) of all non-blocking assignments and schedule updates into the NBA region.\n• Evaluate inputs and update outputs of Verilog primitives.\n• Execute the $display and $finish commands.\nii. Inactive regions# The Inactive region holds the events to be evaluated after all the Active events are processed.\nIf events are being executed in the active region set, an explicit #0 delay control requires the process to be suspended and an event to be scheduled into the Inactive region of the current time slot. so that the process can be resumed in the next Inactive to Active iteration.\nMost of the users are continue to use #0 assignments to defeat a race condition that might exist in their code due to assignments made to the same variable from more than one always block. users that follow good coding practices will have no need for #0 RTL assignments and hence, the Inactive region is unused.\niii. NBA region# The function of this region is to execute the updates to the Left-Hand-Side (LHS) variables that were scheduled in the Active region for all currently executing non-blocking assignments.\nThe NBA (non-blocking assignment update) region holds the events to be evaluated after all the Inactive events are processed.\nIf events are being executed in the active region set, a non-blocking assignment creates an event in the NBA region scheduled for the current or a later simulation time.\n3. observed region# The function of this region is to evaluate the concurrent assertions using the values sampled in the Preponed region. Assertions that execute a pass or fail action block, actually schedule a process associated with the pass and fail code into the Reactive regions, not in the Observed region.\nThis is because concurrent assertions are designed to behave strictly as monitors, they are not allowed to modify the state of the design. But, assertions cannot schedule any Active region events.\n4. Re-Active region set# This Re-Active region set includes i. Re-Active region ii. Re-Inactive region and iii. Re-NBA region.\nThe reactive region set is used to schedule blocking assignments, #0 blocking assignments and non-blocking assignments included in program code. Any task or function called from a program is also scheduled into the reactive set event regions.\nThe intended purpose of the reactive region set is to schedule testbench stimulus drivers and testbench verification checking in the same time slot after RTL code has settled to a semi-steady state.\nFig-4: Blocks of Re-Active region set. i. Re-Active region# The Re-Active region holds the current reactive region set events being evaluated and can be processed in any order. The code specified by blocking assignments in checkers, program blocks and the code in action blocks of concurrent assertions are scheduled in the Re-Active region.\nThe principal function of this region is to evaluate and execute all current program activity.\n• Execute all program blocking assignments. • Execute all program continuous assignments • Execute the pass/fail code from concurrent assertions. • Evaluate the Right-Hand-Side (RHS) of all program non-blocking assignments and schedule updates into the Re-NBA region. • Execute the $exit and implicit $exit commands.\nThis region is used to execute the verification processes spawned by program blocks. Because the Reactive region is located towards the end of the time slot, a process that executes at this point in the simulation has access to three key pieces of information:\nThe current set of steady-state Active region set values – at the start of the current time slot. The next set of steady-state Active region set values - after clock and signal propagation. The disposition of all concurrent assertions triggered in this time slot.\nAll this information enables more powerful and flexible verification techniques without forcing users to resort to specialized synchronization code.\nThe processes that execute when processing the Reactive region typically drive back the stimulus into the design. ii. Re-Inactive region# The Re-Inactive region iterates with the Reactive region until all Reactive/Re-Inactive events have completed. Then, within the same time slot, the RTL regions (Active-Inactive-NBA) will re-trigger if the program execution scheduled any events in those regions in the same time slot.\nEvents are scheduled into the Re-Inactive region by executing a #0 in a program process. However, that recommendation does not apply when dealing with verification code, where it is often useful (and harmless) to add some determinism to the scheduler.\nFor example, when forking background processes, it is often very useful to allow the newly created sub-processes a chance to start executing before continuing the execution of the parent process. This is easily accomplished with the following code:\niii. Re-NBA region# The Re-NBA region holds the events to be evaluated after all the Re-Inactive events are processed.\nIf events are being executed in the reactive region set, a non-blocking assignment creates an event in the Re-NBA region scheduled for the current or a later simulation time.\nThe principal function of this region is to execute the updates to the Left-Hand-Side (LHS) variables that were scheduled in the Re-Active region for all currently executing non-blocking assignments that were evaluated in the Reactive region.\nAs currently defined, the Re-NBA region iterates with the Reactive and Re-Inactive regions until all Reactive region set events have completed. Then, if program execution scheduled any Reactive region events that could trigger Active region set events in the same time slot, the Active set regions (Active-Inactive-NBA) will re-trigger and iterate until the Active region set events have completed.\n5. posponed region# The function of this region is to execute the $strobe and $monitor commands that will show the final updated values for the current time slot.\nNo new value changes are allowed to happen in the current time slot once the Postponed region is reached. Within this region, it is illegal to write values to any net or variable or to schedule an event in any previous region within the current time slot.\nThis region is also used to collect functional coverage for items that use strobe sampling.\nPostponed region PLI events are also scheduled in this region.\nThere is no feedback path from the Postponed region back into the RTL or Reactive-loop regions, so the values displayed and the coverage collected will be the final values for that time slot.\nBlocking and non-blocking statement# Blocking statement\nBlocking statements are assigned with =. It will execute serially in procedural blocks. Blocking statements are executed in a block in a sequential manner but when more than two procedural blocks, these statements will execute parallelly in the blocks and will not block the statements of other procedural blocks.\nSyntax -\nvariable_name(LHS) = expression(RHS); Non - blocking statement\nNon-blocking statements are assigned with the \u0026lt;=. It will not block the execution of a statement inside that particular block. These statements will execute the parallel inside that particular block.\nSyntax -\nVariable(LHS) \u0026lt;= Expression(RHS) ; "},{
      "id": "27",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/11.processes/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / Processes",
      "title": "Processes",
      "content":"Processes# A Processes or Thread is any piece of code that gets executed as a separate entity. A fork-join block creates the different threads that run in parallel.\nIn the below Fig-1 we can see that types of processes and the process controls.\nFig-1: The processes and process control blocks. Cheat sheet for processes:# S.no Processes Description 1. fork-join Parent threads will be executed only when all child threads are executed. 2. fork-join_any Parent threads will be executed only when anyone of the child thread gets executed. 3. fork-join_none Parent threads will be executed parallel with the child threads. 4. wait fork It makes the parent Threads to wait until all the child threads are executed. 5. disable fork It will terminate the execution of all the child threads when disable fork is execute. 6. Fine Grain Process Control These are used to control the processes and it will provide the status of the process/Thread. Processes or Threads# We have 3 types of Threads/Processes\nfork-join fork-join_any fork-join_none 1.fork-join# System Verilog provides support for parallel threads through fork-join construct. In fork-join process parent thread will execute only when all the child thread are finished their execution.\nsyntax:-\nfork Thread 1 Thread 2 Thread 3 join code snippet:-\n$display(\u0026#34;[%0t] Thread_T1: Values of a= %0d,b= %0d, c= %0d,d= %0d\u0026#34;,$time,a,b,c,d); fork:FORK_F1 begin:BEGIN_B2 #1 a \u0026lt;= b; b \u0026lt;= 7; $monitor(\u0026#34;[%0t] Thread-T2: Values of a= %0d,b= %0d, c= %0d,d= %0d\u0026#34;,$time,a,b,c,d); #1 -\u0026gt;e1; c = b; end:BEGIN_B2 begin:BEGIN_B3 wait(e1.triggered); $display(\u0026#34;[%0t] Event is triggered\u0026#34;,$time); begin:BEGIN_B4 #1 d = c; end:BEGIN_B4 end:BEGIN_B3 join:FORK_F1 $display(\u0026#34;[%0t] Thread_T3: value of a= %0d,b= %0d, c= %0d,d= %0d\u0026#34;,$time,a,b,c,d); Output:-\nIn the below Fig-2 we can see that Thread_T1 is executed first at #0 simulation time but Thread_T3 will be executed after all the child threads are executed and the child threads will execute according to the time delays.\nFig-2: The output of fork join block. In the below Fig-3 you can easily understand how the entire code for fork-join works with respect to schedule schematic regions.\nwhere sampling of the variables will be done in preponed region. All the blocking assignments will be executed and all non-blocking assignments was evaluated in active region. Events will be executed in Active region. $display statements will be executed in active region. All #0 delays statements will be executed in inactive region. The evaluated non-blocking assignments will be executed in NBA region. $monitor statements will be executed in postponed region. Fig-3: scheduler Schematic for fork-join code. Github lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/processes/fork_join/fork_join.sv Github log_file link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/processes/fork_join/fork_join.log 2.fork-join_any# The parent threads will be execute when any one of the child thread finished their execution. It means if you have 2 or more thread in your fork-join_any block and each thread need different time to finish. In this case, whichever thread finished first, fork-join_any will comes out of the block and will start executing the next parent thread/statement in simulation.\nIt does not mean that the rest of the child threads will be automatically discarded by simulation. Those threads will be running in the background.\nsyntax:-\nfork Thread 1 Thread 2 Thread 3 join_any code snippet:-\n$display(\u0026#34;[%0t] Thread_T1: Starting of fork_join_any\u0026#34;,$time); a = \u0026#34;Kapu\u0026#34;; c = \u0026#34;Malpe\u0026#34;; fork:FORK_F1 begin:BEGIN_B2 #0 $display(\u0026#34;[%0t] Thread_T2: Values of a =%0s,b =%0s,c =%0s,d =%0s\u0026#34;,$time,a,b,c,d); begin:BEGIN_B3 b \u0026lt;= a; #1 $display(\u0026#34;[%0t] Thread_T3: Values of a =%0s,b =%0s,c =%0s,d =%0s\u0026#34;,$time,a,b,c,d); end:BEGIN_B3 end:BEGIN_B2 fork:FORK_F2 begin:BEGIN_B4 #3 -\u0026gt; e1; $display(\u0026#34;[%0t] Thread_T4: Values of a =%0s,b =%0s,c =%0s,d =%0s\u0026#34;,$time,a,b,c,d); end:BEGIN_B4 join:FORK_F2 join_any:FORK_F1 #1 $display(\u0026#34;[%0t] Thread_T5: Values of a =%0s,b =%0s,c =%0s,d =%0s\u0026#34;,$time,a,b,c,d); begin:BEGIN_B5 wait(e1.triggered); d = \u0026#34;Kodi\u0026#34;; $monitor(\u0026#34;[%0t] Thread_T6: Values of a =%0s,b =%0s,c =%0s,d =%0s\u0026#34;,$time,a,b,c,d); end:BEGIN_B5 Output:-\nIn the below Fig-4 we can see that parent Thread_T1 is executed at #0 and the child Thread_T3 is executed at #1 then only the parent Thread_T5 will be executed at #2.\nFig-4: The output of fork-join_any block. Fig-5: scheduler Schematic for fork-join_any code. Github lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/processes/fork_join_any/fork_join_any.sv Github log_file link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/processes/fork_join_any/fork_join_any.log 3.fork-join_none# The parent threads are executed parallel with the child threads. This means the thread which is outside the fork-join_none, does not wait for the completion of any threads which is inside the fork-join_none, it just execute parallelly.\nIt does not mean that the rest of the child threads will be automatically discarded by simulation. Those threads will be running in the background.\nsyntax:-\nfork Thread 1 Thread 2 Thread 3 join_none code snippet:-\n$display(\u0026#34;[%0t] Thread_T1: Starting of fork_join_none\u0026#34;,$time); a = \u0026#34;Kapu\u0026#34;; c = \u0026#34;Malpe\u0026#34;; fork:FORK_F1 begin:BEGIN_B2 #1 $display(\u0026#34;[%0t] Thread_T2: Values of a =%0s,b =%0s,c =%0s,d =%0s\u0026#34;,$time,a,b,c,d); b \u0026lt;= a; #1 $display(\u0026#34;[%0t] Thread_T3: Values of a =%0s,b =%0s,c =%0s,d =%0s\u0026#34;,$time,a,b,c,d); end:BEGIN_B2 fork:FORK_F2 #1 -\u0026gt; e1; $display(\u0026#34;[%0t] Thread_T4: Values of a =%0s,b =%0s,c =%0s,d =%0s\u0026#34;,$time,a,b,c,d); join:FORK_F2 join_none:FORK_F1 #1 $display(\u0026#34;[%0t] Thread_T5: Values of a =%0s,b =%0s,c =%0s,d =%0s\u0026#34;,$time,a,b,c,d); wait(e1.triggered); d = \u0026#34;Kodi\u0026#34;; $monitor(\u0026#34;[%0t] Thread_T6: Values of a =%0s,b =%0s,c =%0s,d =%0s\u0026#34;,$time,a,b,c,d); Output:-\nIn the below Fig-6 At #0 the parent Thread_T1 and the child Thread_T4 is executed Then At #1 both parent Thread_T5 and child Thread_T2 will gets executed and so on.\nFig-6: The output of the fork-join_none block. Fig-7 : scheduler Schematic for fork-join_none code. Github lab link :https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/processes/fork_join_none/fork_join_none.sv\nGithub log_file link :https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/processes/fork_join_none/fork_join_none.log\nProcess control# System Verilog provides constructs that allow one process to terminate or wait for the completion of other processes.\nwait fork disable fork Fine grain process control 1.wait fork# The wait fork statement is used to ensure that all child processes (processes created by the calling process) have completed their execution. It will wait until all the fork processes complete the execution.\ncode snippet:-\n#1 $display(\u0026#34;[%0t] Thread_T1: values of a = %0s,b = %0s,c = %0s\u0026#34;,$time,a,b,c); fork:FORK_F1 #2 b \u0026lt;= \u0026#34;Delta\u0026#34;; #0 $display(\u0026#34;[%0t] Thread_T2: values of a = %0s,b = %0s,c = %0s\u0026#34;,$time,a,b,c); begin:BEGIN_B2 #1 -\u0026gt; e1; c = \u0026#34;Hoode\u0026#34;; #1 $display(\u0026#34;[%0t] Thread_T3: values of a = %0s,b = %0s,c = %0s\u0026#34;,$time,a,b,c); end:BEGIN_B2 fork:FORK_F2 wait(e1.triggered); #2 $display(\u0026#34;[%0t] Thread_T4: values of a = %0s,b = %0s,c = %0s\u0026#34;,$time,a,b,c); join:FORK_F2 #1 $display(\u0026#34;[%0t] Thread_T5: values of a = %0s,b = %0s,c = %0s\u0026#34;,$time,a,b,c); join_none:FORK_F1 wait fork; #0 $monitor(\u0026#34;[%0t] Thread_T6: values of a = %0s,b = %0s,c = %0s\u0026#34;,$time,a,b,c); Output:-\nIn the below Fig-8 we see that At #1 the parent Thread_T1 will get executed and there was a #0 statement which will be working in inactive region and the statements will be executed in the corresponding regions. Even though we are using fork-join_none the $monitor statement will be waiting till all the child Threads was executed.\nFig-8: The output of wait fork process control statement. Fig-9: scheduler Schematic for wait fork code. Github lab link :https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/processes/wait_fork/wait_fork.sv\ngithub log_file link :https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/processes/wait_fork/wait_fork.log\n2.disable fork# On execution of the disable fork, all the active process will get terminated.\ncode snippet:-\n#0 $display(\u0026#34;[%0t] Thread_T1: Values of a = %0s,b = %0s,c = %0s\u0026#34;,$time,a,b,c); fork:FORK_F1 #3 b \u0026lt;= \u0026#34;Delta\u0026#34;; #4 $display(\u0026#34;[%0t] Thread_T2: Values of a = %0s,b = %0s,c = %0s\u0026#34;,$time,a,b,c); begin:BEGIN_B2 #1 -\u0026gt; e1; c = \u0026#34;Hoode\u0026#34;; #1 $display(\u0026#34;[%0t] Thread_T3: Values of a = %0s,b = %0s,c = %0s\u0026#34;,$time,a,b,c); end:BEGIN_B2 fork:FORK_F2 @(e1.triggered); #1 $display(\u0026#34;[%0t] Thread_T4: Values of a = %0s,b = %0s,c = %0s\u0026#34;,$time,a,b,c); join:FORK_F2 #1 $display(\u0026#34;[%0t] Thread_T5: Values of a = %0s,b = %0s,c = %0s\u0026#34;,$time,a,b,c); join_any:FORK_F1 disable fork; #1 $display(\u0026#34;[%0t] Thread_T6: ending of fork-join\u0026#34;,$time); Output:-\nIn the below Fig-10 At #0 we are waiting for the event to get triggered and the #0 statement will be executed in active region because it was the $display statement.\nAt #1 it was triggering the event e1 and a child Thread_T5 will get executed then due to using fork-join_any it will go to the parent Thread and hits disable fork statement then all the remaining child Threads will be terminated.\nFig-10: The output of disable fork process control statement. Fig-11: scheduler Schematic for disable fork code. Github lab link :https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/processes/disable_fork/disable_fork.sv\nGithub log_file link :https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/processes/disable_fork/disable_fork.log\n"},{
      "id": "28",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/12.fine-grain-process-control/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / Fine Grain Process Control",
      "title": "Fine Grain Process Control",
      "content":"Fine Grain Process Control# Systemverilog has a built in class named Process that allows one process(i.e, like fork_join) to access and control the processes/threads. When we fork off any thread, a new object of process class is created at that time. This object contains status information about that thread.\nFig-1: These are all the pre-defined methods which are available in fine grain process control. Cheat sheet of different fine-grain process control:# S.no Tasks Description 1. self() Used to will create the ID/object of the process. 2. status() Used to will return the mode of the current Thread. 3. kill() Used to will kill the Thread. 4. await() Used to wait the current Thread for some other Thread to complete. 5. suspend() Used to suspend the Thread for some indefinite time. 6. resume() Used to resume the Thread from suspended state. 1.self()# It creates the object/ID for process class. The object is used to access all the pre-defined methods of the process class.\nThe object contains the Status information of all the Threads.\nSyntax:-\nprocess p_handle1,p_handle2; initial begin p_handle1 = process :: self(); p_handle2 = process :: self(); end code snippet:-\nfork:FORK_F1 $display(\u0026#34;[%0t] Entered into fork-join and started first check for the process\u0026#34;,$time); #1 -\u0026gt;e1; begin:BEGIN_B2 wait(e1.triggered); if(p1 == null) $display(\u0026#34;[%0t] Not created\u0026#34;,$time); else $display(\u0026#34;[%0t] Created\u0026#34;,$time); -\u0026gt;e3; #1 -\u0026gt;e2; end:BEGIN_B2 #2 p1 = process :: self(); begin:BEGIN_B3 wait(e2.triggered); $display(\u0026#34;[%0t] Started second check for the process\u0026#34;,$time); if(p1 == null) $display(\u0026#34;[%0t] Not created\u0026#34;,$time); else $display(\u0026#34;[%0t] Created\u0026#34;,$time); -\u0026gt;e4; end:BEGIN_B3 fork:FORK_F2 begin:BEGIN_B4 wait(e3.triggered); $display(\u0026#34;[%0t] first check for the process done\u0026#34;,$time); end:BEGIN_B4 begin:BEGIN_B5 wait(e4.triggered); $display(\u0026#34;[%0t] Second check for the process done\u0026#34;,$time); end:BEGIN_B5 join:FORK_F2 join:FORK_F1 In the above code snippet you can see that At #0 simulation time the handle for the process class was declared.\nIn the below Fig-2,\nAt #1 simulation time we are checking whether an object p1 was created or not then it was displaying Not created. At #2 simulation time we are creating an object for the process p1. At #3 simulation time we are checking for the object p1 it was displaying Created. Fig-2: The output of the self() method. Fig-3: scheduler Schematic for self() method. Github lab link-https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/fine_grain_process_control/fine_self/fine_self.sv\nGithub log_file link-https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/fine_grain_process_control/fine_self/fine_self.log\n2.Status()# It will shows the status/mode of the process ID. There are different modes like Finished, Running, Waiting, Suspended, Killed.\nSyntax:-\nprocess p_handle; initial begin begin p_handle = process :: self(); $display(\u0026#34;status : %s\u0026#34;,p_handle.status()); end end code snippet:-\n$display(\u0026#34;[%0t] Seeking status:\u0026#34;,$time); fork:FORK_F1 begin:BEGIN_B2 p1 = process :: self(); #1 $display(\u0026#34;[%0t] I am in process p1\u0026#34;,$time); $display(\u0026#34;[%0t] Initial status of p1: %s\u0026#34;,$time,p1.status()); #1 $display(\u0026#34;[%0t] Still working in p1\u0026#34;,$time); -\u0026gt;e1; -\u0026gt;e2; end:BEGIN_B2 begin:BEGIN_B3 p2 = process :: self(); wait(e2.triggered); #1 $display(\u0026#34;[%0t] I am in process p2\u0026#34;,$time); $display(\u0026#34;[%0t] Initial status of p2: %s\u0026#34;,$time,p2.status()); $display(\u0026#34;[%0t] Still working in p2\u0026#34;,$time); -\u0026gt;e3; end:BEGIN_B3 begin:BEGIN_B4 wait(e1.triggered); $display(\u0026#34;[%0t] Final status of p1: %s\u0026#34;,$time,p1.status()); end:BEGIN_B4 begin:BEGIN_B5 wait(e3.triggered); $display(\u0026#34;[%0t] Final status of p2: %s\u0026#34;,$time,p2.status()); end:BEGIN_B5 fork:FORK_F2 p3 = process :: self(); #1 $display(\u0026#34;[%0t] I am in process p3\u0026#34;,$time); #1 $display(\u0026#34;[%0t] status of p3: %s\u0026#34;,$time,p3.status()); #1 -\u0026gt;e4; join:FORK_F2 join_any:FORK_F1 wait(e4.triggered); #1 $display(\u0026#34;[%0t] Final status of p3: %s\u0026#34;,$time,p3.status()); In the below Fig-4,\nyou can see that there are some strings which are in upper-case those are the status of a process p1 and p2. At different simulation times the status of the processes/Threads will be changing depending on their execution. Fig-4: The output of the status() method. Fig-5: scheduler Schematic for status() method. Github lab link-https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/fine_grain_process_control/fine_status/fine_status.sv\nGithub log_file link-https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/fine_grain_process_control/fine_status/fine_status.log\n3.kill()# The kill () function terminates the process and all its sub-processes. If the process is not blocked (due to wait statement, delay or waiting for an event to trigger), then it will be terminated in the current timestamp.\nSyntax:-\nProcess p_handle1; initial begin fork p_handle1 = process :: self(); p_handle1.kill(); join_any end code snippet:-\n$display(\u0026#34;[%0t] Seeking status:\u0026#34;,$time); fork:FORK_F1 begin:BEGIN_B2 p1 = process :: self(); #1 $display(\u0026#34;[%0t] I am in process p1\u0026#34;,$time); $display(\u0026#34;[%0t] Initial status check of p1: %s\u0026#34;,$time,p1.status); -\u0026gt;e1; if(p1.status() != process :: FINISHED) p1.kill(); $display(\u0026#34;hi i am working\u0026#34;); $display(\u0026#34;what about you?\u0026#34;); end:BEGIN_B2 begin:BEGIN_B3 wait(e1.triggered); #1 $display(\u0026#34;[%0t] Status of p1 before killing: %s\u0026#34;,$time,p1.status()); end:BEGIN_B3 join:FORK_F1 In the above code snippet you can see that process p1 At #0 simulation time process class object was created.\nIn the below Fig-6,\nAt #1 simulation time the status of p1 was RUNNING. At #2 simulation time after using kill() method the status of p1 was KILLED. Fig-6: The output of the kill() method. Fig-7: scheduler Schematic for kill() method. Github lab link-https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/fine_grain_process_control/fine_kill/fine_kill.sv\nGithub log_file link- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/fine_grain_process_control/fine_kill/fine_kill.log 4.await()# This method is used to allows one process to wait for another process/Thread to complete.\nSyntax:-\nProcess p_handle1,p_handle2; initial begin fork begin p_handle1 = process :: self(); p_handle2.await(); end begin p_handle2 = process :: self(); end join end code snippet:-\n$display(\u0026#34;[%0t] Seeking status:\u0026#34;,$time); fork:FORK_F1 begin:BEGIN_B2 p1 = process :: self(); #1 $display(\u0026#34;[%0t] I am in process p1\u0026#34;,$time); $display(\u0026#34;[%0t] Initial status of p1: %s\u0026#34;,$time,p1.status()); $display(\u0026#34;[%0t] Status of p1 before await: %s\u0026#34;,$time,p1.status()); if(p1.status() != process :: FINISHED) p2.await(); end:BEGIN_B2 #2 $display(\u0026#34;[%0t] Status of p1 after await: %s\u0026#34;,$time,p1.status()); begin:BEGIN_B4 p2 = process :: self(); #1 $display(\u0026#34;[%0t] I am in process p2\u0026#34;,$time); $display(\u0026#34;[%0t] Initial status of p2: %s\u0026#34;,$time,p2.status()); #2 -\u0026gt;e2; end:BEGIN_B4 begin:BEGIN_B5 wait(e2.triggered); $display(\u0026#34;[%0t] Final status of p2: %s\u0026#34;,$time,p2.status()); -\u0026gt;e1; end:BEGIN_B5 begin:BEGIN_B6 wait(e1.triggered); $display(\u0026#34;[%0t] Final status of p1: %s\u0026#34;,$time,p1.status()); end:BEGIN_B6 join_any:FORK_F1 In the above code snippet we are trying to make process p1 to wait until the process p2 was finished.\nIn below Fig-8, you can see\nAt #1 simulation time before using await() method the status of p1 was RUNNING. At #2 simulation time after using await() method the status of p1 was WAITING. At #3 simulation time once the status of p2 was FINISHED then the status of p1 also FINISHED. Fig-8: The output of the await() method. Fig-9: scheduler Schematic for await () method. Github lab link-https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/fine_grain_process_control/fine_await/fine_await.sv\nGithub log_file link-https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/fine_grain_process_control/fine_await/fine_await.log\n5.suspend()# This method is used to suspend the execution of the process/Thread. It can suspend its own or other process’s execution. The execution is suspended until a resume() method is encountered.\nIf the process is not blocked (due to wait statement, delay or waiting for an event to trigger), then it will be suspended in the current timestamp.\nSyntax:-\nProcess p_handle1; initial begin fork begin p_handle1 = process :: self(); p_handle1.suspend(); end join_none end code snippet:-\n$display(\u0026#34;[%0t] Seeking status:\u0026#34;,$time); fork:FORK_F1 begin:BEGIN_B2 p1 = process :: self(); #1 $display(\u0026#34;[%0t] I am in process p1\u0026#34;,$time); $display(\u0026#34;[%0t] Initial status of p1: %s\u0026#34;,$time,p1.status()); -\u0026gt;e1; if(p1.status() != process :: FINISHED) begin:BEGIN_B3 #1 $display(\u0026#34;[%0t] Status of p1 before suspending: %s\u0026#34;,$time,p1.status()); p1.suspend(); $display(\u0026#34;[%0t] Status of p2 in p1 block: %s\u0026#34;,$time,p2.status()); end:BEGIN_B3 end:BEGIN_B2 begin:BEGIN_B4 wait(e1.triggered); p2 = process :: self(); #1 $display(\u0026#34;[%0t] I am in process p2\u0026#34;,$time); $display(\u0026#34;[%0t] Initial status of p2: %s\u0026#34;,$time,p2.status()); #1 $display(\u0026#34;[%0t] status of p1 after suspended: %s\u0026#34;,$time,p1.status()); -\u0026gt;e2; end:BEGIN_B4 begin:BEGIN_B5 wait(e2.triggered); $display(\u0026#34;[%0t] Final status of p2: %s\u0026#34;,$time,p2.status()); end:BEGIN_B5 join:FORK_F1 In the above code snippet we are trying to make process p1 to suspend permanently.\nIn the below Fig-10, you can see\nAt #1 simulation time before suspending the status of p1 was RUNNING. At #3 simulation time after suspending the status of p1 was SUSPENDED. Fig-10: The output of the suspend() method. Fig-11: scheduler Schematic for suspend () method. Github lab link-https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/fine_grain_process_control/fine_suspend/fine_suspend.sv\nGithub log_file link- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/fine_grain_process_control/fine_suspend/fine_suspend.log 6.resume()# This method is used to restart the process that was suspended. Resuming a process that was suspended while being blocked (due to wait statement, delay or waiting for an event to trigger) shall reinitialize that process to the event expression or wait for the wait condition to be true or for the delay to expire.\nSyntax:-\nProcess p_handle1,p_handle2; initial begin fork begin p_handle1 = process :: self(); p_handle1.suspend(); end begin p_handle2 = process :: self(); p_handle1.resume(); end join_none end code snippet:-\n$display(\u0026#34;[%0t] Seeking status:\u0026#34;,$time); fork:FORK_F1 begin:BEGIN_B2 p1 = process :: self(); #1 $display(\u0026#34;[%0t] I am in process p1\u0026#34;,$time); $display(\u0026#34;[%0t] Initial status of p1: %s\u0026#34;,$time,p1.status()); -\u0026gt;e1; if(p1.status() != process :: FINISHED) begin:BEGIN_B3 #1 $display(\u0026#34;[%0t] Status of p1 before suspending: %s\u0026#34;,$time,p1.status()); p1.suspend(); $display(\u0026#34;[%0t] Status of p2 in p1 block: %s\u0026#34;,$time,p2.status()); end:BEGIN_B3 end:BEGIN_B2 begin:BEGIN_B4 wait(e2.triggered); $display(\u0026#34;[%0t] Status of p1 before resuming: %s\u0026#34;,$time,p1.status()); p1.resume(); #1 $display(\u0026#34;[%0t] Status of p1 after resuming: %s\u0026#34;,$time,p1.status()); -\u0026gt;e3; end:BEGIN_B4 begin:BEGIN_B6 p2 = process :: self(); #1 $display(\u0026#34;[%0t] I am in process p2\u0026#34;,$time); $display(\u0026#34;[%0t] Initial status of p2: %s\u0026#34;,$time,p2.status()); if(p1.status() == process :: SUSPENDED) #1 -\u0026gt;e2; end:BEGIN_B6 begin:BEGIN_B7 wait(e3.triggered); #1 $display(\u0026#34;[%0t] Final status of p1: %s\u0026#34;,$time,p1.status()); $display(\u0026#34;[%0t] Final status of p2: %s\u0026#34;,$time,p2.status()); end:BEGIN_B7 join:FORK_F1 Here in the above code snippet we are trying to resume the process p1 in the process p2.\nIn the below Fig-12, you can see\nAt #1 simulation time the status of p1 was RUNNING. At #2 simulation time before using resume() method the status of p1 was SUSPENDED. At #3 simulation time after using resume() method the status of p1 was FINISHED. Fig-12: The output of the resume() method. Fig-13: scheduler Schematic for resume() method. Github lab link-https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/fine_grain_process_control/fine_resume/fine_resume.sv\nGithub log_file link-https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/fine_grain_process_control/fine_resume/fine_resume.log\n"},{
      "id": "29",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/13.interface/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / Interface",
      "title": "Interface",
      "content":"In Verilog, the communication between blocks is specified using module ports.\nDisadvantage of verilog module connections\nDeclaration must be duplicated in multiple modules. Risk of mismatched declaration. A change in design specifications can require modifications in multiple modules. Interface# SystemVerilog adds the interface construct which encapsulates the communication between blocks. An interface is a bundle of signals or nets through which a testbench communicates with a design.\nsl. no. data type 1. Interface 2. Parameterized interface 3. Modports 4. Clocking blocks 5. Virtual interface Tabular column.1. Interface Figure.1.Interface types The interface construct is used to connect the design and testbench.\nSystemverilog without Interface\nBelow diagram shows connecting design and testbench without interface.\nFigure.2.top module without interface SystemVerilog Interface\nBelow diagram shows connecting design and testbench with the interface.\nFigure.3.top module with interface Syntax:\ninterface (interface_name) ([port_list]); [list_of_signals] endinterface Example: Interface declaration\ninterface and_if; logic input_a,input_b,output_y; endinterface Figure.4.and gate interface Here the interface consist of group of signals, In test module we call the interface handle but we not declare the direction of signals. In test module we pass the value of a_input and b_input to the interface. In top module we instantiate the DUT signals with interface. Output of DUT \u0026lsquo;y\u0026rsquo; is sent to the test module through interface. The modport is not used in the interface.we can declare the size of the each signal by decalaring \u0026lsquo;/\u0026rsquo; on the signals. It is used to now the vector size of the signal.\nTOP module for AND gate\n//Here the interface,testbench,design module are called. module top(); //interface module and_if inf(); //design module instantiate andg a1(.input_a(inf.input_a), .input_b(inf.input_b), .output_y(inf.output_y)); //testbench tb a2(inf); endmodule:top Design code for AND gate\n//module declaration module andg(input_a,input_b,output_y); input input_a,input_b; output output_y; //assign output assign output_y=input_a\u0026amp;input_b; endmodule:andg Testbench for AND gate\n//testbench for and gate module tb(and_if inf); initial begin $display(\u0026#34;\\n// and gate output\u0026#34;); $monitor(\u0026#34;\\ninput_a=%b\\t input_b=%b\\t output_y=%b\u0026#34;,inf.input_a,inf.input_b,inf.output_y); inf.input_a = 0; inf.input_b = 0; #1; inf.input_a = 1; inf.input_b = 0; #1; inf.input_a = 0; inf.input_b = 1; #1; inf.input_a = 1; inf.input_b = 1; end endmodule:tb Below figure shows the output of and gate using interface.\nFigure.5.output for AND gate with interface Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/interface/interface_error/interface_example Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/interface/interface_example/interface.log Advantages of SystemVerilog interfaces\nIn Verilog for the addition of new signals, it has to be manually changed everywhere that module has been instantiated. System Verilog made it easier to add new signals in the interface block for existing connections. It has increased re-usability across the projects. A set of signals can be easily shared across the components bypassing its handle. It provides directional information (modports) and timing information (clocking blocks). Parameterized interface# Parameters can be used in interfaces to make vector sizes and other declarations within the interface reconfigurable using Verilog’s parameter redefinition constructs.\nSyntax\ninterface (interface_name) #(parameter parameter_name = initialize); [list_of_signals] endinterface Example\ninterface count_if #(parameter N=2) ; logic reset,clk; logic [N:0] counter; endinterface:count_if TOP module for COUNTER\n//Here the interface,testbench,design module are called. module top(); //parameterised interface count_if inf(); //design code of up_counter up_counter u1(.clk(inf.clk), .reset(inf.reset), .counter(inf.counter)); //testbench for up_counter upcounter_testbench u2(inf); endmodule:top Design code for counter\n//Design code for up counter module up_counter(clk,reset,counter); input clk, reset; output [2:0] counter; reg [2:0] counter_up; //up counter always @(posedge clk or posedge reset) begin //if reset=0 count will be incremented if(reset) counter_up \u0026lt;= 3\u0026#39;d0; else counter_up \u0026lt;= counter_up + 3\u0026#39;d1; end assign counter = counter_up; endmodule:up_counter Test bench for counter\n//testbench for up counter module upcounter_testbench(count_if inf); initial begin $display(\u0026#34;\\n // Parameterised interface example\u0026#34;); //used to monitor the count values $monitor(\u0026#34;\\ncount=%0d\u0026#34;,inf.counter); inf.clk=0; forever #5 inf.clk=~inf.clk; end initial begin inf.reset=1; #20; inf.reset=0; #70 $finish; end endmodule:upcounter_testbench Here we\u0026rsquo;re considering 3 bit output, where the counter counts from 0 to 7.\nBelow figure shows the output of counter with parameterized interface.\nFigure.6.Output for counter with parameterized interface Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/interface/parameter_interface Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/interface/parameter_interface/code.log The parameter value can be updated in two ways\nPass constant value Use the ‘defparam’ keyword Pass constant value\nHere the value of the parameter is passed to the interface by the top module instantiation of interface.\nExample: count_if#(2) intf();\ncount_if is interface_name.\n#(2)- is the parameter value passing to interface module.\nExample:\ninterface module\ninterface count_if #(parameter N); logic rst,clk; logic [N:0] counter; logic [N:0] counter_up; endinterface:count_if top module\nmodule top(); //parameterised interface //pass by constant value count_if#(2) intf(); //design code of up_counter up_counter u1(intf); //testbench for up_counter upcounter_testbench u2(intf); endmodule:top OUTPUT:\nThe below Figure.7,The output of up_counter it count from 0 to 7. here the value of the parameter is passed to the interface in the top module instantiation.\nFig.7: output of counter with pass by constant parameterized interface Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/interface/Types_of_parameter_passing/pass_constant_parameter Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/interface/Types_of_parameter_passing/pass_constant_parameter/code.log Use the ‘defparam’ keyword\ndefparam is used for overridding the parameter value by using the hierarchical name instance.defparam allow the changing of parameter value during compilation time\nExample:defparam intf.N=1;\nHere intf is the handle of interface.\nN is the parameter.\ninterface module\ninterface count_if #(parameter N=4); // declaration of design signals logic rst,clk; logic [N:0] counter; logic [N:0] counter_up; endinterface:count_if top module\nmodule top(); //parameterised interface count_if intf(); //Declaration of defparam defparam intf.N=1; //instantiation of design module up_counter u1(intf); //testbench for up_counter upcounter_testbench u2(intf); endmodule:top OUTPUT:\nThe Figure.8 below shows,The interface parameter value N=4. but at the top module instantiation by using the keyword defparam we can override the value of parameter.\nFig.8: output of counter with defparam parameterized interface Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/interface/Types_of_parameter_passing/Defpram_parameter Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/interface/Types_of_parameter_passing/Defpram_parameter/code.log Modport:# Modport is used to specifies the port directions to the signals declared within the interface. modports are declared inside the interface with the keyword modport. modport is abbreviated as module port. Characteristics of modports:\nIt can have, input, inout and output. By specifying the port directions, modport provides access restrictions for signals. The Interface can have any number of modports, the signal declared in the interface can be grouped in many modports. modports are sythesizable. Syntax:\nmodport identifier (input \u0026lt;port_list\u0026gt;, output\u0026lt;port_list\u0026gt;); Example:\ninterface and_intr; logic p,q; logic r; modport DUT_MP(input p,input q,output r); modport TB_MP(output p,output q,input r); endinterface : and_intr Top module for AND gate while calling modport name in testbench and design file:\n// creating top module // in this file design,testbench,interface modules are called module top(); // interfce module called and_intr inf(); // design module called and_gate a1(inf); // testbench module called tb a2(inf); endmodule : top design file for AND gate:\n// and gate design file // module defination for and gate with interface instanciation module and_gate(and_intr inf); // assign the output using continuous assignment assign inf.DUT_MP.r = (inf.DUT_MP.p) \u0026amp; (inf.DUT_MP.q); endmodule : and_gate testbench file for AND gate:\n// testbench file for and gate design // module defination for testbench with interface instanciation module tb(and_intr inf); initial begin $display(\u0026#34;// and gate output using modports\\n\u0026#34;); repeat(5) begin inf.TB_MP.p = $random; #1; inf.TB_MP.q = $random; #1; $display(\u0026#34;input_p=%b\\t input_q=%b\\t output_r=%b\u0026#34;,inf.TB_MP.p,inf.TB_MP.q,inf.TB_MP.r); end end endmodule : tb Output of AND gate using modports in interface remains same for both of the above mentioned ways. it showing in below figure.\nFigure.9 AND gate Output Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/interface/modports Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/interface/modports/modport.log Clocking Block# The clocking block is defined that the mechanism to synchronize sampling and driving of input and output signal with respect to clock event. It is quite useful to use clocking blocks inside a testbench to avoid race condition in simulation. We can make timing explicitly when signals are synchronous to a particular clock. Clocking block can only declared inside a module ,interface. Clocking block only deals with how the inputs and outputs are sampled and synchronized. Assigning a value to a variable is done by module, interface not the clocking block.\nClocking block terminologies# 1. Clocking event\nclocking clockingblock_name @(posedge clk); The event specification used to synchronize the clocking block, @(posedge clk) is the clocking event.\n2. Clocking signal\ninput from_Dut; output to_Dut; Signals sampled and driven by the clocking block, from_DUT and to_DUT are the clocking signals,\n3. Clocking skew\nClocking skew specifies with respect to at which input and output clocking signals are to be sampled or driven respectively. A skew must be a constant expression and can be specified as a parameter.\nInput and Output skews\ndefault input #1step output #0; The default input skew and output skew is declared like this, default input #1step output #0; .Here default input skew takes #1step delay for sampling process to get the stable input. The output skew takes only #0 delay means that we get the stable output at the current time slot itself.\nThe below figure shows that default input and output skew\nFig.10: default input #1step output #0 The below figure shows the Input skew and output skew\nFig.11: Input skew and output skew Input signals are sampling with respect to the clock event. If an input skew is specified then the signal is sampled at skew time units before the clock event. Then the output signals are driving skew simulation time units after the corresponding clock event. Input skew is implicitly negative because it happens before the clock.\nEg. default input #3ps output #2\nSyntax:\nclocking cb @(posedge clk); default input #1step output #0; input from_Dut; output to_Dut; endclocking Example:D_flipflop\nFig.12: Block diagram of d_ff design The above figure.13 shows the design block diagram for d_ff. The Interface connect the DUT and test. The test provide the randomized value d. it is driven to DUT through interface. The DUT gives the sampled value q. The sampled value q is given as input to the test. Here the top module consist of all blocks such as test, interface and DUT. The instance of each block is created in top module.\nFig.13: Block diagram for triggering the DUT and Test at posedge clock In this example both DUT (clocking block clock) and Test is triggered at positive edge (interface clock).\nHere in this scenario, the wave form output and display statement output is mismatching.\nthe output is shown in the below Figure.12\nExample code:\nDUT code:\n// module:d_flipflop module d_flipflop(dff.dut intf); //clocking block cd always @(intf.cd) //Non-Blocking assignment intf.cd.q \u0026lt;= intf.cd.d; endmodule : d_flipflop Interface code:\n//module: Interface interface dff(input clk); //declare the signals logic d; logic q; //Clocking block for dut clocking cd @(posedge clk); default input #1step output #0; output q; input d; endclocking //modport for dut modport dut(clocking cd); //modport for tb modport tb(input q, output d, input clk);` endinterface: dff Test code:\n//module: test module test(dff.tb intf); //task:drv task drv; //loop repeat(10) begin //test triggering at posedge @(posedge intf.clk ) //randomzing the d intf.d \u0026lt;= $random; $display(\u0026#34;test side[%0t]=d_tb_drive:%d q_dut_sample:%d\u0026#34;,$time,intf.d, intf.q); end $finish; endtask //calling the task drv initial begin drv(); end endmodule :test Top module\n//including the file test.sv and interface.sv `include \u0026#34;test.sv\u0026#34; `include \u0026#34;interface.sv\u0026#34; module top; bit clk=1; initial forever #5 clk = ~clk; //creating interface instance dff intf(clk); //d_flipflop instance d_flipflop t1(intf); //test Instance test t2(intf); initial $monitor(\u0026#34;DUT side [%0t]=d_tb_drive:%d q_dut_sample:%d\u0026#34;,$time,intf.cd.d, intf.cd.q); endmodule : top Figure:14,In below output, first give posedge for both DUT and test. In this example at 0 time both DUT and test output is x, after at 10ns test randomize d value x to 0, that time Dut get 0 and give sample q output to 0, this clock cycle test(tb) only randomize value d = 0 but test(tb) take sampled previous value q = x.\nAt 10ns my DUT give output d = 0 and q = 0, and at that time my test(tb) give output d = 0 and q = x. Now, at 20ns test randomize d value 0 to 1, At that time DUT get 1 and give sampled q output to 1, this clock cycle test(tb) only randomize value d = 1 but test(tb) takes sampled previous value q = 0. at 20ns my DUT give output d = 1 and q = 1, and at that time my test give output d = 1 and q = 0.\nTranscript output\nThe below Figure.14 shows the output of dflipflop.\nFig.14: Transcript output of above example. output of d_ff for all clock cycles\nThe below figure.15 shows the output waveform of d_flipflop.\nFig.15: output waveform of case1. Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/interface/Clocking_Block/clocking_block_example Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/interface/Clocking_Block/clocking_block_example/top.log Advantages of Clocking Block\nClocking block provides race free condition between testbench and DUT. Clocking block can be declared inside interface, module. Clocking block helps the user to write testbenches with higher level of abstraction. Simulation is more faster. Separating clocking activities of design from its data assignments activities. Save amount of code and time in design execution. Virtual Interface# The virtual interface is a variable that represent the interface instance.\nThe virtual interface is used to create a interface instance in the class because the interface is a static component and the system verilog test bench is a dynamic component. we cannot directly declare the interface in the class by using the variable virtual we can declare the interface instance in the class\nsynatax: virtual interface_name instance_name;\ninterface_name: name of the interface\ninstance_name: name of the virtual interface instance can be used in the class with variables Ex: vif.variable;\nThe virtual interface must be initialized in the class pointing to actual interface. Declaration of virtual interface in the class Example: Virtual intf vif;\nAccessing of uninitialized virtual interface result in fatal error.\nThe virtual interface can be passed as argument to the task and function methods.\nThe virtual interface can be a property of class and which is initialized by using the function argument i.e it can call the actual interface in the particular class and create the instance of interface in that class\nExample: function new(virtual intf vif);\nThe virtual interface can be passed as argument to the function method Calling the actual interface \u0026lsquo;intf\u0026rsquo; to declare the virtual interface in the class using the procedure or in function argument by using new() construct.\nThe interface variables can be accessed by virtual interface handles inside the class function and task methods as virtual_instance_name.variable;\nExample : vif.a\nvif is a virtual_instance_name;\na is the variable/property of class\nThe keyword/signal virtual interface variable represent the different interface instance in different time through out the simulation time\nsyntax:\ninterface \u0026lt;interface_name\u0026gt;(); \u0026lt;port_list\u0026gt;; .......... endmodule To connect static(interface module) to to dynamic(class) we use virtual interface class clase_name; virtual \u0026lt;interface_name\u0026gt; \u0026lt;interface_instance\u0026gt;; ....... properties; ..... function() ..... endfunction task(); ...... endtask endclass Example1: Fulladder\nDesign code of Full adder\n//Module:fullinput_adder module fulladder(in_a,in_b,in_c,out_sum,out_carry) ; //Declaration of input variables input in_a,in_b,in_c; //Declaration of output variables output out_sum; output out_carry; //continuous input_assignment statement assign out_sum = in_a^in_b^in_c; assign out_carry = (in_a\u0026amp;in_b)|(in_b\u0026amp;in_c)| (in_c\u0026amp;in_a); endmodule:fulladder Interface module of full adder\ninterface adder(); //declaring the signals logic in_a,in_b,in_c; logic out_sum,out_carry; endinterface Virtual Interface declaration inside the class\n//class:driver class driver; //Declaration of virtual interface //syntax: virtual interface_name interface_instance; virtual adder vif; //constructor function new(virtual adder vif); //this.vif refer to class driver //vif refer to the function argument this.vif = vif; endfunction //task task run(); repeat(10) begin //interface_instance.variable vif.in_a = $random; vif.in_b = $random; vif.in_c = $random; $display(\u0026#34;\u0026#34;); $display(\u0026#34;//INPUT:Inputs of full adder \\n a=%0b, b=%0b, cin =%0b\u0026#34;, vif.in_a,vif.in_b, vif.in_c); #5; $display(\u0026#34;\u0026#34;); $display(\u0026#34;//OUTPUT:Outputs of full adder \\n sum=%0b, carry = %0b\\n\u0026#34;, vif.out_sum, vif.out_carry); end endtask endclass Test module of full adder\n`//include the driver file include \u0026#34;driver.sv\u0026#34; //module:test module test(adder intf); //declaring the driver instance driver drv; initial begin //creating the driver instance drv = new(intf); //calling the task run drv.run(); end endmodule:test Top module of full adder\n//including the test.sv and interface.sv files `include \u0026#34;test.sv\u0026#34; `include \u0026#34;interface.sv\u0026#34; //module:top module top; //creating an instance of interface adder intf(); // the instance of test t1. test t1(intf); //fulladder DUT instance , connecting the interface signal to instance DUT fulladder dut(.in_a(intf.in_a), .in_b(intf.in_b), .in_c(intf.in_c), .out_sum(intf.out_sum), .out_carry(intf.out_carry)); endmodule Below figure shows the design block of the code:\nFig.16: Design Block diagram Here in the Figure:16, the driver is a class here we declare the virtual interface because inside the class we cannot call the interface directly because interface is static component and class is dynamic component. so this virtual keyword is used to create the instance in the class (it will create the virtual interface) inside the class. In driver we generates the random stimulus and send to the interface, the DUT is connected to interface. The DUT output is given to the interface. The test block consist of class component i.e (driver.sv) and the top module consist of all the component such as test, interface and DUT. The instance of all component is created in the Top module/block.\nBelow figure shows the output of full adder:\nHere in the Figure.17 shows the output of full adder where a, b \u0026amp; cin are the input of the full adder, sum and carry are the output of the fulladder\nFig.17: Output of Full adder Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/interface/Virtual_interface Github output code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/interface/Virtual_interface/top.log "},{
      "id": "30",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/14.constraint/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / Constraint",
      "title": "Constraint",
      "content":"Constraint# The constraint is the way to assign legal value to the random variables. Constraints help us to limit the randomness of the variable by specifying the range. The way to create valid test configurations is by the use of constraints.\nTo enable the randomization we use rand() and randc() function. For using the constraint first, we need to assign the random variables by using the keyword rand or randc. After that declare the constraint statement.\nAll the constraint blocks are active at the same time.\nSyntax constraint constraint_name{random_variable[range];} Note- If the variable is randomised without any constraints, then any value in the range will be assigned to the variable with equal probability.\nCheat Sheet\nS.No. Constraints 1. Random Function System 2. Random Variables 3. std::randomize 4. Constraint Block 5. Array Randomization 6. Inside Constraint 7. Inverted Inside Constraint 8. Weighted Distribution 9. Bidirectional Constraint 10. Implication Constraint 11. if-else constraint 12. foreach 13. Solve before constraint 14. Static Constraint 15. Randomization methods 16. Inline Constraint 17. Soft Constraint 18. Disable Constraint 19. Disable Randomization 20. randcase 21. constraint memory examples Randomization is done in two ways.\nRandom function system Random Variables 1.Random Function system# This system function is used to give the pseudorandom numbers. These functions are used inside the \u0026ldquo;initial begin\u0026rdquo; block. There are generally two system functions used and these are -\n$urandom() $random() $urandom_range() Return 32-bit unsigned random number but the number remains the same throughout the simulation unless we change the seed number. For the particular seed number again the random number is fixed and does not change throughout the simulation. Syntax- $urandom() Returns 32-bit signed random number and same as $urandom() not change the value throughout the simulation unless the seed number changed. Syntax- $random() Returns the unsigned value for the given specified range and does not change the value throughout the simulation time. Syntax - $urandom(max,min); Example -\nThe below example shows the random function code. a = $random(); b = $urandom(); c= $urandom_range(4,2); //GIVING RANGE (MAX,MIN) d = $random(23); // assign some seed value e = $urandom(4); // assign seed value $display (\u0026#34;a=$random() // Return 32 bit signed random variable\u0026#34;); $display(\u0026#34;Random Value of a = %0d\u0026#34;,a); $display(\u0026#34;b = $urandom() // Return 32 bit unsigned random value .\u0026#34;); $display(\u0026#34;Random Value of b = %0d\u0026#34;,b); $display (\u0026#34;c = $random_range(4,2) // Return the unsigned random number\u0026#34;) ; $display(\u0026#34; by giving the range to the variable\u0026#34;); $display(\u0026#34;Random value of c = %0d\u0026#34;,c); $display(\u0026#34; $random(seed); // assign some seed value, it will display 32 bit \u0026#34;); $display (\u0026#34; signed random value for the given seed value \u0026#34;); $display (\u0026#34;d = $random(23); // Seed value =23\u0026#34;); $display (\u0026#34;Random value of d = %0d\u0026#34;,d ); $display (\u0026#34;$urandom(seed); // assign the seed value , it will display 32 bit \u0026#34;); $display (\u0026#34; unsigned random value for the given seed value \u0026#34;); $display (\u0026#34;e = $urandom(4); // Seed value = 4;\u0026#34;); $display (\u0026#34;Random value of e = %0d\u0026#34;, e); end Output Snap\nThe below output, fig -1 shows the $random(),$urandom() value and shows the effect of the seed value. fig -1 Output - random function GitHub lab file link-https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/random_function/random_function.sv\nGitHub log file link -https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/random_function/random_function_log.log\nNote:\nseed is the value given while randomization saying that for particular seed the values of rand variables should not change and is given using -sv_seed\u0026lt;value\u0026gt; at CMD line. No matter how many times you compile and run the file ,same random values are given again and again. If you want different values at different times the change seed. 2.Random Variables# Generally, a random variable is a variable whose value is unknown or a function that assigns values to each of an experiment\u0026rsquo;s outcomes. The class variables which get random values on randomization are called random variables. The value of the random variable is uniformly distributed for the range.\nPurpose of random variables When we do direct tests, we need some time to think about the possible conditions or scenarios for the test and there is a possibility that we missed some test cases. To solve this random variable concept is introduced.\nIn a random variable, random values in that particular assigned range will be generated.\nThe drawback of random functions is, that they cannot change the value throughout the simulation times .\nTo use, random variables, class variables need to be declared using the rand and randc type-modifier keywords.\nrand# rand is non-cyclic in nature. It will randomly give any value and can repeat the value before completing the cycle.\nSyntax rand data_type variable_name; Example The below example is of rand variable.\nclass rand_function; rand logic [2:0] a ; endclass rand_function raf; module rand_var; initial begin // rand_function ra_f; raf = new(); $display (\u0026#34;rand - Randomizing the value of the variable in the non-cycling form \u0026#34;); for (int i =0;i \u0026lt;= 10;i++)begin void\u0026#39;(raf.randomize ()); $display(\u0026#34;Iteration = %0d Random value of a = %0d\u0026#34;,i, raf.a); end end In the above code, the class is declared as rand_function inside it the variable declared is \u0026lsquo;a \u0026lsquo;. random variable rand is used to randomize the value of the variable \u0026lsquo;a\u0026rsquo;. Inside the module to randomize the class, randomize() function is used. for loop is used to get the randomised value of the variable 11 times.\nOutput Snap\nHere, the output shows the randomization of variables using rand. fig-2 Output - rand GitHub lab code link- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/rand/rand.sv GitHub lab output link- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/rand/rand_log.log randc# randc is random cyclic and cycles through all the values within their range before repeating any particular value. randc is cyclic in nature. It will give a random value and repeat it after completing the cycle.\nSyntax randc data_type variable_name; Example The below example is for randc variable.\nclass pack; randc bit [2:0]a; endclass module randc_var; pack pk=new(); initial begin $display (\u0026#34; randc - It is cyclic in nature . It will repeat \u0026#34;); $display (\u0026#34; it\u0026#39;s value after completing one cycle .\u0026#34;); for (int i =0; i\u0026lt;=12;i++)begin void\u0026#39;(pk.randomize ()); $display(\u0026#34;Iteration = %0d Random Value = %0d \u0026#34;, i ,pk.a); end end Above code, the class declared is pack inside class variable declared is a. Using the randc, variable a is randomized. Inside module, randomize () is used to randomize the class and for loop is iterating from 0 to 12.\nOutput Snap\nThe below output shows the randomization of variable using the randc. fig-3 Output- randc GitHub lab code link- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randc/randc_var.sv GitHub log output link- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randc/randc_var_log.log 3.std::randomize# std::randomize() is also called a Scope-Randomize Function. Scope randomize gives you the ability to randomize variables that are not members of a Class and even multiple variables can be randomized at the same time with either of the methods shown below.\nThe scope randomize is generally done for the local variables which are declared without the rand function and also users can specify random constraints for it. Even it can accept the inline constraints using the “with” clause. Below there are some syntaxes for declaring the std::randomize function.\nSyntax: std::randomize (variable); std::randomize (variable) with { constraint\u0026#39;s; }; std::randomize (variable-1, variable-2 ... variable-n); std::randomize (variable-1, variable-2 ... variable-n) with { constraint\u0026#39;s; }; Example: module std_random; bit [3:0]a; bit [3:0]b; bit [3:0]c; bit [3:0]d; bit [3:0]e; initial begin repeat(4)begin void\u0026#39;( std ::randomize(a)); $display(\u0026#34;value of a %d\u0026#34;,a); void\u0026#39;(std::randomize(b) with {b\u0026gt;6; a\u0026lt;12;}); $display(\u0026#34;value of b :%d\u0026#34;,b); void\u0026#39;(std::randomize(c,d) with {c\u0026lt;4; d\u0026lt;3;}); $display(\u0026#34;value of c :%d and d %d \u0026#34;,c,d); void\u0026#39;(std::randomize(e) with {e inside {[1:4]};}); $display(\u0026#34;value of e :%d \u0026#34;,e); end end endmodule In the above example, we declared 5 local variables. These variables are randomized using std::randomize(), even all the variables can be randomized at the same time by passing multiple variables as arguments to the randomize() function. Even we can specify our own inline constraints to the randomizing variables.\nThis is an advantage for randomizing the local variables and even in the module we can randomize multiple variables at the same time just like class_handle.randomize();\nOutput:\nUsing std::randomize inside the class:# If we randomize the variables using class_handle.randomize only those variables which are of type rand and randc are randomized. In order to overcome this we can use std::randomize(this), which will randomize all the variables of that class. But, the variables which are local to any function are not randomized, this is the main drawback of this std::randomize() function. For this local variables we need to randomize again using std function.\nExample: class test; int a; rand bit [2:0]b; constraint c1 { a \u0026gt;= 2;a \u0026lt;= 9; } function void display(); int c; if (std::randomize(this)); $display(\u0026#34;using std_randomize %0d , %d\u0026#34;,a,b); if (randomize(a)) $display(\u0026#34;randomize(a) %0d\u0026#34;,a); if (std::randomize(a)); $display(\u0026#34;using std_randomize(a) %0d\u0026#34;,a); if(std::randomize(b)) $display(\u0026#34;using std_randomize b: %0d\u0026#34;,b); if (std::randomize(c) with {c\u0026gt;1; c\u0026lt;4;}) $display(\u0026#34;using std_randomize with constraint,c: %0d\u0026#34;,c); if (this.randomize()); $display(\u0026#34;this randomize %0d %d\u0026#34;,a,b); endfunction endclass module tb; test t; initial begin t=new(); repeat (3) t.display(); end endmodule In this example, we declared int type \u0026lsquo;a\u0026rsquo; and rand bit type \u0026lsquo;b\u0026rsquo; variables in the class test and inside the display function we declared local variable \u0026lsquo;c\u0026rsquo;. So, when we use std::randomize(this) only the \u0026lsquo;a\u0026rsquo; and \u0026lsquo;b\u0026rsquo; variables are randomized leaving the local variable \u0026lsquo;c. Even we can randomize the local variable and can give inline constraints by using \u0026ldquo;with\u0026rdquo; clause.\nOutput: From the above output we can see the exact operation of std:randomize(), this function is strictly applicable only to the local variables. Even though there is constraint defined for variable \u0026lsquo;a\u0026rsquo; within the class, std::randomize(a) is not considering that global constraint as it is totally dependent on its inline constraint. Since there is no inline constraint for std::randomize(a), the simulator is considering the entire range of \u0026lsquo;a\u0026rsquo;.\nWhereas for variable \u0026lsquo;c\u0026rsquo; we have declared a inline construct whose range is between 1 to 4. Hence, the output of c is between this range.\nLimitations:\nstd::randomize(variable) considers only its inline constraint, or else it will consider its declared default range for randomization. std::randomize(this) is applicable only for randomizing the class variables. But this function will not consider the locally declared variables inside any function, hence there is more chance of missing some data during randomization. std::randomize(variable) is applicable only for locally declared variables. It cannot be accessed in any other functions or class. 4.Constraint Block# Constraint blocks are the class methods just like function and task. Constraints have a unique name in the class.\nSyntax constraint [constraint_name] {expression 1; expression 2; ... expression N;} Instead of begin end block, constraint blocks are enclosed with curly braces.\nConflict in constraint Conflict in constraint blocks are arise when - We declare more than one constraint with the same name. If there is non-matching in the given ranges of constraint. We can declare constraints inside and outside of the class. For declaring the constraint outside the class, use the \u0026ldquo;extern\u0026rdquo; keyword.\nDeclare the constraint outside the class block\nIf we declare constraint without using the extern keyword, then it will display a warning while compiling.\nDeclare constraints outside the class- Syntax class class_name; extern constraint constraint_name; endclass constraint class_name ::constraint_name{condition;} Example The below example will show the constraint declaration with the use of the extern keyword. Here, there are two constraints declared that is cons_name1 and cons_name2. cons_name1 is declared inside the class and cons_name2 is declared outside the class using the extern keyword.\nclass class_a; rand byte a; rand byte x; constraint const_name1{a\u0026lt;6; a\u0026gt;2;} extern constraint cons_name2; endclass constraint class_a:: cons_name2{x\u0026gt;7;} module mod; class_a pack; initial begin pack = new; for (int i =0;i\u0026lt;=5;i++)begin void\u0026#39;(pack.randomize()); $display ( \u0026#34;Iteration = %0d Value of a = %0d Value of x = %0d \u0026#34; , i,pack.a,pack.x); end end Output Snap The output, fig-4 shows the randomization of a variable using an extern constraint.\nfig-4 Output- extern constraint GitHub Lab file link- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/extern_cons/extern_cons.sv GitHub Lab Output link- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/extern_cons/extern_cons_log.log Over-riding Constraints# Constraints Override\nHere in this overriding of constraint, if we have the same constraint name in the parent class and the child class, then we can say that our constraint is overridden in the child class using the child class handle.\nExample Let us understand through an example:\nclass parent; rand byte a; rand byte b; constraint cons{a==0;b==5;} endclass:parent class child extends parent; constraint cons{a==5;b==8;} endclass:child module top; initial begin child t1; t1= new; for(int i=0;i\u0026lt;3;i++) begin if (!t1.randomize()) begin $display(\u0026#34;Randomization failed\u0026#34;); end else begin $display(\u0026#34;Iteration = %0d value of the a=%0d value of b=%0d\u0026#34;,i,t1.a,t1.b); end end end endmodule:top If you use different constraint names in the parent class and child class, that time randomization is failed. because the child class is extended from the parent so we can\u0026rsquo;t use different constraint names in the class.\nif we want to override the constraint we have to use the same constraint name for both parent and child classes. then we can override the parent things easily from the child class.\nIn the above example, we declared a class and the name is the parent and we are declaring one more class that extends from the parent class. Inside the parent, were writing constraints that are a=0 and b=5. then inside the child, we write the value to variables a=5 and b=8 and both are the same constraint name. and\nwere create the handle for the child and doing the randomization now the parent class constraint value is getting the override. the output of child constraint values is executed a=5 \u0026amp; b=8.\nOutput fig. The output of Constraints Override In the above example, in the 3 iterations, only the child constraints values are executed values are a= 5 and b=8.\nGitHub lab file link\nGitHub log file link\n5.Array Randomization# Randomization can also be done in array data types like static array, dynamic array and queues. The variables have to be declared with the type rand or randc to enable the randomization of the variable.\nStatic array randomization# In a static array, randomization is possible only for the array elements. As the size is fixed, it is not possible to change it.\nDeclare the array as the keyword rand or randc; on randomization, the elements of the array will get random values.\nExample -1\nThe below example show the randomization of the one-dimensional static array without using the constraint. class static_array; randc byte a[5]; endclass module stat_array; static_array stat_arr; initial begin stat_arr = new(); $display (\u0026#34;Static array - Size is already declared. So, we can only randomize \u0026#34;); $display (\u0026#34; the elements of it . \u0026#34;); $display (\u0026#34;Before randomize the elements of array \u0026#39;a\u0026#39;\u0026#34;); $display (\u0026#34;Assign by the default value of array data type.\u0026#34;); $display (\u0026#34; %0p\u0026#34;, stat_arr.a); void \u0026#39;(stat_arr.randomize ()); $display (\u0026#34;After randomize the elements of array \u0026#39;a\u0026#39;\u0026#34;); $display (\u0026#34;Output = %0p \u0026#34;,stat_arr.a); end Above code, declared an array \u0026lsquo;a[5]\u0026rsquo; of byte data type. The randomization is done by using the randomization function. Without using void, after compilation, the compiler displays a warning. Here, after the randomization of the class, the randomized array will be displayed.\nOutput Snap\nBelow fig-5 shows the output of randomization of the one array without using constraint. fig-5 Output-static array randomization GitHub lab code link- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/stat_arr/stat_single/stat_arr_rndm.sv GitHub lab output link- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/stat_arr/stat_single/stat_arr_rndm_log.log Example -2-\nThe below example shows the randomization of a two-dimensional static array without using constraint. class class_1; rand bit [3:0]a[2][4]; endclass module mod; class_1 pack; initial begin pack = new; $display (\u0026#34;The value elements of array before randomization = %0p\u0026#34;,pack.a); for (int i =0;i\u0026lt;=5;i++)begin void\u0026#39;(pack.randomize()); $display (\u0026#34;The value of elements of array after randomization = %0p\u0026#34;,pack.a); end end Above code, the array declared is a[2][4] with each element of size 4 bits. Inside the module, for loop is used to get more iterations.\nOutput Snap\nThe output is shown in fig-6, is the randomization of a two-dimensional array. fig-6 Output- multidimensional array randomization GitHub Lab File Link- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/stat_arr/stat_multi/stat_arr_multi.sv GitHub Lab Output Link- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/stat_arr/stat_multi/stat_arr_multi_log.log Example -3\nThe below example show the randomization of the multidimensional static array using the constraint. Inside the constraint, foreach loop is used to give the condition to the variable. Here, the array randomization is done 6 times. As we can see, all the element\u0026rsquo;s value is less than 12. class class_1; rand bit [4:0]a[2:0][3:0]; constraint cons_name1{foreach (a[i,j]) // standard way to represent multidimensional array using a[i][j]\u0026lt;12;} //foreach conditional statement endclass module mod; class_1 pack; initial begin $display (\u0026#34;Randomization of multidimensional array\u0026#34;); $display (\u0026#34;----------------------------------------\u0026#34;); pack=new(); $display (\u0026#34;Before randomization\u0026#34;); $display (\u0026#34; Array = %0p\u0026#34;,pack.a); // gives default value of data types . $display (\u0026#34;After randomization\u0026#34;); void\u0026#39;(pack.randomize()); for (int i =0;i\u0026lt;=5;i++)begin void\u0026#39;(pack.randomize()); $display (\u0026#34; Iteration = %0d, Array = %0p\u0026#34;,i,pack.a); end end Output Snap\nBelow fig-7 show the randomization of a multidimensional array using constraint. fig-7 Output - multidimensional array randomization using constraint GitHub Lab File Link- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/stat_arr/stat_cons/stat_cons.sv GitHub Lab Output Link- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/stat_arr/stat_cons/stat_cons_log.log Dynamic Array# A dynamic array has no predefined size during array declaration. Generally, the array_name.new() keyword is used to assign the size of the dynamic array.\nConstraints are used in two ways -\nTo limit the size of the dynamic array by using the keyword size in the constraint block. To give the value using operators for the elements of the dynamic array using \u0026ldquo;foreach\u0026rdquo; conditional statement in the constraint block. The below example will show how to randomize the dynamic array. The output after randomization is an empty array if the size is not constrained.\nExample class class_1; randc bit [7:0] dyn_arr[]; // declaring a dynamic array, each element is of 8 bits. constraint dyn_arr_size{dyn_arr.size()\u0026gt;3;dyn_arr.size()\u0026lt;7;} // declare the size of the dyn_arr between 3 to 7 constraint dyn_arr_ele{foreach (dyn_arr[i]) // each element value is square of the index number. dyn_arr[i]==i*i;} endclass module mod; class_1 pack; initial begin pack = new(); for (int i = 0;I\u0026lt;=2;i++)begin void\u0026#39;(pack.randomize()); $display (\u0026#34;Iteration =%0d Array =%0p\u0026#34;,i,pack.dyn_arr[i]); end end Above code, first declaring a dynamic array \u0026lsquo;dyn_arr[]\u0026rsquo;. Inside class declaring a constraint for giving the size range. Inside the module, randomize() function is used to randomize the class. The size of the array is between 3 to 7 using constraint. The output will be displayed after randomization for (size of array +1) times.\nOutput Snap\nThe below output is for dynamic array randomization. fig-8 Output - dynamic array randomization Lab link- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/dyn_arr/dyn_arr.sv log file link- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/dyn_arr/dyn_arr_log.log Queue# Queue size will get randomized based on size constraints, and queue elements will get random values.\nThe below example will show, how to randomize the elements of the queue.\nExample The below example shows the randomization of elements of the queue and using constraint declaring the size of the queue.\nclass class_1; rand bit [3:0]que[$]; constraint que_const{que.size()==5;} endclass module mod; class_1 pack; initial begin pack=new; for (int i = 0;i\u0026lt;=pack.que.size();i++)begin void\u0026#39;(pack.randomize()); $display (\u0026#34; Iteration = %0d The value of array =%0p\u0026#34;,i,pack.que); end end endmodule Output snap lab link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/queue/queue_code.sv output log file link\n6.Inside constraint# The inside keyword is used to check if a given value lies within the range. The values contained by the inside block can be variable, constant, or range. inside construct includes both upper and lower limits and it gathers all values and chooses between the values with equal probability. In the inside block, we write inside keyword followed by curly braces{}\nSyntax constraint const_name { variable inside { values or range };} Example: Let\u0026rsquo;s take an example of inside constraint for better understanding. // class declaration class PQR; // random variable declared using the rand keyword rand bit [3:0] var1; //constraint block constraint C1 {(var1 inside {[3:9]});} endclass module top; initial begin int i; //Here, we need to create a handle //handle name is pkt PQR pqr; //memory allocation to the handle pqr=new(); $display(\u0026#34;-------Output for inside constraint-------\u0026#34;); $display(\u0026#34;-------------------------------------------\u0026#34;); for(int i =1; i\u0026lt;7;i++)begin // The .randomize() function is used to randomize properties of an object of a class void\u0026#39;(pqr.randomize()); $display(\u0026#34;[%0t] @ iteration: %0d -----\u0026gt; var1=%0d\u0026#34;,$time,i,pqr.var1); end $display(\u0026#34;-------------------------------------------\u0026#34;); end endmodule In the above example, we declared a class, the class name is PQR in which variable var1 is declared. In the constraint block, we are declaring a range by the use of an inside keyword and the range lies between 3 and 9. In this, the random value will be printed between 3 and 9.\nOutput snap: The below figure shows the output of the inside constraint. Fig:-9 Output of inside constraint In the above example, we declared a class in which a random variable is declared as var1. In this,we are declaring a range by the use of an inside keyword and the range lies between 3 and 9. The random value will be printed between 3 and 9.\nGitHub Lab File link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/implication/common_constraint/inside/inside_const.sv GitHub Lab Output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/implication/common_constraint/inside/inside_const.sv.log 7..Inverted inside constraint# The inverted inside is the opposite of the inside operator. It can be achieved by just placing a not symbol ! before it. If we want to generate a value that should not be inside a range of values (range_of_values), here we can use the inside operator with negation\nSyntax constraint const_name { !(variable inside { values or range });} Example: Let\u0026rsquo;s take an example of invert inside constraint for better understanding. // class declaration class PQR; // random variable declared using the rand keyword rand bit [3:0] var2; //constraint block //here we use, not symbol before the inside keyword constraint C1 {!(var2 inside {[3:9]});} endclass module top; initial begin int i; //Here, we need to create a handle //handle name is pkt PQR pqr; //memory allocation to the handle pqr=new(); $display(\u0026#34;-----Output for invert inside constraint-----\u0026#34;); $display(\u0026#34;---------------------------------------------\u0026#34;); for(int i =1; i\u0026lt;7;i++) begin // The .randomize() function is used to randomize properties of an object of a class void\u0026#39;(pqr.randomize()); $display(\u0026#34;[%0t] @ iteration: %0d -----\u0026gt; var2=%0d\u0026#34;,$time,i,pqr.var2); end $display(\u0026#34;---------------------------------------------\u0026#34;); end endmodule In the above example, we declared a class, the class name is PQR in which variable var2 is declared. In the constraint block, we are declaring a range by the use of an inside keyword with the negation and the range lies between 3 and 9. If we want to generate a value that should not be inside a range of values, here we can use the inside operator with negation. In this, the random value will be printed that does not lie in range because of use of inside keyword with negation.\nOutput snap: The below figure shows the output of the inverted inside constraint. Fig:-10 Output of inverted inside constraint In the above example, we declared a class in which a random variable is declared as var2. In this, the random value will be printed that does not lie in range because of use of inside keyword with negation.\nGitHub Lab File link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/implication/common_constraint/invert_inside/invert_inside.sv GitHub Lab Output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/implication/common_constraint/invert_inside/invert_inside.sv.log 8.Weighted Distribution# The dist operator allows you to create the weighted distribution. dist is an operator that takes a list of values and weights, separated by := or :/ operator. The value which is more weight, the occurrence of that value in randomization is more. The dist operator is helpful whenever to have weighted distribution during randomization.\nThere are two types of distribution operators\n1. := operator# The := operator assigns the specified weight to the item or, if the item is a range, specified value to every value in the range.\nSyntax value := weightage Example: Let\u0026rsquo;s take an example := operator for better understanding. class myWorld; // random variable declared using the rand keyword rand bit [3:0] value1; //constraint block //In this, the weight of 1 is 30, 6 is 70, and 7 is 20 //while 2 through 5 is 40 constraint m_var { value1 dist { 1:=30, [2:5]:=40, 6:=70, 7:=20};} endclass module top; initial begin int i; //Here, we need to create a handle //handle name is world myWorld world; // memory allocation to the handle world = new(); $display(\u0026#34;-----Output for := operator-----\u0026#34;); $display(\u0026#34;The occurrence of \u0026#39;6\u0026#39; is more as \u0026#39;6\u0026#39; has more weight\u0026#34;); for(int i =0; i\u0026lt;10; i++) begin void\u0026#39;( world.randomize()); $display(\u0026#34;[%0t] @ iteration %0d -----\u0026gt; value1=%0d\u0026#34;,$time,i,world.value1); end end endmodule In this example, the weight of 1 is 30, 6 is 70, and 7 is 20 while 2 through 5 is 40, for a total of 280.\nHence the probability of choosing 1 is 30/280, 6 is 70/280, 7 is 20/280 and the probability of choosing a value between 2 and 5 is 40/280. In this 6 have appeared more because they have a higher weight and are chosen more often.\nOutput snap: The below figure shows the output of the weighted distribution with := operator. Fig-:11 Output of := operator In the above example, we are using a := operator. In this, the 6 is more weight in comparison to the other ones. The occurrence of 6 is more because 6 is more weight.\nGitHub Lab File link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/implication/common_constraint/weight1/weighted_distribution.sv GitHub Lab Output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/implication/common_constraint/weight1/wighted_distribution.sv.log 2. :/ operator# The :/ operator assigns the specified weight to the item or, if the item is a range, to the range as a whole. If there are n values in the range, the weight of each value is range_weight / n\nSyntax value :/ weightage Example Let\u0026rsquo;s take an example of :/ operator for better understanding. //class declaration class myWorld; //random variable declared using the rand keyword rand bit [3:0] value1; //constraint block //In this, the weight of 1 is 30, 6 is 40, and 7 is 20 //while 2 through 5 share a total weight of 60 constraint m_var { value1 dist { 1:/30, [2:5]:/60, 6:/40, 7:/20};} endclass //module name is top module top; initial begin int i; //Here, we need to create a handle //handle name is world myWorld world; //memory allocation to the handle world = new(); $display(\u0026#34;-----Output for :/ operator\u0026#34;); $display(\u0026#34; The occurrence of \u0026#39;6\u0026#39; is more as \u0026#39;6\u0026#39; has more weight\u0026#34;); $display(\u0026#34;--------------------------------\u0026#34;); for(int i =0; i\u0026lt;10; i++) begin void\u0026#39;( world.randomize()); $display(\u0026#34;[%0t] @ iteration %0d -----\u0026gt; value1=%0d\u0026#34;,$time,i,world.value1); end end endmodule In this example, the weight of 1 is 30, 6 is 40, and 7 is 20, while 2 through 5 share a total weight of 60, thus having 60/4 each.\nHence the probability of choosing 1 is 30/150, 6 is 40/150, 7 is 20/150 and the probability of choosing a value between 2 and 5 is 60/150. In this, 6 has appeared more than the other because it has the highest weight.\nOutput Snap:\nThe below figure shows the output of the weighted distribution with :/ operator. Fig-:12 Output of :/ operator In the above example, we are using a :/ operator in which 6 is the highest weight. In this, The occurrence of \u0026lsquo;6\u0026rsquo; is more because \u0026lsquo;6\u0026rsquo; has more weight in comparison to others.\nGitHub Lab File link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/implication/common_constraint/weighted_2/weighted_distribution2.sv GitHub Lab Output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/implication/common_constraint/weighted_2/weighted_distribution2.sv.log 9.Bidirectional constraint# Constraints are solved bidirectionally, which means constraints on all random variables will be solved parallel. Constraints solve parallelly for all random variables and make sure no constraint fails.\nExample: Let\u0026rsquo;s take an example of bidirectional constraint for better understanding. //class declaration class items; // random variable declared by using rand keyword rand bit [3:0] value1; //constraint block constraint addr_mode1 { value1 \u0026gt; 5; value1 \u0026lt;12;} constraint addr_mode2 {value1\u0026gt;6;} endclass // module name is constraint_top module constraint_top; initial begin int i; //Here, we need to create a handle //handle name is an item items item; //memory allocation to the handle item = new(); $display(\u0026#34; -----Output for bidirectional constraint-----\u0026#34;); $display(\u0026#34; -----constraint 1 \u0026amp; 2 limits the value to 7,8,9,10 and 11-----\u0026#34;); $display(\u0026#34;----------------------------------------------------------------\u0026#34;); for (int i =1;i\u0026lt;10;i++) begin void\u0026#39;(item.randomize()); $display(\u0026#34;[%0t] @ iteration %0d -----\u0026gt; value1 = %0d\u0026#34;,$time, i, item.value1); end $display(\u0026#34;----------------------------------------------------------------\u0026#34;); end endmodule In the above example, we declared a class, the class name is item in which variable value1 is declared. In the constraint blocks, we are giving some conditions in both constraints. Constraints on all random variables will be solved parallel.\nIn this, constraint 1 \u0026amp; 2 limits the value to 7,8,9,10 and 11.\nOutput snap: The below figure shows the output of the bidirectional constraint. Fig-:13 Output of bidirectional constraint In the above example, we declared a class in which a random variable is declared as a value1.\nIn this, constraint 1 \u0026amp; 2 limits the value to 7,8,9,10 and 11.\nGitHub Lab File link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/implication/common_constraint/bidirectional/bidirectional_const.sv GitHub Lab Output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/implication/common_constraint/bidirectional/bidirectional_const.sv.log 10.Implication Constraint# The implication operator is used to declare the conditional relations between two variables. The implication operator is placed between the expression and constraint.\nThe implication operator is denoted by the symbol -\u0026gt;\nImplication operator# The implication operator -\u0026gt; is used in a constraint expression to show the conditional relationship between two variables. The implication operator is placed between the expression and constraint.\nIf the expression on the LHS of implication operator -\u0026gt; is true, then the constraint expression on the RHS will be satisfied. If the LHS is not true, then the RHS expression is not considered.\nSyntax: constraint const_name { (variable1) -\u0026gt; (variable2) } Example: Let\u0026rsquo;s take an example of an implication operator for better understanding. //class declaration class ABC; // random variable declared using rand keyword rand bit [2:0] value1; rand bit [3:0] value2; //constraint block //implication operator is used to mention conditions between //two variables value1 and value2 constraint c_mode { (value1 inside {[1:5]}) -\u0026gt; (value2 \u0026lt;8);} endclass // module name is top module top; initial begin int i; //Here, we need to declare a handle //handle name is abc ABC abc; // memory allocation to the handle abc = new(); $display(\u0026#34;-----Output for implication constraint-----\u0026#34;); $display(\u0026#34;-------------------------------------------\u0026#34;); for(int i = 0; i\u0026lt; 10 ; i++) begin void\u0026#39;(abc.randomize()); $display(\u0026#34;[%0t] @ iteration %0d -----\u0026gt; value1=%0d , value2=%0d\u0026#34; ,$time,i, abc.value1, abc.value2); end $display(\u0026#34;--------------------------------------------\u0026#34;); end endmodule In the above example, we declared a class, class name is ABC in which two variables value1 and value2 are declared. In the constraint block, value1 has declared the range by using the inside keyword. In this, if the value1 lies between the range of 1 and 5 then the value2 is always less than 8. If the value1 does not lie between the range of 1 and 5 then the value2 is always greater than 8.\nOutput snap: The below figure shows the output of the implication constraint. Fig-:14 Output of implication operator In the above example, the implication operator is used in which we define two random variables value1 and value2. In this, if the value1 lies between the range of 1 and 5 then the value2 is always less than 8. If the value1 does not lie between the range of 1 and 5 then the value2 is always greater than 8.\nGitHub Lab file link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/implication/implication/implication/implication_constraint.sv GitHub Lab Output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/implication/implication/implication/implication_constraint.sv.log 11.if-else Constraint# The if-else block allows conditional execution of constraint. If the expression is true, all the constraints in the first constraint block must be satisfied, otherwise, all the constraints in the optional else constraint must be satisfied.\nExample: Let\u0026rsquo;s take an example of the if-else constraint for better understanding. // class declaration class basic; //value1 \u0026amp; value2 are the variables //random variables are created by rand keyword rand bit [3:0] value1; rand bit [2:0] value2; constraint c_var { if(value1 inside {[4\u0026#39;h3:4\u0026#39;h9]}) value2 == 1; else { value2 == 0;} } endclass //module name is top module top; int i=1; initial begin //here, we need to create a handle //handle name is pkt basic pkt; // memory allocation to the handle pkt = new(); $display(\u0026#34;-----Output for if else constraint-----\u0026#34;); $display(\u0026#34;If the value1 lies between the 3 to 9, \u0026#34;); $display(\u0026#34; then value2 will be 1 otherwise 0 \u0026#34;); $display(\u0026#34;-----------------------------------------------\u0026#34;); for (int i=0;i\u0026lt;5;i++)begin void\u0026#39;( pkt.randomize()); $display(\u0026#34;[%0t] @ iteration %0d -----\u0026gt; value1=%0d, value2 = %0d\u0026#34;,$time,i,pkt.value1,pkt.value2); end $display(\u0026#34;-----------------------------------------------\u0026#34;); end endmodule In the above example, we declared a class, class name is basic in which two variables value1 and value2 are declared. In the constraint block, we are using the if-else condition.\nIn the if statement, the value1 has declared a range with the use of the inside keyword, and if the range lies between 3 and 9 then the value2 will always be 1 and if the range does not lie between the range of 3 and 9 then the value2 always be 0.\nOutput snap:\nThe below figure shows the output of the if-else constraint. Fig-:15 Output of if-else constraint In the above example, we declared a class in which two random variables are declared value1 and value2. If the range lies between 3 and 9 then the value2 will always be 1 and if the range does not lie between the range of 3 and 9 then the value2 always be 0.\nGitHub Lab File link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/implication/implication/implication_ifelse/implication_ifelse.sv GitHub Lab Output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/implication/implication/implication_ifelse/implication_ifelse.sv.log 12.foreach constraint# The foreach constructs iterate over the elements of an array and assign all the values of each element to that of its index. The foreach loop iterates over the elements of an array, so constraints with the foreach loop are called Iterative constraints\nSyntax: constraint constraint_name { foreach ( variable[iterator] ) variable[iterator] \u0026lt;..conditions..\u0026gt; } Example: Let\u0026rsquo;s take an example of foreach constraint for better understanding. //class declaration class value; //random variable declared using rand keyword rand bit [3:0] s_array1[4]; rand bit [3:0] s_array2[5]; //constraint block //standard way to represent fixed array using //foreach conditional statement constraint cons {foreach(s_array1[i]) s_array1[i]==i; foreach (s_array2[i]) s_array2[i] == i;} endclass // module name is top module top; initial begin //here,we need to declare handle //handle name is val value val; //memory allocation to the handle val = new(); $display(\u0026#34;-------------------------------\u0026#34;); void\u0026#39;(val.randomize()); $display(\u0026#34;\\t s_array1=%0p\u0026#34; , val.s_array1); $display(\u0026#34;\\t s_array2=%0p\u0026#34; , val.s_array2); $display(\u0026#34;-------------------------------\u0026#34;); end endmdule In the above example, we declared a class and the class name is value in which two fixed arrays are defined. two arrays s_array1 and s_array2 are declared inside the class. This constraint will iterate through each of the elements in an array, and set each element to the value of its particular index\nOutput snap: The below figure shows the output of the foreach constraint. Fig-:16 Output for foreach constraint GitHub Lab File link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/implication/foreach_constraint/static_cons.sv GitHub Lab Output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/implication/foreach_constraint/static_cons.sv.log 13.Solve before Constraint# This constraint property is used inside the constraint block for specifying the constraint solving. If the variables are dependent as the constraint are bidirectional, the value of one variable will influence the other variable. This solve-before can change the probability distribution by forcing the constraint solver to choose the order in which constraints are to be solved.\nsyntax: constraint constraint_name {variable_1==1 -\u0026gt; variable_2==1;solve variable_1 before variable_2} Let\u0026rsquo;s take an example for a better understanding of the solve-before constraint\nExample: class without_solve_before; rand bit value1; rand bit [3:0] value2; constraint val {value1==1 -\u0026gt; value2==1;} endclass class with_solve_before; rand bit value1; rand bit [3:0] value2; constraint valu {value1==1 -\u0026gt; value2==1; solve value1 before value2;} endclass module solve_before(); without_solve_before gen1 = new(); with_solve_before gen2 = new(); initial begin $write(\u0026#34;%c[1;31m \\t------Without solve before----------\\n\u0026#34;,27); for(int i=1;i\u0026lt;=10;i++) begin void\u0026#39;(gen1.randomize()); #1 $display(\u0026#34;\\t[%0t] @ iteration: %0d -----\u0026gt; value1: %0d \\t value2: %0d\u0026#34;,$time,i,gen1.value1,gen1.value2); end $write(\u0026#34;\\n%c[1;34m\\t -----with solve before--------\\n\u0026#34;,27); for(int i=1;i\u0026lt;=10;i++) begin void\u0026#39;(gen2.randomize()); #1 $display(\u0026#34;\\t[%0t] @ iteration: %0d -----\u0026gt; value1: %0d \\t value2: %0d\u0026#34;,$time,i,gen2.value1,gen2.value2); end $write(\u0026#34;%c[0m\u0026#34;,27); end endmodule : solve_before In the above example, took two classes named without_solve_before and with_solve_before which have objects gen1 and gen2 respectively. Both have the same constraints that if the value1 is 1 then the value2 should be 1. As the constraint solver is bidirectional the probability to choose a value2 also affects the probability to choose value1.\nThe probability to choose individually. value1 is 1/2 value2 is 1/16\noutput: Fig-:17 Output of Solve before In the above output, the first 32 iterations are used without solve-before and the next 10 iterations are used with solve before.\nwithout: both value1 and value2 constraints are taken into consideration i.e., probability of value1 to get 1 is 1/2 and for value2 to be 1 is 1/16,but for getting value1 as 1 \u0026amp; value2 as 1 is (1/2)*(1/16)=1/32. with: here the constraint solver first randomizes value1 and depending upon the value1, value2 is solved. so the probability of getting a value1 as 1 is 1/2.\nso in the first 32 iterations, there was only 1 iteration that got value1 of 1 i.e., 0.03%, but using solve before value1 got 1 for every alternative iteration means 50%.\nGithub code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/solve_before_constraint/solve_before.sv Github output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/solve_before_constraint/solve_before_log.log limitations: can\u0026rsquo;t use randc variables, as they were always allowed to solve first, if used then without solve-before is not considered. shouldn\u0026rsquo;t have circular dependency i.e., solve value1 before value2 and solve value2 before value1, if so through error as shown below. Fig.18 : Error of solve before 14.Static Constraint# static constraints are shared across all the objects of that class.\nA static constraint mode can be enabled or disabled by any object handle of that class which reflects in all the classes.\nsyntax: static constraint constraint_name {constraint1; constraint2; ........ constraintN;} Example: class class1; rand bit [2:0] value; constraint cons {value==1;} endclass class class2; rand bit [2:0] value; static constraint cons {value==1;} endclass initial begin object_1.cons.constraint_mode(0); for(int i=1;i\u0026lt;=3;i++) begin void\u0026#39;(object_1.randomize()); void\u0026#39;(object_2.randomize()); #1 $display(\u0026#34;\\t[%0t] @ iteration: %0d -----\u0026gt; value in object_1: %0d value in object_2: %0d\u0026#34;,$time,i,object_1.value,object_2.value); end object_3.cons.constraint_mode(0); for(int i=1;i\u0026lt;=3;i++) begin void\u0026#39;(object_3.randomize()); void\u0026#39;(object_4.randomize()); #1 $display(\u0026#34;\\t[%0t] @ iteration: %0d -----\u0026gt; value in object_3: %0d value in object_4: %0d\u0026#34;,$time,i,object_3.value,object_4.value); end end In the above example, there were two classes named class1 \u0026amp; class2 with objects 1\u0026amp;2 for class1 and objects 3\u0026amp;4 for class2. Here the constraint for both classes is the same so the value should be always 1 if the constraint is on.\nIf the constraint is off then the value will have other than 1.\ngif 1. static constraint From the above gif, can say that if the non-static constraint is turned off/on by using a single object handle then the constraint is applicable to that particular object whereas in static constraint, if the constraint is turned off/on then it is applicable for every object of that class.\noutput: Fig-:19 Output of static constraint output Class 1 has two objects 1\u0026amp;2 and class2 has objects 3\u0026amp;4.In class1 used non-static constraint, turned off in object 1 but still, the constraint is on in object 2, but used static constraint in class2, and turned off in object 3 then the constraint has been turned off in object 4 as well.\nGithub code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/static_constraint/static_constraint.sv Github output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/static_constraint/static_constraint_log.log 15.Randomization Methods# In general, there will be three randomize methods:\nrandomize(); pre_randomize(); post_randomize(); gif 2: Randomization methods when a randomize function is called generates random values for variables that were declared as rand/randc by considering the constraints. It is a virtual function that is not overridable and on successful completion of randomization returns 1 else 0.\nActually, before performing the actual randomization, the simulator first enters into pre_randomize before randomizing, and then on successful randomization simulator enters into the post_randomize function which is also overridable. If the randomization fails due to any issues like constraint conflicts then the simulator doesn\u0026rsquo;t enter into post_randomize and returns 0.\nrandomize:# randomize is a virtual function of int type returns 1 on successful completion else 0\nExample: class generator; rand bit [2:0] value; constraint cons {value==5;} endclass module randomization(); generator gen = new(); initial begin $display(\u0026#34;\\tCalling Randomize....\u0026#34;); if(gen.randomize()) $display(\u0026#34;\\tvalue: %0d \\tRandomization successful\u0026#34;,gen.value); else $display(\u0026#34;\\tvalue: %0d \\tRandomization Failed\u0026#34;,gen.value); $display(\u0026#34;\\tCalling Randomize....\u0026#34;); if(gen.randomize()with{value==2;}) $display(\u0026#34;\\tvalue: %0d \\tRandomization successful\u0026#34;,gen.value); else $display(\u0026#34;\\tvalue: %0d \\tRandomization Failed\u0026#34;,gen.value); end endmodule output: Fig-:20 Output of Randomization In the above example calling randomize function and after randomization was done taking constraint that value must be 5 if randomization is successful else prints randomization failed and the previous random value will be present in the variable.\nIn the first randomization, there is no conflict so randomization completes successfully and returns 1 so if condition satisfies so prints as randomization successful, In the next call conflict between constraints so randomization doesn\u0026rsquo;t complete so returns 0 so prints as randomization failed and has the previous random value i.e., 5.\nNote: If the randomization fails in the first iteration then the value of the variable will be the default value of the variable. If randomization fails after some successful randomization then the previous randomized value will be present in the variable.\nGithub code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randomization_methods/randomization/randomization.sv Github output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randomization_methods/randomization/randomization_log.log pre_randomize:# This is a void function type that can be overridable called before the actual randomization performs.\nsyntax: function void pre_randomize(); Example: class generator; rand bit [2:0] value; constraint exp { value\u0026gt;5;} function void pre_randomize(); if(i%2==0) begin rand_mode(0); $display(\u0026#34;\\tstopping randomization\u0026#34;); end else rand_mode(1); i++; endfunction endclass module pre_randomization(); generator gen = new(); initial begin for(int i=1;i\u0026lt;=4;i++) begin $display(\u0026#34;\\t[%0t]Calling Randomize....\u0026#34;,$time); void\u0026#39;(gen.randomize()); #1 $display(\u0026#34;\\t[%0t] @ iteration: %0d -----\u0026gt; value: %0d \u0026#34;,$time,i,gen.value); end end endmodule output: Fig. 21 Output of Pre randomization In the example, calling pre_randomize function and inside that, if condition satisfies then randomization is stopping in pre_randomize so simulator exits the randomize function without performing the randomization which means rand variables will have previous values. In iterations 1,3 randomization is stopped, so it has previous values but in iterations 2,4 randomization is done.\nGithub code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randomization_methods/pre_randomization/pre_randomization.sv Github output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randomization_methods/pre_randomization/pre_randomization_log.log post_randomize:# This is also a void function type that can be overridable runs after the randomization is performed.\nsyntax: function void post_randomize(); Example: function void pre_randomize(); $display(\u0026#34;\\tI\u0026#39;m in pre_randomize function\u0026#34;); check=0; endfunction function void post_randomize(); $display(\u0026#34;\\tI\u0026#39;m in post_randomize function\u0026#34;); check=1; endfunction initial begin $display(\u0026#34;\\t[%0t]Calling Randomize....\u0026#34;,$time); check=gen.randomize(); #1 $display(\u0026#34;\\t[%0t] @ iteration: 1 -----\u0026gt; value: %0d \u0026#34;,$time,gen.value); if(check==1) $display(\u0026#34;%c[1;32m\\tRandomization is performed%c[0m\u0026#34;,27,27); else $display(\u0026#34;%c[1;31m\\tRandomization is not performed%c[0m\u0026#34;,27,27); $display(\u0026#34;\\t[%0t]Calling Randomize....\u0026#34;,$time); check=gen.randomize()with{value\u0026lt;5;}; #1 $display(\u0026#34;\\t[%0t] @ iteration: 2 -----\u0026gt; value: %0d \u0026#34;,$time,gen.value); if(check==1) $display(\u0026#34;%c[1;32m\\tRandomization is performed%c[0m\u0026#34;,27,27); else $display(\u0026#34;%c[1;31m\\tRandomization is not performed%c[0m\u0026#34;,27,27); end output: Fig.22 output of Post randomization In the first iteration of the example calling randomize function, there was no conflict so entering into both pre as well as post after randomizing so printed as randomization is successful but in the second iteration there was a conflict so randomization doesn\u0026rsquo;t completes and comes back and printing as randomization is failed.\nGithub code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randomization_methods/post_randomization/post_randomization.sv Github output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randomization_methods/post_randomization/post_randomization_log.log 16.Inline Constraint# Consider that some variables are needed to be randomized in 100 iterations but in the first 95 iterations user needs the common constraints, and in the last 5 iterations user wants to add some more constraints along with previous constraints, then instead of writing in different classes user can just add those extra constraints from where the randomization function is called using with the keyword as shown.\nsyntax: obj_hndl.randomize()with{extra_constraints}; These inline constraints just act as extra constraints by taking the previous constraints into consideration but not overriding the previous constraints. For example, if variable \u0026gt;5 is declared in class and if added one more inline constraint as variable\u0026lt;10 then the final value of the variable will be between 5 and 10.\nOnly inline constraint inline constraint along with class constraint inline conflict with class constraint Only inline constraint# Example: class generator; rand bit [2:0] value; endclass module only_inline(); generator gen = new(); initial begin for(int i=1;i\u0026lt;=2;i++) begin void\u0026#39;(gen.randomize()with{value==3;}); #1 $display(\u0026#34;\\t[%0t] @ iteration: %0d -----\u0026gt; value: %0d\u0026#34;,$time,i,gen.value); end end endmodule In the above example, there were no constraints in class so the value can be anywhere between 0 to 7 as it is 3-bit, but calling the randomize function along with inline constraint that value should be 3.\noutput: Fig.23 output of only inline constraint As per the inline constraint, the value must be 3 so in both iterations the value is the same.\nGithub code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/inline_constraints/only_inline/only_inline.sv Github output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/inline_constraints/only_inline/only_inline_log.log inline constraint along with class constraint# Example: class generator; rand bit [2:0] value; constraint exp { value\u0026gt;2;} endclass module inline_constraint(); generator gen = new(); initial begin void\u0026#39;(gen.randomize()); #1 $display(\u0026#34;\\t[%0t] @ iteration: %0d -----\u0026gt; value: %0d\u0026#34;,$time,i,gen.value); void\u0026#39;(gen.randomize()with{value==7;}); #1 $display(\u0026#34;\\t[%0t] @ iteration: %0d -----\u0026gt; value: %0d\u0026#34;,$time,i,gen.value); end endmodule In the above example, the class has one constraint that the value should be greater than 2 and one more constraint is given through inline that the value should be 7.\noutput: Fig.24 output of inline constraint along with class constraint The initial constraint in class is value \u0026gt;2 so its first iteration value is in the range of 2 to 7, but in the second iteration giving value must be 7 from inline so the value is 7\nGithub code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/inline_constraints/class_and_inline/inline_constraint.sv Github output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/inline_constraints/class_and_inline/inline_constraint_log.log inline conflict with class constraint# Example: class generator; rand bit [2:0] value; constraint cons {value==5;}; endclass module conflict_with_inline(); generator gen = new(); int check; initial begin for(int i=1;i\u0026lt;=2;i++) begin check=gen.randomize()with{value==3;}; if(check) $display(\u0026#34;\\tRandomization Done \\t @ iteration: %0d -----\u0026gt; value: %0d\u0026#34;,i,gen.value); else $display(\u0026#34;\\tRandomization Failed \\t @ iteration: %0d -----\u0026gt; value: %0d\u0026#34;,i,gen.value); end end endmodule In the above example, the class has a constraint that the value must be 5 and from the inline constraint, there was one more constraint mentioned that value should be 3.\noutput: Fig.25 output of inline conflict with class constraint Here the constraint solver takes both the constraints into consideration which means there was a conflict between these constraints, in these times randomization will not happen and returns the value 0. so based on the check display message is printed.\nGithub code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/inline_constraints/conflict_with_inline/conflict_with_inline.sv Github output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/inline_constraints/conflict_with_inline/conflict_with_inline_log.log note:\nNot throwing any error from Questa sim 10.6 version simulator In mentor graphics of 2021 version it\u0026rsquo;s throwing an error that constraint conflict arose as shown below Fig. 26 Constraint conflict error 17.Soft Constraint# Constraints declared with the keyword soft are called as soft constraints.\nIf any conflict between class constraint and inline constraint leads to a randomization failure, it is clear that it is not possible to override the class constraint by using an inline constraint. So some test-case demand overrides the constraints, this can be done by using a soft keyword in class constraint.\nSyntax constraint constraint_name { soft variable_name \u0026gt; range ; } Example\nfor a better understanding purpose, we are executing the two codes. First Let\u0026rsquo;s take an example for a better understanding of the normal constraints without using soft constraint\nclass pack; rand bit [0:3]a; constraint addr_a{a\u0026gt;5;} endclass module soft_without_conflict; pack pkh; initial begin pkh = new; $display(\u0026#34;without using soft constraint output\u0026#34;); for(int i =0; i\u0026lt;5;i++) begin void\u0026#39;(pkh.randomize()); $display(\u0026#34;\\n \\t a=%0d value =%0d\u0026#34;,i,pkh.a); end pkh = new; $display(\u0026#34;\\n \\t output of without conflict\u0026#34;); for(int i =0; i\u0026lt;5;i++) begin void\u0026#39;(pkh.randomize()with {a\u0026lt;5;}); $display(\u0026#34;\\n \\t a=%0d value =%0d\u0026#34;,i,pkh.a); end end endmodule In the above example, we took a class name as pack which has an object pkh. the class has a constraint name called addr_a in that constraint is displayed from 0 to 5 value. and inside the module we are using inline constraint it will display from 0 to 10 values but we are using here inline constraint so This Constraint addr_a will be overridden.\nOutput Snap\nfig.27 Output of without soft constraint In the above example, in the starting 5 iterations normal constraints are executed so it displays the value from 5 to 15, and another 5 iterations inline constraint is executed so it displays the value from 10 to 0.\nGitHub lab file link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/constraints/soft_without_conflict GitHub log file link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/soft_without_conflict/soft_without_conflict_output.log Let\u0026rsquo;s take an example for a better understanding of the Soft constraint\nclass pack; rand bit [0:3]a; constraint addr_a{a\u0026gt;5;} endclass module soft_with_conflict; pack pkh; initial begin pkh = new; $display(\u0026#34;output of soft with conflict \u0026#34;); for(int i =0; i\u0026lt;5;i++) begin void\u0026#39;(pkh.randomize()with {a\u0026lt;5;}); $display(\u0026#34;\\n \\t a=%0d value =%0d\u0026#34;,i,pkh.a); end pkh = new; $display(\u0026#34;\\n \\t using soft constraint to solve conflict issue\u0026#34;); for(int i =0; i\u0026lt;5;i++) begin void\u0026#39;(pkh.randomize()with {soft a\u0026lt;10;}); $display(\u0026#34;\\n \\t a=%0d value =%0d\u0026#34;,i,pkh.a); end end endmodule In the above example, we took a class name as pack which has an object pkh. the class has a constraint name called addr_a in that constraint as to be displayed from 0 to 5 value but it\u0026rsquo;s not displaying anything. and inside the module we are using inline constraint the is also not displaying anything because here the conflict will occur so resolve this conflict we are using a soft constraint. and it displays the value from 10 to 0 values.\nOutput Snap\nfig 28. The output of soft with conflict In the above example, in the starting 5 iterations, normal constraints are executed so it displays the value zero because in the inside code already conflict occurred. another 5 iterations using soft constraints to execute the code, display the value from 10 to 0.\nGitHub lab file link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/soft_with_conflict/soft_with_conflict.sv GitHub log file link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/soft_with_conflict/soft_with_conflict_output.log # 18.Disable constraint# Constraints in a class can be disabled using the constraint_mode method\nBy default all the constraints will be enabled, during the randomization constraint user will not consider the disabled constraints.\nconstraint_mode(1) means constraint block is enabled\nconstraint_mode(0) means constraint block is disabled\nThe default value of constraint_mode is 1, i.e enabled once the constraint block is disabled, it is required to make constraint_mode(1) enable back the constraint block.\nSyntax: object_handle.constraint_block_name.constraint_mode(enable); enable == 1, constraint block enable enable == 0, constraint block disable\nExample Let\u0026rsquo;s take an example for a better understanding of the disabled Constraint\nclass packet; rand bit [3:0] data; constraint data_range { data inside {5,10,15}; } endclass module constraint_mode; packet pkt = new(); initial begin $display(\u0026#34;If constraint is mode is 1 it will display the 5,10,15\u0026#34;); $display(\u0026#34;If constraint is mode is 0 it will display the random values\u0026#34;); $display(\u0026#34;\\t Before Constraint disable\u0026#34;); $display(\u0026#34;\\t Value of constraint mode = %0d\u0026#34;,pkt.data_range.constraint_mode()); void\u0026#39;( pkt.randomize()); $display(\u0026#34;\\tdata = %0d\u0026#34;,pkt.data); pkt.data_range.constraint_mode(0); $display(\u0026#34;After Constraint disable\u0026#34;); $display(\u0026#34;Value of constraint mode = %0d\u0026#34;,pkt.data_range.constraint_mode()); repeat(5) begin void\u0026#39;(pkt.randomize()); $display(\u0026#34;\\tdata = %0d\u0026#34;,pkt.data); end end endmodule In the above example, we took a class name as packet which has an object pkt. the class has a constraint name called data_range in that constraint will be displayed 5, 10, 15. constraint mode is enabled (1) it displays the values 5, 10, and 15 and if constraint mode is disabled (0) it displays any values.\nOutput snap fig 29. The output of Disable constraint In the above output, If constraint mode is 1 it displays 5,10,15, and if disabled the constraint using constraint mode is 0 then it displays the any random values.\nGitHub lab file link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_mode/constraint_mode_code.sv GitHub log file link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_mode/constraint_mode_code_output.log 19.Disable randomization# The rand_mode() method is used to disable the randomization of a variable declared with the rand/randc keyword.\nrand_mode(1) means randomization enabled\nrand_mode(0) means randomization disabled\nThe default value of rand_mode is 1, i.e enabled\nOnce the randomization is disabled, it is required to make rand_mode(1) enable back the randomization rand_mode can be called as SystemVerilog method, the randomization enables/disable status of a variable can be obtained by calling variable.rand_mode().\nthe rand_mode method returns 1 if randomization is enabled else returns 0\nSyntax object_hanlde.variable_name.rand_mode(enable); //enable = 1, randomization enable //enable = 0, randomization disable Example Let\u0026rsquo;s take an example for a better understanding of the disable randomization\nclass packet; rand bit [2:0]data1; randc bit [1:0]data2; int state; function rand_mode1(int a); if(a==0) begin rand_mode(a); state = a; end else if(a==1) begin rand_mode(a); state = a; end endfunction endclass module randomization_mode; packet pkt = new(); int c; initial begin $display(\u0026#34;Before Randomization data1 = %0d data2= %0d\u0026#34;,pkt.data1,pkt.data2); if(pkt.data1.rand_mode()) if (pkt.data2.rand_mode()) pkt.state = 1; $display(\u0026#34;randomization of all variables are enabled\u0026#34;); for(int i = 0;i\u0026lt;5;i++) begin c = pkt.randomize(); $display(\u0026#34;[%0d] After enable the randomizations data1 =%0d, data2 = %0d\u0026#34;,i,pkt.data1,pkt.data2); $display(\u0026#34;[%0d] state = %0d\u0026#34;,i,pkt.state); if(i==3) begin pkt.rand_mode1(0); $display(\u0026#34;[%0d] state = %0d\u0026#34;,i,pkt.state); end $display(\u0026#34;[%0d] After disable in the randomization data1 =%0d, data2 = %0d\u0026#34;,i,pkt.data1,pkt.data2); end end endmodule In the above example, we took a class name as packet which has an object pkt. inside the class, we are declaring a function name called rand_mode1 which has the variable is state. if state = 1 randomization enabled, state = 0 randomization disabled.\nwe were declaring the output 0 to 5 variations, in that 0 to 3, enable randomization and disable randomization both randomization has happened. and remaining 4 \u0026amp; 5 variations only randomization happens.\nOutput snap\nFig.30 The output of Disable randomization In the above output, using Randomization mode is 1 to enable the randomization, then it will display the random data . using randomization mode is 0 to disable the randomization, then it displays the zero or previous randomization data. In our output snap, iterations from 0 to 3 both randomization enable disable are happening and in iteration 4 only randomization disable is happening.\nGitHub lab file link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randomization_mode/randomization_mode_code.sv GitHub log file link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randomization_mode/randomization_mode_code_output.log 20.randcase# The keyword randcase introduces a case statement that randomly selects one its of branches.\nThe case item expressions are positive integer values that represent the weights associated with each item.\nThe probability of selecting an item is derived by the division of that item\u0026rsquo;s weight divided by the sum of all weights.\nSyntax\nrandcase item: statement endcase Example\nLet\u0026rsquo;s take an example for a better understanding of the randcase\nmodule r_case; initial begin $display(\u0026#34;Random data will be generated by simulator\u0026#34;); $display(\u0026#34;data from 0 to 3 then it will display randcase output\u0026#34;); for(int i =0; i\u0026lt;6;i++) begin randcase 0:$display(\u0026#34;\\t \\n output of randcase 0\u0026#34;); 1:$display(\u0026#34;\\t \\n output of randcase 1\u0026#34;); 2:$display(\u0026#34;\\t \\n output of randcase 2\u0026#34;); 3:$display(\u0026#34;\\t \\n output of randcase 3\u0026#34;); endcase end end endmodule In the above example, we were using randcase, if its expressions match it displays. Each call to randcase retrieves one random number in the range of 0 to the sum of the weights. the weights are then selected in declaration order of small random numbers corresponding to the first (top) weight statements.\nOutput snap\nFig.31 output of the randcase In the above output, using randcase to generate the 0 to 3 values if any expressions is match it displays outputs.\nIn the above-output snap, the sum of all weights is 6; therefore, the probability of taking the first branch is (1/6) i.e. 0.166. The probability of taking the second is (2/6) i.e. 0.33, and the probability of taking the third is (3/6) i.e. 0.5. Each call to the randcase statement will return a random number in the range from 0 to 3.\nGitHub lab file link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randcase/randcase_code.sv GitHub log file link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randcase/randcase_code_output.log Memory partition using constraints# Memory block randomization# Assume that you have a memory of size 2048 i.e., 2KB in design to store some data, then if we need some block of that 2KB memory for some purpose, for partitioning that memory we can use constraints.\nExample:\nclass memory_block; bit [31:0] mem_ram_start,mem_ram_end; rand bit [31:0] mem_start_addr,mem_end_addr; rand int mem_block_size; constraint mem {mem_start_addr\u0026gt;=mem_ram_start; mem_start_addr\u0026lt;mem_ram_end; mem_start_addr%4==0; mem_end_addr==mem_start_addr+mem_block_size-1;} constraint block_size {mem_block_size inside {32,64};} function void display(); $display(\u0026#34;\\t----memory block----\u0026#34;); $display(\u0026#34;\\t RAM start addr : %0d\u0026#34;,mem_ram_start); $display(\u0026#34;\\t RAM end addr : %0d\u0026#34;,mem_ram_end); $display(\u0026#34;\\t BLOCK start addr : %0d\u0026#34;,mem_start_addr); $display(\u0026#34;\\t BLOCK end addr : %0d\u0026#34;,mem_end_addr); $display(\u0026#34;\\t BLOCK SIZE:%0d\u0026#34;,mem_block_size); endfunction endclass module single_memory_block(); memory_block memb =new(); initial begin memb.mem_ram_start=32\u0026#39;h0; memb.mem_ram_end=32\u0026#39;h7ff; void\u0026#39;(memb.randomize()); memb.display(); end endmodule In the above example,we took start address is 0 and end address is 2047, and gave constraints such that the block size should be of either 32, 64(int).The block should start at multiple of 4 and should end depending on the block_size.\noutput:\nFig. 32. output of the Memory block randomization The output of the above example is shown in above diagram, for constraint of block size , solver gave 64.Based on this block size the solver will give a start address such that the memory block will be within the range of 2KB. here gave it as 1896 which is multiple of 4 and from there 64 it will be 1959 as end address.\nGitHub lab file link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_memory_examples/single_memory_block/single_memory_block.sv **GitHub log file link ** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_memory_examples/single_memory_block/single_memory_block_log.log Memory n equal partitions# Here we will try to divide the given memory into n equal parts of partitions.\nExample:\nclass memory_block; bit [31:0] mem_ram_start,mem_ram_end; rand int mem_num_parts,mem_part_size; rand bit [31:0] mem_part_start[]; constraint parts {mem_num_parts\u0026gt;=2; mem_num_parts\u0026lt;=8;} constraint part_size {mem_part_size==(mem_ram_end-mem_ram_start)/mem_num_parts+1;} constraint patition {mem_part_start.size()==mem_num_parts; foreach(mem_part_start[i]) if(i) mem_part_start[i]==mem_part_start[i-1]+mem_part_size; else mem_part_start[i]==mem_ram_start;} function display(); $display(\u0026#34;\\t RAM start addr : %0d \u0026#34;,mem_ram_start); $display(\u0026#34;\\t RAM end addr : %0d \u0026#34;,mem_ram_end); $display(\u0026#34;\\t No of Partitions : %0d \u0026#34;,mem_num_parts); $display(\u0026#34;\\t Size of each partition : %0d \u0026#34;,mem_part_size); $display(\u0026#34;\\n\\t -----------partitions----------- \u0026#34;); foreach(mem_part_start[i]) begin if(i==mem_num_parts-1) $display(\u0026#34;\\t Partition : %0d from %0d to %0d \u0026#34;\\ ,i+1,mem_part_start[i],mem_ram_end); else $display(\u0026#34;\\t Partition : %0d from %0d to %0d \u0026#34;\\ ,i+1,mem_part_start[i],mem_part_start[i+1]-1); end endfunction endclass module memory_n_equal_partitions(); memory_block memb=new(); initial begin memb.mem_ram_start=32\u0026#39;h0; memb.mem_ram_end=32\u0026#39;h7ff; void\u0026#39;(memb.randomize()); void\u0026#39;(memb.display()); end endmodule In the above example, we have taken a memory of 2KB and tried to make it into n equal partitions.\noutput:\nFig.33. output of the Memory n equal partitions All the constraints are solved in parallel, here let\u0026rsquo;s say first took a number between 2 \u0026amp; 8 i.e., 7 in this case, and then divide the whole memory by 7 i.e., 293 which will be almost equal to 2KB. Here we tried to assign the start address of every part using the array and each part with space 293 each.\nGithub lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_memory_examples/memory_n_equal_partitions/memory_n_equal_partitions.sv Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_memory_examples/memory_n_equal_partitions/memory_n_equal_partitions_log.log Memory n variable partitions# In the following example, we are trying to divide one block of memory into n partitions but need not to be equal.\nExample:\nclass memory_block; bit [31:0] mem_ram_start,mem_ram_end; rand int mem_num_parts,mem_part_size[]; rand bit [31:0] mem_part_start[]; constraint parts {mem_num_parts\u0026gt;=2; mem_num_parts\u0026lt;=8;} constraint part_sizes {mem_part_size.size()==mem_num_parts; mem_part_size.sum()==mem_ram_end-mem_ram_start+1; foreach(mem_part_size[i]) mem_part_size[i] inside {16,32,64,128,256,512,1024,2048,4096}; } constraint partition {mem_part_start.size()==mem_num_parts; foreach(mem_part_start[i]) if(i) mem_part_start[i]==mem_part_start[i-1]+mem_part_size[i-1]; else mem_part_start[i]==mem_ram_start;} function display(); $display(\u0026#34;\\t RAM start addr : %0d \u0026#34;,mem_ram_start); $display(\u0026#34;\\t RAM end addr : %0d \u0026#34;,mem_ram_end); $display(\u0026#34;\\t No of Partitions : %0d \u0026#34;,mem_num_parts); $display(\u0026#34;\\n\\t -----------partitions-----------\u0026#34;); foreach(mem_part_start[i]) begin if(i==mem_num_parts-1) $display(\u0026#34;\\t Partition : %0d with size :%0d from %0d to %0d \u0026#34;\\ ,i,mem_part_size[i],mem_part_start[i],mem_ram_end); else $display(\u0026#34;\\t Partition : %0d with size :%0d from %0d to %0d \u0026#34;\\ ,i,mem_part_size[i],mem_part_start[i],mem_part_start[i+1]-1); end endfunction endclass module memory_n_var_partitions(); memory_block memb=new(); initial begin memb.mem_ram_start=32\u0026#39;h0; memb.mem_ram_end=32\u0026#39;h3fff; void\u0026#39;(memb.randomize()); void\u0026#39;(memb.display()); end endmodule Here the memory size given is 16KB, then taking a constraint to divide by n parts i.e., 8 parts in this example. One more constraint is given such that the total sum of all the n variant partitions and allocated the particular sizes for partitions using foreach constraint.The divisions of the partitions are shown in the following diagram.\noutput:\nFig.34. the output of the Memory n variable partitions **Github lab code link: ** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_memory_examples/memory_n_var_partitions/memory_n_var_partitions.sv Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_memory_examples/memory_n_var_partitions/memory_n_var_partitions_log.log Memory partitions with spaces in between# In this example, it was similar to the previous example like dividing n variable partitions but here adding space parts also in between the partitions .\nExample:\nclass memory_block; bit [31:0] mem_ram_start,mem_ram_end; rand int mem_num_parts,mem_part_size[],mem_space[]; rand bit [31:0] mem_part_start[]; constraint parts {mem_num_parts\u0026gt;4; mem_num_parts\u0026lt;10;} constraint part_sizes {mem_part_size.size()==mem_num_parts; mem_space.size()==mem_num_parts-1; mem_part_size.sum()+mem_space.sum()==mem_ram_end-mem_ram_start+1; foreach(mem_part_size[i]) { mem_part_size[i] inside {256,512,1024,2048}; if(i\u0026lt;mem_space.size()) mem_space[i] inside {64,256,512,1024}; } } constraint partition {mem_part_start.size()==mem_num_parts; foreach(mem_part_start[i]) if(i) mem_part_start[i]==mem_part_start[i-1]+mem_part_size[i-1]; else mem_part_start[i]==mem_ram_start;} function display(); $display(\u0026#34;\\tRAM start addr : %0d \u0026#34;,mem_ram_start); $display(\u0026#34;\\tRAM end addr : %0d \u0026#34;,mem_ram_end); $display(\u0026#34;\\tNo of Partitions : %0d \u0026#34;,mem_num_parts); $display(\u0026#34;\\tmem_part_size : %0p\u0026#34;,mem_part_size); $display(\u0026#34;\\tmem_space : %0p\u0026#34;,mem_space); $display(\u0026#34;\\n\\t %c[1;32m-----------%c[1;34mpartitions%c[1;32m------------%c[0m\u0026#34;,27,27,27,27); foreach(mem_part_start[i]) begin if(i==mem_num_parts-1) $display(\u0026#34;\\t%c[0;34m Partition : %0d with size :%0d from %0d to %0d %c[0m\\n\u0026#34; ,27,i,mem_part_size[i],mem_part_start[i]+mem_space[i-1],mem_ram_end,27); else if(i==0) $display(\u0026#34;\\t%c[0;34m Partition : %0d with size :%0d from %0d to %0d %c[1;31m \\n\\t\\tspace_part : %0d bytes \u0026#34;,27,i,mem_part_size[i],mem_part_start[i], mem_part_start[i+1]-1,27,mem_space[i]); else $display(\u0026#34;\\t%c[0;34m Partition : %0d with size :%0d from %0d to %0d %c[1;31m \\n\\t\\tspace_part : %0d bytes\u0026#34;,27,i,mem_part_size[i], mem_part_start[i]+mem_space[i-1],mem_part_start[i+1]-1,27,mem_space[i]); end endfunction endclass module memory_partition_with_spaces(); memory_block memb=new(); initial begin memb.mem_ram_start=32\u0026#39;h0; memb.mem_ram_end=32\u0026#39;h23ff; void\u0026#39;(memb.randomize()with{mem_num_parts==5;}); void\u0026#39;(memb.display()); end endmodule In the above example, memory is 9KB, we have taken 5 memory parts as inline constraints and space partition between every two parts, which means the total will be 9 parts. Here we are taking those all parts sum should be equal to 9215. The starting addresses of the memory partition are stored in one array and assigned different sizes using inside constraints and the same with the parts of the space also. The final memory block looks like the following diagram. If any of the constraints is not satisfying then there will be no randomization done and every value will be having default value i.e., 0\noutput:\nFig.35. Output of the Memory partitions with spaces in between **Github lab code link: ** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_memory_examples/memory_partition_with_spaces/memory_partition_with_spaces.sv Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_memory_examples/memory_partition_with_spaces/memory_partition_with_spaces_log.log Partitions for program and data# In the following example, memory is made into n partitions of program and data and spaces in between\nExample:\nclass memory_block; int total_mem; rand int pgm[],data[],space[]; rand int max_pgms,max_pgm_size,max_data_size; rand int num_pgm,num_data,num_space; constraint nums {num_pgm inside {[1:max_pgms]}; num_data inside {[1:10]}; num_space inside {[1:10]};} constraint maxs {max_pgms==10; max_pgm_size==512; max_data_size==128;} constraint arrays {pgm.size()==num_pgm; data.size()==num_data; space.size()==num_space;} constraint ram {foreach(pgm[i]) { pgm[i] dist {[128:512]:=75,[32:64]:/20}; pgm[i]%4 ==0; } foreach(data[i]) { data[i] inside {64}; } foreach(space[i]) { space[i] inside {64,128,512}; } total_mem == pgm.sum()+data.sum()+space.sum(); } function void display(); $display(\u0026#34;\\tTotal_RAM : %0d \u0026#34;,total_mem); $display(\u0026#34;\\tNo.of Programs : %0d \u0026#34;,num_pgm); $display(\u0026#34;\\tNo.of data\u0026#39;s : %0d \u0026#34;,num_data); $display(\u0026#34;\\tNo.of space\u0026#39;s : %0d \u0026#34;,num_space); $display(\u0026#34;\\tTotal_program_size : %0d , Total_data_size :\\ %0d Total_space_size : %0d \\n\u0026#34;,pgm.sum(),data.sum(),space.sum()); foreach(pgm[i]) $display(\u0026#34;\\t %c[1;32m Program_%0d is of %0d bytes %c[0m\u0026#34;,27,i,pgm[i],27); foreach(data[i]) $display(\u0026#34;\\t %c[1;33m data_%0d is of %0d bytes %c[0m\u0026#34;,27,i,data[i],27); foreach(space[i]) $display(\u0026#34;\\t %c[1;34m space_%0d is of %0d bytes %c[0m\u0026#34;,27,i,space[i],27); endfunction endclass module memory_pgm_data(); memory_block mb; initial begin mb =new(); mb.total_mem=6144; void\u0026#39;(mb.randomize()); mb.display(); end endmodule In this, we have used constraints such that the total programs, data, and space of all sizes should be equal to the size of the memory block of 6KB.here we gave the constraints to choose the number of program blocks, data blocks, and space blocks. here it came as 10 programs, 2 data blocks, and 5 space blocks. And also the program, space, and data sizes are assigned using foreach and inside constraints.If any of the constraints fails then the whole randomization will be stopped.\noutput:\nFig.36. Output of the Partitions for program and data **Github lab code link: ** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_memory_examples/memory_program_data/memory_pgm_data.sv Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_memory_examples/memory_program_data/memory_pgm_data_log.log # "},{
      "id": "31",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/15.classes-and-oops/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / 类和面向对象",
      "title": "类和面向对象",
      "content":"Class# Class is user define data type. Classes contains a set of \u0026ldquo;properties\u0026rdquo; and \u0026ldquo;methods\u0026rdquo; in it. Both properties and methods are treated as Members of the class.\ngenerally,\nClass Properties are the variables inside a class and Class Methods are the Functions/Tasks inside a class.\nClass declaration does not occupy any memory. we can define a class in systemverilog inside a module or outside of a module. Fig-1: All variations of a class. Class declaration syntax:\nclass class_name; // declare class properties // define class method (task and function) endclass Example:\nclass home; bit light; int fan ; string switch; task open_electricity(); switch = \u0026#34;ON\u0026#34; $display(\u0026#34;switch is %s so electricity is open\u0026#34;,switch); endtask endclass In the above example class home contains light, fan, switch as properties of the class and open_electricity is a method of the class.\nCheat sheet for classes:# classes and oops Description 1.Class A class is a user-defined data type that includes data (class properties), functions and tasks that operate on data 2.Class handle An object handle is nothing but a pointer for an object. 3.Class constructor A constructor simply a method to create a new object of particular class datatype 4.Class object Class properties and methods can be accessed only after creating the object 5.This keyword the thiskeyword used to refer properties or methods of current instance 6.Super keyword the super keyword is used from within the child-class to refer to properties and methods of parent-class 7.Extern keyword An extern keyword is used for methods which provides a facility for class methods to define them outside of the class body 8.Constant class properties To make class properties read-only, a const specifier is used 9.Copying objects Copying the objects according to the memory locations 10.Parameterized classes parameters are like constants that are local 11.Virtual methods Virtual method functionality is set at run‐time, which allows extended class handles to be assigned to base class handles 12.Static properties and methods class members with the keyword static are called as static class members 13.Over riding class members Defining the class properties and methods with the same name as parent class in the child class will override the class members. 14.Inheritance Inheritance is an OOP concept that allows the user to create classes that are built upon existing classes 15.Polymorphism The ability for the same code to behave differently depending on the kind of Object with which it is dealing 16.Encapsulation The technique of hiding the data within the class and making it available only through the methods 17.Abstraction class declared with the keyword virtual is referred to as an abstract class Class Instance (or) Class handle# A handle is an indirect reference to a class object, like a pointer to an address in memory.\nsyntax:\nclass_name class_handle;\nIn the below code home is a class and h1 is the handle of that class. It can hold the handle to an object of class home, but until assigned with class constructor (i.e, new function) it is always null. At this point, the class object does not exist yet.\ncode snippet:\nclass home; //define class //declare class properties bit light; int fan ; string switch; //define class method(task/function) task open_electricity(); switch = \u0026#34;ON\u0026#34;; $display(\u0026#34;switch is %s so electricity is open\u0026#34;,switch); endtask:open_electricity endclass:home module tb; home h1; initial begin:BEGIN_I $display(\u0026#34;Let\u0026#39;s declare handle\u0026#34;); $display(\u0026#34;Check wheather the object is created or not\u0026#34;); if (h1==null) $display(\u0026#34;object is empty\u0026#34;); else $display(\u0026#34;object is not empty\u0026#34;); end:BEGIN_I endmodule:tb output:\nIn above code we create a handle h1 for class home and check it is null or not. In the below Fig-2 we can see that it display object is empty. so, we can say that object was not created. Fig-2: output of class handle\nGithub lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/class_handle/handle.sv Github logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/class_handle/handle.log Class constructor# The \u0026ldquo;new()\u0026rdquo; function is called as class constructor. On calling \u0026ldquo;new()\u0026rdquo; function it allocates the memory and returns the address to the class handle. Constructing an object allocate the space in the memory needed to hold the properties of an object.\nsyntax:-\nclass_handle_name = new();\nclass object:-# An object is an instance of that class. An object is used by first declaring a variable of that class type (that holds an object handle) and then creating an object of that class (using the new() function) and assigning it to the variable.\nIn simple way if we create an object then we assign a memory for that handle of the class.\nsyntax:-\nclass_handle_name = new();\nThe above statement will create an object and assign to handle h1. We can create a object in either 2 step or 1 step also.\nThere are 2 ways to create an object:-\n1. Two step process:\nstep - 1: home h1;\nstep - 2: h1 = new();\n2. One step process:\nstep - 1: home h1 = new();\ncode snippet:-\nclass home; //define class //declare class properties bit light; int fan ; string switch; //define class method(task/function) task open_electricity(); switch = \u0026#34;ON\u0026#34;; $display(\u0026#34;switch is %s so electricity is open\u0026#34;,switch); endtask:open_electricity endclass:home module tb; home h1; //creating handle initial begin:BEGIN_I $display(\u0026#34;Using new() method we can create an object\u0026#34;); h1=new(); if (h1==null) $display(\u0026#34;object is empty\u0026#34;); else $display(\u0026#34;object is not empty\u0026#34;); end:BEGIN_I endmodule:tb output:-\nOn below fig-3 we can see that after create an object the memory to a class handle was created so it display object is not empty.\nFig-3: output of class object Github lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/class_object/object.sv Github logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/class_object/object.log Accessing class properties and methods\nWith the help of \u0026rsquo; . \u0026rsquo; we can access class properties and method. Class properties and methods can be accessed by using object names followed by property or method name.\nsyntax:-\n\u0026lt;class_handle\u0026gt;.\u0026lt;class_properties\u0026gt; = 1;\n\u0026lt;class_handle\u0026gt;.\u0026lt;class_method\u0026gt;;\ncode snippet:-\nclass home; //define class //declare class properties bit light; int fan; string switch; //define class method(task/function) task open_electricity(); switch = \u0026#34;ON\u0026#34;; $display(\u0026#34;\\t switch is %0s so electricity is open\u0026#34;,switch); endtask:open_electricity endclass:home module check_electricity; initial begin:BEGIN_I home h1; //creating handle h1=new(); //Creating Object for the Handle h1.light=1; // access the properties h1.fan=1; $display(\u0026#34;\u0026#34;); h1.open_electricity; //access the method $display(\u0026#34;\\t light is %0d(ON) and fan is also %0d(ON)\u0026#34;,h1.light,h1.fan); $display(\u0026#34;\u0026#34;); end:BEGIN_I endmodule:check_electricity On the above code home is a class. They have properties and method. Then here create a handle h1 for class home and the create a object using new() function the access the class properties by h1.light and h1.fan and access the class method by h1.open_electricity.\noutput:-\nIn below fig-4 we see that access the properties and give the value of light = 1 and fan = 1 it print the light is 1 and fan is also 1.\nFig-4: output of class Github lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/class/class.sv Github logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/class/class.log This keyword# The \u0026ldquo;this\u0026rdquo; keyword resolves the ambiguity of a compiler when class properties and arguments passed to class methods are the same. In simple terms, \u0026ldquo;this\u0026rdquo; keyword is a used to call the value of class properties inside the class method.\nsyntax:-\nthis.class_property;\ncode snippet:-\nclass base_class; string fan =\u0026#34;OFF\u0026#34; ; string switch=\u0026#34;OFF\u0026#34;; function void open_electricity(); string fan=\u0026#34;ON\u0026#34;; string switch=\u0026#34;ON\u0026#34;; this.fan=fan; this.switch=switch; $display(\u0026#34;Inside class method :- switch is %0s that\u0026#39;s why fan is %0s\u0026#34;,switch,fan); endfunction:open_electricity endclass:base_class module check_electricity; base_class b1; initial begin:BEGIN_I b1=new(); b1.open_electricity; $display(\u0026#34;Outside class :- switch is %0s that\u0026#39;s why fan is %s\u0026#34;,b1.switch,b1.fan); end:BEGIN_I endmodule:check_electricity From above example we can see that, fan \u0026amp; switch is class properties and argument of function is same and we assign fan to fan but using this keyword it is differentiate.\noutput:-\nIn this code we mention the this keyword before the fan and switch then he print the value switch is ON and fan is also ON inside the class as well as outside the class.\nFig-5: output of this keyword Github lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/this_keyword/this.sv Github logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/this_keyword/this.log what happens if do not use the \u0026ldquo;this\u0026rdquo; keyword in the above code ?\nIf did not mention the this keyword before assigning the fan to fan or switch to switch then inside the method the it display the overwrite value of properties but outside the class it display the default or given value of properties.\ncode snippet:-\nclass base_class; string fan =\u0026#34;OFF\u0026#34; ; string switch=\u0026#34;OFF\u0026#34;; function void open_electricity(); string fan=\u0026#34;ON\u0026#34;; string switch=\u0026#34;ON\u0026#34;; fan=fan; switch=switch; $display(\u0026#34;Inside class method :- switch is %0s that\u0026#39;s why fan is %0s\u0026#34;,switch,fan); endfunction:open_electricity endclass:base_class module check_electricity; base_class b1; initial begin:BEGIN_I b1=new(); b1.open_electricity; $display(\u0026#34;Outside class :- switch is %0s that\u0026#39;s why fan is %s\u0026#34;,b1.switch,b1.fan); end:BEGIN_I endmodule:check_electricity output:-\nOn the below fig we can see that if we did not mention the this keyword then it display inside method switch is ON that\u0026rsquo;s why fan is ON but outside the class it display the switch is OFF that\u0026rsquo;s why fan is OFF.\nFig-6: output of without this keyword Github lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/without_this_keyword/without_this.sv Github logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/without_this_keyword/without_this.log super keyword# The \u0026ldquo;super\u0026rdquo; keyword is used in a child or derived class to refer to class members of parent class. If the method of the parent class is overridden in the child class, then using the \u0026ldquo;super\u0026rdquo; keyword parent class method can be accessed from the child class if both class members have the same name for class properties and methods.\nsyntax:-\nsuper.class_method;\ncode snippet:-\nclass base_class; string fan,switch; //properties of class function void display(); //method of class switch=\u0026#34;ON\u0026#34;; $display(\u0026#34;Here using super keyword we can get both display() methods\u0026#34;); $write(\u0026#34;switch is %s \u0026#34; ,switch); endfunction:display endclass:base_class class sub_class extends base_class; string fan=\u0026#34;ON\u0026#34;; function void display(); super.display; $write(\u0026#34;that\u0026#39;s why fan is %s \\n\u0026#34; ,fan); endfunction:display endclass:sub_class sub_class s1; //creating handle for class module super_example; initial begin:BEGIN_I s1 =new(); //create an object s1.display(); //access the sub_class method end:BEGIN_I endmodule:super_example output:-\nOn below fig we can see that it display the parent class method and child class method by using the child class handle so it display the switch is ON that\u0026rsquo;s why fan is also ON and it display the single line because here use the $write .\nFig-7: output of super keyword Github lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/super_keyword/super.sv Github logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/super_keyword/super.log scope resolution# We have a scope resolution operator in classes which is used to access the class properties and methods outside of the class using class name and followed by symbol :: and then the propeties and methods of a class.\nextern keyword# An \u0026ldquo;extern\u0026rdquo; keyword is used for methods which provides a facility for class methods to define them outside of the class body.\nIf the method definition is lengthy (many lines of code inside a method), the extern method provides better readability and cleaner implementation of the class.\nAn extern keyword is used for method declaration and a class name with a scope resolution operator is used for method definition.\nNote:-\nMethod definition and declaration should have the same number of argument lists, data types, and argument names. For the extern function return type should be the same if used. syntax:-\nStep - 1: method declaration - extern indicates out-of-body declaration\nextern function function_name;\nextern task task_name;\nStep - 2: method implementation outside class body using scope resolution operator\nfunction class_name::function_name;\ntask class_name::task_name;\ncode snippet:-\nclass home; string switch; string fan = \u0026#34;OFF\u0026#34;; extern function void display(); endclass:home function void home::display(); string switch=\u0026#34;OFF\u0026#34;; $display(\u0026#34;The switch is %0s that\u0026#39;s why fan is %0s\u0026#34;,fan,switch); endfunction:display module extern_example; home h; initial begin:BEGIN_I h=new(); $display(\u0026#34;Using extern keyword we are creating prototype for our function in the class\u0026#34;); $display(\u0026#34;Then we are declaring the function outside the class\u0026#34;); h.display; end:BEGIN_I endmodule:extern_example output:-\nHere class method is define the outside the class but after access it by using class handle it display the switch is OFF that\u0026rsquo;s why fan is also OFF.\nFig-8: output of extern keyword Github lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/extern_keyword/extern.sv Github logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/extern_keyword/extern.log Chaining Constructs# The function new() is called a class constructor. This constructor is used to create objects for class handle. Creating an object means we are allocating some memory to that class. Chaining constructor means when we are extending the child class from parent class then all the properties and methods from parent class will be comming into child class. you can use same methods in both parent and child class then the child class will overwrite the methods of parent class. But in the case of new() function you can use the same new() in both parent and child class but there is no point of overwriting the parent class new(). By default the simulator will call the super.new() statement inside the extended class this is only happening in new() method. code snippet:\nclass parent; int a; function new(); a = 1; endfunction extern function void display(); endclass:parent class child extends parent; int b; function new(); b = 2; endfunction extern function void display(); endclass:child function void parent::display(); $display(\u0026#34;a = %0d\u0026#34;,a); endfunction function void child::display(); super.display(); // Super is a keyword used to get the method of same name from extended class. $display(\u0026#34;b = %0d\u0026#34;,b); endfunction module basic_chain_construct(); child c; initial begin c = new; c.display(); end endmodule:basic_chain_construct output:\nHere in the above code we are trying to create 2 classes which has one new() and one display() methods in it. so we are not calling super.new() in child constructor.\nEven though we are getting both the values of a and b which we set in two different constructers. so, we can say that an internal super.new() was there inside a constructor.\nFig-9: output for chaining constructs. Github lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/classes/chaining_constructs Github logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/chaining_constructs/basic_constructs_1/chain_constructs.log Constant class properties# To make class properties read-only, a const specifier is used. Since class objects are dynamic in nature, Systemverilog provides two types of constants. They are\n1.Global constants 2.Instance constants In both we use the \u0026lsquo;const\u0026rsquo; keyword to declare the constant values.\nFig-10: Types of constant class properties 1.Global Constants# During variable declaration, an initial value is assigned, such class properties known as global constants. The value of a variable can be changed inside the class constructor even after declaration. It cannot be override the value of constant variable in any other functions or in any module.\nsyntax:-\nconst int b=2;\nCode Snippet\nclass data; string a; const int b=1;//global constant function new(); a=\u0026#34;team\u0026#34;; endfunction:new function void display(); $display(\u0026#34;a=%0d,b=%0d\u0026#34;,a,b); endfunction:display endclass:data module global_class; data p1; initial begin:BEGIN_I p1=new(); $display(\u0026#34;\u0026#34;); p1.display(); // p1.b=2;// invalid usage of b //------------------------------------------------------- //Here we assigned the b value in class properties using \u0026#39;const\u0026#39; again we //should not assign the value for \u0026#39;b\u0026#39; even though we declared the values it throws the //errors. //-------------------------------------------------------- $display(\u0026#34;\u0026#34;); end:BEGIN_I endmodule:global_class Output:-\nIn the below figure you can see that value of b is \u0026lsquo;1\u0026rsquo; only because we declared it as a constant value. Even if we want to change the value of \u0026lsquo;b\u0026rsquo; it throws errors. It won\u0026rsquo;t take the values after it declares as constant.\nFig-11: output of global constant Github lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/constant_variables/global_class/global_class.sv Github logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/constant_variables/global_class/global_class.log 2.Instance Constants# During variable declaration, an initial value is not assigned, such class properties are known as instance constants. An instance constant allows a user to assign value in run time only once in the class constructor.\nsyntax:-\nconst int b;\nfunction new();\nb=9;\nendfunction\nCode Snippet:-\nclass data; const int a; string b; function new(); a=5; b=\u0026#34;bhavana\u0026#34;; endfunction:new function void display(); $display(\u0026#34;a=%0d,b=%0d\u0026#34;,a,b); endfunction:display endclass:data module instance_class; data t1; initial begin:BEGIN_I t1=new(); //t1.a=2; //------------------------------------------------------- // Here we should not assign value for the \u0026#39;a\u0026#39; because // we declared the \u0026#39;a\u0026#39; as constant variable. // so if we assign any value to the \u0026#39;a\u0026#39; it throws errors // it won\u0026#39;t take any value eventhough we declared. //------------------------------------------------------- t1.b=\u0026#34;bjt\u0026#34;; $display(\u0026#34;\u0026#34;); t1.display(); $display(\u0026#34;\u0026#34;); end:BEGIN_I endmodule:instance_class Output:-\nIn below figure we can a value is constant because here we declared it as constant and in instance constant we can declare value only in the constructor.\nFig-12: output of Instance Constants Github lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/constant_variables/instance_class/instance_class.sv Github logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/constant_variables/instance_class/instance_class.log parameterized classes# Parameterized classes are useful when the same class needs to be instantiated differently. The default parameter can be set in the class definition. These parameters can be overridden when it is instantiated.\nThe parameter value can be used to define a set of attributes in class. default values can be overridden by passing a new set of parameters during instantiation this is called parameter overriding.\nParameterized by value# syntax:-\nclass Vector #(parameter WIDTH=1); bit [WIDTH-1:0] data; endclass Code Snippet:-\nclass mirafra #(parameter branch,employes); bit [branch-1:0]b1; bit [employes-1:0]b2; function new(); b1=13; b2=9; endfunction function void disp(); $display(\u0026#34;b1=%0d,b2=%0d\u0026#34;,b1,b2); endfunction endclass:mirafra mirafra#(3,2) m; module value; initial begin:BEGIN_I m=new(); $display(\u0026#34;\u0026#34;); $display(\u0026#34;contents of m \u0026#34;); m.disp(); $display(\u0026#34;\u0026#34;); end:BEGIN_I endmodule:value Output\nIn the below figure we can see the output of paramerized class by value where we consider int parameters branch and employess as the width of 32 bit.\nFig- 12 output of parameterized by value Github lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/parameterized_classes/parameter_value/parameter_value.sv Github logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/parameterized_classes/parameter_value/parameter_value.log Parameterized by type(datatype)# Datatype is parameterized in this case and can also be over ridden in instantiated.\nsyntax\nclass Stack #(parameter type T=int); T items[64], idx=0; function void push(input T val); function T pop(); endclass Code Snippet\nclass data #(parameter a,type team=string);//parameter declaration bit [a-1:0]d; team c; function new(); d=20; c=\u0026#34;Mirafra\u0026#34;; endfunction function void disp(); $display(\u0026#34;d=%0d,c=%0s\u0026#34;,d,c); endfunction endclass:data data#(4) p1; module test; initial begin:BEGIN_I p1=new(); $display(\u0026#34;\u0026#34;); $display(\u0026#34;contents of p1\u0026#34;); p1.disp(); $display(\u0026#34;\u0026#34;); end:BEGIN_I endmodule:test Output:-\nIn the below figure we can see that output of parameter by datatype as we considered T as the string in the paraenter.\nFig-13 output of parameterized by datatype Github lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/parameterized_classes/parameter_datatype/parameter_datatype.sv Github logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/parameterized_classes/parameter_datatype/parameter_datatype.log Copying Objects# There are 3 types of Copying Objects\n1.Class Assignment 2.Shallow copy 3.Deep copy Fig-14 type of copy method 1.Class Assignment# With the class assignment both the original and copy class will point to same memory location. Any update to a variable from either of the classes will have impact on the other class.\nsyntax\na=new();\nb=a;\nMemory Allocation of Class Assignment\nFig-15 memory allocation for class assignment In the above memory allocation we have say that p1 and p2 are sharing same memory and if we change one variable in one class(p1) it will be updated in other class(p2) also.\nCode Snippet\nclass Mirafra; string c; int d; function new(); c=\u0026#34;team\u0026#34;; d=4; endfunction:new function void display(); $display(\u0026#34;\\t c=%0s,\\t d=%0d\u0026#34;,,c,d); endfunction:display endclass:Mirafra module assignment; Mirafra p1; Mirafra p2; initial begin:BEGIN_I p1=new(); $display(\u0026#34;contents of p1 before changes\u0026#34;); p1.display(); p2=p1; $display(\u0026#34;contents of p2 before changes\u0026#34;); p2.display(); p2.c=\u0026#34;BJT\u0026#34;; p2.d=8; $display(\u0026#34;contents of p1 after changes\u0026#34;); p1.display(); $display(\u0026#34;contents of p2 after changes\u0026#34;); p2.display(); end:BEGIN_I endmodule:assignment Output\nIn the below figure we can see that class assigment operation as we know class assignment has same memory location so first we can the copied objects so if we want change the values if we chnage one value in handle that changes reflect in other handle also\nFig-16 output of class assignment Github lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/copying_methods/class_assignment/class_assignment.sv Github logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/copying_methods/class_assignment/class_assignment.log 2.Shallow Copy# When a class is shallow copied to another class, all the variables of the original class is copied to the copied class, with an exception of objects inside the class. In case the original class has a class object defined inside, that object would NOT be copied, only the handle for the object will be copied.This means the memory location of the object remain same. so if the object is updated from the copied class, this object value will be updated also for the original class.but if variable of copied class is update, it will NOT update the variable of the original class.\nsyntax a=new();\nb=new a;\nMemory Allocation for Shallow Copy\nFig-17 memory allocation for shallow copy In the above figure we can that memory allocation in p1 and p2 is same but variables change is updated only in the handle variables.\ncode snippet\nclass Mirafra; string c; int d; function new(); c = \u0026#34;Teams\u0026#34;; d = 8; endfunction:new function void display(); $display(\u0026#34;\\t c=%0s,\\t d=%0d\u0026#34;,c,d); endfunction:display endclass:Mirafra module shallow; Mirafra p1; Mirafra p2; initial begin:BEGIN_I p1 =new(); $display(\u0026#34;contents of p1\u0026#34;); p1.display(); p2 =new p1; $display(\u0026#34;contents of p2\u0026#34;); p2.display(); p2.c=\u0026#34;place\u0026#34;; $display(\u0026#34;diplay contents of p1\u0026#34;); p1.display(); $display(\u0026#34;diplay contents of p2\u0026#34;); p2.display(); end:BEGIN_I endmodule:shallow Output:-\nIn the below figure we can see the shallow copy as we know it has same memory location but share the memory by splitting and first valkues are copied if we want changes the values then only is updated as we see here a and b is updated but c is updated in particular handle.\nFig-18 output of shallow copy Github lab link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/copying_methods/shallow_copy/shallow_copy.sv\nGithub logfile link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/copying_methods/shallow_copy/shallow_copy.log\n3.Deep Copy# SystemVerilog deep copy copies all the class members and its nested class members. That means it will copy all the members to a different memory location including the object inside the class. Any change in members of one of the class will have NO impact on another class member.\nsyntax\na=new();\nb=new();\nb.copy(a);\nMemory Allocation of Deep Copy\nFig-19 memory allocation for deep copy In the above figure we can see p1 and p2 has different memories so if change or update any varibale only that class is updated because of different memory locations.\nCode snippet\nclass branches; string c; int d; function new(); c=\u0026#34;Banglore\u0026#34;; d=1; endfunction:new function void disp(); $display(\u0026#34;\\t c=%0d,\\t d=%0d\u0026#34;,c,d); endfunction:disp function void deep(branches copy);//copy this.c=copy.c; this.d=copy.d; endfunction:deep endclass:branches module deep; branches p1; branches p2; initial begin:BEGIN_I p1=new(); p2=new(); p2.deep(p1);//deep copy $display(\u0026#34;\u0026#34;); $display(\u0026#34;contents of branch p1 before changes\u0026#34;); p1.disp(); $display(\u0026#34;contents of branch p2 before changes\u0026#34;); p2.disp(); p1.c=\u0026#34;Manipal\u0026#34;; p2.c=\u0026#34;Hyderabad\u0026#34;; $display(\u0026#34;contents of branches p1 after changes\u0026#34;); p1.disp(); $display(\u0026#34;contents of branches p2 after changes\u0026#34;); p2.disp(); $display(\u0026#34;\u0026#34;); end:BEGIN_I endmodule:deep Output:-\nIn the below figure we can se that it has different memory locations but we can copy the values using copymethod and if want change the values the value updation also occurs in the particular handle which we considered.\nFig- 20 output of deep copy Github lab link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/copying_methods/deep_copy/deep_copy.sv\nGithub logfile link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/copying_methods/deep_copy/deep_copy.log\nVirtual Methods# SystemVerilog Methods declared with the keyword virtual are referred to as virtual methods.\nFig-21 type of virtual class member Virtual Methods are two types 1.Virtual Functions 2.Virtual Tasks Virtual Function# A function declared with a virtual keyword before the function keyword is referred to as virtual Function, we use the virtual in base(parent)class function then only child class gets executed.\nCode Snippet\nclass packet; string a; int b; function new(); a=\u0026#34;Team\u0026#34;; b=4; endfunction:new virtual function void display(); $display(\u0026#34;a=%0d\u0026#34;,a); $display(\u0026#34;b=%0d\u0026#34;,b); endfunction:display endclass:packet class pack extends packet; string c; int d; function new(); c=\u0026#34;BJT\u0026#34;; d=8; endfunction:new function void display(); // super.display(); $display(\u0026#34;c = %0d\u0026#34;,c); $display(\u0026#34;d = %0d\u0026#34;,d); endfunction:display endclass:pack class pack1 extends packet; string e; function new(); e=\u0026#34;Manipal\u0026#34;; endfunction:new function void display(); $display(\u0026#34;e = %0d\u0026#34;,e); endfunction:display endclass:pack1 packet pp0,pp1; pack p2; pack1 p3; module virt_fun; initial begin:BEGIN_I p2=new(); p3=new(); pp0=p2; pp1=new p3; pp0.display(); pp1.display(); end:BEGIN_I endmodule:virt_fun Output:-\nIn the below figure we can see the contents of child class 1 and 2 as we declared parent class function as virtual function so it give the values of child classes.\nFig-22 output of virtual function Github lab link: classes/virtual_methods/virtual_function Github logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/virtual_methods/virtual_function.log Virtual Task# Task declared with a virtual keyword before the task keyword is referred to as virtual task\ncode snippet\nclass packet; string a; int b; virtual task display(); a=\u0026#34;Team\u0026#34;; b=4; $display(\u0026#34;a=%0s\u0026#34;,a); $display(\u0026#34;b=%0d\u0026#34;,b); endtask endclass//class 1 //-----class 2------- class pack extends packet; string c; int d; task display(); c=\u0026#34;BJT\u0026#34;; d=8; $display(\u0026#34;c=%0s\u0026#34;,c); $display(\u0026#34;d=%0d\u0026#34;,d); endtask endclass//class 2 packet p1; pack p2; module virtual_task; initial begin:BEGIN_I p2=new(); p1=p2; $display(\u0026#34;contents of pp0\u0026#34;); p1.display(); end:BEGIN_I endmodule:virtual_task Output\nIn the below figure we ca see that contents of child class as we declared the parent class methods as the virtual task it gives the child class contents.\nGithub lab link :https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/virtual_methods/virtual_task/virtual_task.sv\nGithub logfile link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/virtual_methods/virtual_task/virtual_task.log\nOver-riding Class Members# Base class or parent class properties and methods can be overridden in the child class or extended class by defining the class properties and methods with the same name as parent class in the child class will override the class members.\nTo override a method means that given a base class with a method, we can define a subclass which extends from that base class and then provide a new definition for the given method. By default, the subclass inherits the base class implementation of the method but should the programmer decide to change that definition by overriding it - simply listing a new version of that method, then the new version of the method will be used instead of the parent\u0026rsquo;s.\nCode Snippet\n//parentclass class Mirafra; string place; int members; int teams; function new(); place=\u0026#34;manipal\u0026#34;; members=13; endfunction:new function void display(); $display(\u0026#34;place = %0d,\\t members= %0d\u0026#34;,place,members); endfunction:display endclass:Mirafra //child-1 class Teams extends Mirafra; string Teams; int members; function new(); Teams=\u0026#34;mirafra-teams\u0026#34;; members=25; endfunction:new function void display(); $display(\u0026#34;Teams=%0d,\\t mem=%0d\u0026#34;,Teams,members); endfunction:display endclass:Teams //child-2 class bjt extends Mirafra; string Team; int members; string place; function new(); Team =\u0026#34;Team3\u0026#34;; members=4; endfunction:new function void display(); $display(\u0026#34;Team=%0s,\\t members=%0d,\\t place=%0s\u0026#34;,Team,members,place); endfunction:display endclass:bjt module over_riding; bjt c; initial begin:BEGIN_I c=new(); $display(\u0026#34;contents before over-riding\u0026#34;); c.display(); c.place = \u0026#34;mirafra\u0026#34;; c.Team=\u0026#34;BJT\u0026#34;;//over-riding parent-class members c.members = 8; c.place=\u0026#34;Manipal\u0026#34;; $display(\u0026#34;contents after over-riding\u0026#34;); c.display(); end:BEGIN_I endmodule:over_riding Output:-\nIn the below figure we can the class over_riding members,here we are just accessing the parent class using the child class handle but parents and child should have same class peroperties here if we see we can place which in the parent class.\nFig-23 output of overriding class member Github lab link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/class_over_riding/over_riding_class.sv\nGithub logfile link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/class_over_riding/over_riding_class.log\nStatic Properties and Methods# Class members can be created with the keyword static. class members with the keyword static are called as static class members. the class can have static properties and static methods (functions and tasks). a single copy of static variables is shared across multiple instances.\nFig-24 static class member Static Properties# The static variable declared inside a class with static keyword shares a single memory location across all class instances.\nsyntax\nstatic \u0026lt;data_type\u0026gt; \u0026lt;variable_name\u0026gt;\nCode Snippet\nclass Mirafra; byte teams; //declare the static property static byte BJT; function new(); //incrementing the BJT BJT++; //Assigning static byte to byte teams=BJT; endfunction:new function void disp(); $display(\u0026#34;teams=%0d\u0026#34;,teams); endfunction:disp endclass:Mirafra module static_properties; Mirafra m[4];//declared array of m here initial begin:BEGIN_I foreach(m[i]) begin:BEGIN_LOOP m[i] = new(); $display(\u0026#34;contents of teams\u0026#34;); m[i].disp(); end:BEGIN_LOOP end:BEGIN_I endmodule:static_properties Output\nIn the below figure we see that when for loop is operation is done the value of contenyts of teams is updated because here we considered BJT as the static property and we assigned that BJT to team so team value is updated.\nFig-25 output of static properties Github lab link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/static/static_properties/static_properties.sv\nGithub logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/static/static_properties/static_properties.log Static Methods# Static methods are the same as static variables that also follow class access rules and scope.\nStatic functions and tasks can not be virtual They can access only static properties (static members) of a class. Accessing non-static members leads to compilation errors as it is illegal to use. But non-static functions or tasks can access static variables. Both static methods and static members in a class can be accessed without creating an object.\nsyntax\nstatic function \u0026lt;method_name\u0026gt;\nCode Snippet\nclass Mirafra; static int team ; function new(); //incrementing team team ++; endfunction:new //declaring static method static function void disp(); $display(\u0026#34;\\t team=%0d\u0026#34;,team); endfunction:disp endclass:Mirafra module static_method; Mirafra m[3];//declaring array initial begin:BEGIN_I $display(\u0026#34;\u0026#34;); foreach(m[i])begin:BEGIN_LOOP m[i]=new; end:BEGIN_LOOP $display(\u0026#34;\\t contents of team\u0026#34;); m[2].disp(); $display(\u0026#34;\u0026#34;); end:BEGIN_I endmodule:static_method Output In the below figure we see the static methods as we declared function as static function and in this static function only the static properties are accessible so as the for loop iteration is done the value gets updated each time so here we can see the teams is \u0026lsquo;3\u0026rsquo;.\nFig-26 output of static method Github Lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/static/static_methods/static_method.sv Github Logfile Link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/static/static_methods/static_method.log Inheritance# Inheritance is a mechanism which allows child class to inherit the properties of base-class. Objects of child class will have access to attributes and methods of parent class. If child class inherits parent class, then parent class is called super-class and child class is called subclass.\nFig-27 Inheritance memory diagram Inheritance is done by keyword \u0026rsquo;extends\u0026rsquo; which allows access to all class members of parent class.\nFig-28 Functionality of extends keyword From the above fig-2, we can clearly see that all the instantiation steps are reduced down to one single keyword \u0026rsquo;extends\u0026rsquo; which allows to have all the class members of parent to the child.\ncode snippet:-\nclass A; int a = 5; function void disp(); $display(\u0026#34;1.Value of a = %0d\u0026#34;,a); endfunction:disp endclass:A class B extends A; int a = 6; function void display(); $display(\u0026#34;2.Value of a = %0d\u0026#34;,a); endfunction:display endclass:B module inh_sam(); B b1; initial begin b1 = new; b1.a = 10; b1.disp(); b1.display(); end endmodule:inh_sam Output:-\nIn the code we can see that initially in the class A(parent) we have initialized the value of \u0026lsquo;a\u0026rsquo; with 5 and in class B(child) we are intializing the value of 6 to \u0026lsquo;a\u0026rsquo;. In the module we are creating handle \u0026lsquo;b1\u0026rsquo;only for the child class B and we are intialising it with value 10. When we access the parent class method with the help of the child class handle it will display a = 5 and when we access the child class method with the help of the child class handle it will overwrite the value of a=6 with a=10 and displays the output. So we are able to access both the methods just by child class B handle.\nFig-29 output of inheritance Github lab link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/inheritance/inh.sv\nGithub logfile link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/inheritance/inh_op.log\nPolymorphism# Polymorphism allows to access the sub-class methods using super-class objects. Any subclass object can be assigned to super-class object. In polymorphism, same handle (or) methods take different forms. It is important to know that all the method names should be same for both parent and child class, also if we don\u0026rsquo;t use virtual for methods in parent class then it will only access parent class methods.\ncode snippet:-\nclass parent; int a; int b; virtual function void display(); a = 1; b = 2; $display(\u0026#34;This is parent class\u0026#34;); $display(\u0026#34;a = %0d, b= %0d\u0026#34;,a,b); endfunction:display endclass:parent class child1 extends parent; int c,d,e; function void display(); a = 3; b = 4; e = a+b; $display(\u0026#34;This is child class\u0026#34;); $display(\u0026#34;a = %0d, b = %0d,e = %0d\u0026#34;,a,b,e); endfunction:display endclass:child1 class child2 extends parent; int f; function void display(); f= a*b; $display(\u0026#34;f = %0d\u0026#34;,f); endfunction:display endclass:child2 module poly_ex(); parent p1[1:0]; child1 c; child2 c2; initial begin c = new(); p1[0] = c; p1[1] = new(); p1[0].display(); p1[1].display(); end endmodule:poly_ex Output:-\nIn this code we can see that the methods of both parent class and child classes are same. So the child class methods will overwrite parent class methods. So we are assigning the child handle \u0026lsquo;c\u0026rsquo; is assigned to parent handle p[0]. So with the help of the p[0] handle we are able to access the child class method. Since it is display function it will print a=3,b=4,e=7. But when we are accessing the class method with the help of handle p[1] it will display the parent class method, that is a =1,b=2 because we did not assign child class handle c to parent class handle p[1]. So here the parent class handle is taking many forms to access child class methods which indeed called poly which is many forms in the polymorphism.\nFig-30 output of polymorphism Github lab link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/polymorphism/poly.sv Github logfile linkhttps://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/polymorphism/poly_op.log Abstract/Virtual class# Abstract class is a virtual class which cannot be instantiated directly in the program(in other words an object of a virtual/abstract class cannot be created). If you try doing so it will throw compile time error. They will be used as a base class to inherit any no of classes. We generally use abstract class to define a prototype in advance, that means an abstract class provides a template for a set of derived classes. So you know you have a basic set of methods/properties that already exist, that makes it simpler for you to focus on the new intent for which you are creating this derived class.\ncode snippet:-\nvirtual class A; int a = 5; function void disp(); $display(\u0026#34;1.Value of a = %0d\u0026#34;,a); endfunction:disp endclass:A class B extends A; int a = 6; function void display(); $display(\u0026#34;2.Value of a = %0d\u0026#34;,a); endfunction:display endclass:B module abstract_ex(); B b1; initial begin b1 = new; b1.a = 10; b1.disp(); b1.display(); end endmodule:abstract_ex Output:-\nIn the code we can see that initially in the class A(parent) we have initialized the value of \u0026lsquo;a\u0026rsquo; with 5 and in class B(child) we are intializing the value of 6 to \u0026lsquo;a\u0026rsquo;. In the module we are creating handle \u0026lsquo;b1\u0026rsquo;only for the child class B and we are intialising it with value 10. When we access the parent class method with the help of the child class handle it will display a = 5 and when we access the child class method with the help of the child class handle it will overwrite the value of a=6 with a=10 and displays the output. So we are able to access both the methods just by child class B handle\nFig-31 output of abstract Github lab link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/abstraction/abstract_class/abstract.sv\nGithub logfie link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/abstraction/abstract_class/abstract_op.log\nPure virtual method# A virtual method inside an abstract class can be declared by keyword \u0026lsquo;pure\u0026rsquo; and is called pure virtual method. The class will automatically consider it as abstract class if any pure virtual method is used. It should be only added in the base class. In the base class we are not allowed to add any function definition to the pure virtual function. It is important to know that all the derived classes of a base class with pure virtual methods should have implementation of all pure virtual methods individually.\ncode snippet:-\nvirtual class A; int a,b,c; pure virtual function void disp(); pure virtual task sum(); endclass:A class B extends A; virtual function void disp(); a =10; $display(\u0026#34;1.Value of a = %0d, b = %0d, c = %0d\u0026#34;,a,b,c); endfunction:disp virtual task sum(); c = a+b; $display(\u0026#34;2.Value of a = %0d, b = %0d, c = %0d\u0026#34;,a,b,c); endtask:sum endclass:B module pure_vir_fun_ex(); B b1; initial begin b1 = new; b1.disp(); b1.b = 35; b1.sum; end endmodule:pure_vir_fun_ex Output:- In the code we can see that initially in a virtual class we will be declaring two methods function void disp and task sum which we are supposed to be used in our code without defining it. When we inherit class A to B it is important that both the methods(function void disp and task sum) are supposed to be used in the child class B. In the similar fashion if there are more child classes each class is supposed to have both the methods declared individually or else it will throw an error. So in class B we are assiging value of a=10, but since we are not declaring the values of b=0,c=0. In task method we are adding both the values of a and b but we are passing the value of b =35, so we will get a = 10,b=35,c=45.\nFig-32 output of pure virtual class Github lab link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/abstraction/pure_virtual_function/pvf.sv\nGithub logfile link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/abstraction/pure_virtual_function/pvf_op.log\nEncapsulation# Encapsulation is the technique of hiding data within the class and making it available only through the methods. It seals the data and allows only access to trusted users(i.e., by the methods of the class).\nNote:- It can be applicable for methods as well.\nFig- 33 Type of encapsulation Local# A member declared as \u0026rsquo;local\u0026rsquo; is accessible only to the methods of the same class and will not be able to access by child class.\ncode snippet:-\nclass parent; bit [3:0] a,b; local bit[5:0] c; local int d = 5; function int sum(bit[4:0]val1,val2); c = val1 + val2; return c; endfunction:sum function void display(); $display(\u0026#34;sum = %0d\u0026#34;,c); $display(\u0026#34;d = %0d\u0026#34;,d); endfunction:display endclass:parent module encap(); parent p; int e; initial begin p = new(); e = p.sum(1010,101); p.display(); end endmodule:encap Output:-\nIn the code we can see that the local variable c,d declared inside the class is being accessed inside the class. As it is allowed, no compilation error is observed.\nFig-34 output of local encapsulation Github lab link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/encapsulation/local/local.sv\nGithub logfile link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/encapsulation/local/encap_op.log\nErrors expected if we access local variable by child class# code snippet:-\nclass parent; bit [3:0] a,b; local bit[5:0] c; local int d = 5; function int sum(bit[4:0]val1,val2); c = val1 + val2; return c; endfunction:sum function void display(); $display(\u0026#34;sum = %0d\u0026#34;,c); $display(\u0026#34;d = %0d\u0026#34;,d); endfunction:display endclass:parent class child extends parent; function void disp(); display(\u0026#34;d = %0d\u0026#34;,d); endfunction endclass:child module encap(); parent p; child c1; int e; initial begin p = new(); c1 = new(); e = p.sum(1010,0101); p.display(); p.c = 5\u0026#39;b10; p.display(); c1.disp(); end endmodule:encap Output:-\nIn the code we can see that the local variable c,d declared inside the class is trying to access from outside the class by using object handle of child class as well as parent handle p in module block. As the variable is declared as local, which leads to a compilation error.\nFig-35 showing error Protected# Sometimes there will be necessity to access the members of parent class by the child class. This can be done by the keyword \u0026lsquo;protected\u0026rsquo;. By using protected, all the child classes will get the access to the base class members which were data protected.\ncode snippet:-\nclass parent; bit [3:0] a,b; protected bit[5:0] c; protected int d = 5; function int sum(bit[4:0]val1,val2); c = val1 + val2; return c; endfunction:sum function void display(); $display(\u0026#34;sum = %0d\u0026#34;,c); $display(\u0026#34;1.d = %0d\u0026#34;,d); endfunction:display endclass:parent class child extends parent; function void disp(); $display(\u0026#34;2.d = %0d\u0026#34;,d); endfunction endclass:child module prot(); parent p; child c1; int e; initial begin p = new(); c1 = new(); e = p.sum(1010,0101); p.display(); // p.d = 10; //Cannot access local/protected member \u0026#34;p.d\u0026#34; c1.disp(); end endmodule:prot Output:-\nIn the code we can see that the protected variable c,d declared inside the class is being accessed inside the class. But here since it is protected inheritance is also allowed as when we try accessing in child class it will not throw an error. But we try accessing the values c,d in module block it will throw an error.\nFig-36 output of protected encapsulation Github lab link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/encapsulation/protected/prot.sv\nGithub logfile link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/encapsulation/protected/prot_op.log\nPublic# By default if we does not define any attributes with keywords \u0026rsquo;local\u0026rsquo; and \u0026lsquo;protected\u0026rsquo;, then by default it is \u0026lsquo;public\u0026rsquo;. It provides full access to all attributes and methods to child classes.\ncode snippet:-\nclass parent; bit [3:0] a,b; bit[5:0] c; int d = 5; function int sum(bit[4:0]val1,val2); c = val1 + val2; return c; endfunction:sum function void display(); $display(\u0026#34;sum = %0d\u0026#34;,c); $display(\u0026#34;1.d = %0d\u0026#34;,d); endfunction:display endclass:parent class child extends parent; function void disp(); $display(\u0026#34;2.d = %0d\u0026#34;,d); endfunction endclass:child module pub(); parent p; child c1; int e; initial begin p = new(); c1 = new(); e = p.sum(1010,0101); p.display(); c1.d = 10; c1.disp(); end endmodule:pub Output:- In the code we can see that the variable c,d declared inside the class which is by default public is being accessed inside the class.Here inheritance is also allowed as when we try accessing in child class it will not throw an error. When we try accessing the values c,d in module block it will not throw an error since it will have full access to all the attributes.\nFig-37 output of public encapsulation Github lab link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/encapsulation/public/pub.sv\nGithub logfile link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/classes/encapsulation/public/pub_op.log\n"},{
      "id": "32",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/17.functional-coverage/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / Coverage",
      "title": "Coverage",
      "content":"Coverage# Coverage is a generic term for measuring progress to complete design verification. Coverage reports are read in percentage(%).\nNeed for coverage\nTo help us to understand whether all features of the design are measured and to know whether every line in the code is executed or not.\nTypes of coverage\nCode Coverage Functional Coverage Code Coverage# Code coverage deals with the implementation part that is, it checks whether your tests exercised the “implementation” of the design specification, but it won’t check the verification plan. It will measure the quality of the test case\nLine Coverage: Checks how many lines have been executed. Path Coverage: Checks in which path the code has been executed. Toggle Coverage: Checks which single-bit variable has/had the values 0 or 1. FSM Coverage: Checks which state and transitions in a state machine have been visited. Limitation of Code coverage It depends on the design code so it can measure coverage for the code which has been written but cannot say anything about the software that has not been written.\nFunctional Coverage# Functional coverage defines how much of the design specification has been exercised in verification or Functional coverage measures the progress of all tests in fulfilling the verification plan requirements. It measures the quality of DV.\nLimitation of Functional Coverage\nIf there are 15 features in the design and we mentioned only 10 features of them, it will conclude that all the features are covered. So make sure to include all design features is included in the functional coverage block.\nNeed\nFunctional coverage is needed to track whether all the DUT features have been verified and measure the quality of verification. Functional coverage helps us to target the DUT features that are unverified.\nDifference between Functional Coverage and Code Coverage\nSl.No. Functional Coverage Code Coverage 1. Checks how well the stimulus is covering various functionality Checks how well code is tested by stimulus 2. If any block of code is missing in the design, functional coverage can identify that mistake If any block of code is missing in the design, code coverage cannot identify that mistake 3. Depends on design specification Depends on design code Coverage comparison# When functional coverage and code coverage are low\nIt is the start of the project When functional coverage is high and code coverage is low\nCode needs more cover points/cases Dead code It is possible that the test plan is missing some features to cover When functional coverage is low and code coverage is high\nPoor quality of stimulus(try different seeds) When functional coverage and code coverage are high\nEnd of the design and check for the bug rate Covergroup and coverpoints# In the System Verilog, the cover group is a user-defined type, that encapsulates the specifications of the coverage model. It must be instantiated for it to collect data. This is similar to a class, they can be defined once and instantiated multiple times at different places using the new function.\nWe generally use the sample function to trigger the coverage group explicitly. If we don\u0026rsquo;t sample this cover group then functional coverage will term it as zero functions covered.\nEach cover group specification can include,\nA clocking event that synchronizes the sampling of coverage points.\nA set of coverage points.\nCross coverage between coverage points.\nOptional formal arguments.\nCoverage option.\nSyntax:-\ncovergroup covergroup_name ; ..... endgroup Example: The below example shows the declaration and execution of the cover group.\ncovergroup cgrp; c1: coverpoint a; c2: coverpoint b; endgroup cgrp cg =new(); initial begin repeat (5)begin a=$random(); b=$random(); cg.sample(); $display(\u0026#34;a=%d ; b=%d ; coverage = %.2f\u0026#34;,a,b,cg.get_inst_coverage()); A cover group is defined with name cgrp and it is instansiated with name \u0026lsquo;cg\u0026rsquo;. c1 and c2 are the labels given to the cover points, and a and b are the variables declared. Using its handle_name(cg) an object is created using the new function. a and b variables are randomized to have different values for 5 iterations and during this randomization, the cover group is triggered using the sample function, and functional coverage is displayed using the handle.get_inst_coverage() function.\nOutput Snap The below figure shows the output of a simple coverage group.\nFigure.1. output of the Simple coverage group During the first iteration a=0 and b=1, at this iteration cover points c1 and c2 coverages are calculated separately. The average of c1 and c2 is the instance coverage percentage. Here a and b can have four values that are from 0-3, out of 4 values only value 0 is assigned for \u0026lsquo;a\u0026rsquo; variable , therefore the percentage is (1/4)*100 = 25%. Similarly, for b variable value 1 is assigned, so the coverage percentage is (1/4)*100 = 25%. Now, the average of c1 and c2 is (25+25)/2 = 25%.\nDuring the second iteration: a=1 and b=3 ; at this point two values out of four are assigned to variable \u0026lsquo;a\u0026rsquo; hence the coverage percentage is (2/4)*100 = 50%. Similarly for \u0026lsquo;b\u0026rsquo; variable coverage percentage is 50%. Now the average of cover points c1 and c2 are (50+50)/2 = 50%.\nDuring the third iteration: a=1 and b=1, at this point \u0026lsquo;a\u0026rsquo; value is repeating with value 1. But this value 1 is already covered in the execution during the 2nd iteration hence \u0026lsquo;a\u0026rsquo; has covered only 2 values out of 4, hence its coverage is (2/4)*100 = 50%. Similarly for variable \u0026lsquo;b\u0026rsquo;, value 1 is covered during 1st iteration, so 2 values are assigned out of 4, hence coverage is (2/4)*100 = 50%. Now average of c1 and c2 is (50+50)/2 = 50%.\nDuring the fourth iteration a=1 and b=2; at this point variable \u0026lsquo;a\u0026rsquo; has covered 2 values but variable \u0026lsquo;b\u0026rsquo; has covered 3 values out of 4. Hence, coverage for c1 = 50% and c2 = 75%. Now average of c1 and c2 is (50+75)/2 = 62.50% .\nDuring the fifth iteration a=1 and b=1; \u0026lsquo;a\u0026rsquo; has covered 2 values and \u0026lsquo;b\u0026rsquo; has covered 3 values out of 4. Hence, coverage for c1 = 50% and c2 = 75%. Now average of c1 and c2 is (50+75)/2 = 62.50% .\nCoverage report\nFigure.1. Coverage Report of simple coverage group. NOTE: To have a higher coverage percentage, increase the number of iterations, so the probability of covering all the functions is more.\nGitHub lab file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/covergroup/covergrp_declaration/cover_grp/cover_grp.sv GitHub log file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/covergroup/covergrp_declaration/cover_grp/cover_group.log Coverpoints# A covergroup can contain one or more coverpoints. Coverpoints specify only integral value or integral expression. The coverpoint can be evaluated when the covergroup is sampled. It can be optionally labeled with a semicolon \u0026lsquo;:\u0026rsquo;. If the coverpoint is labeled then the system Verilog gives the name of the coverpoint. Each coverpoint will have bins. Bins are automatically created by the simulator or explicitly defined.\nsyntax:\n// without label name // covergroup covergroup_name; coverpoint variable_name; endgroup // with label name// covergroup covergroup_name; label_name: coverpoint variable _name; endgroup Cheat Sheet for Covergroup Declaration\nSL.NO Covergroup Declration 1. Covergroup defined inside a module 2. Covergroup defined inside a class 3. Covergroup defined outside class and module 1. Covergroup defined inside a module# When we define a cover group inside a module it is easy to access data values and there is no mandatory for instantiation and handle creation. Instead, we can directly use the covergroup_name to execute the respective coverpoints. In order to use cover group we need to create an object using the new function.\nSyntax: module tb; datatype var; covergroup covergroup_name; label : coverpoint var; endgroup initial begin covergroup_name = new(); endclass Example: module cvgrp_inside_mod; covergroup cvgrp ; c1: coverpoint p.a; c2: coverpoint p.b ; endgroup cvgrp cg; initial begin cg=new; repeat (5) begin void\u0026#39;(p.randomize); cg.sample(); $display (\u0026#34;a=%d ; b=%d ; coverage =%.2f\u0026#34;,p.a,p.b,cg.get_inst_coverage()); Here a cover group is defined inside the module whereas the variable is declared inside the class. c1 and c2 are the labels given to the cover points, p.a and p.b are the variables declared in class. A handle is created for covergroup with a user-defined name \u0026lsquo;cg\u0026rsquo;. Using handle name an object is created using the new function. \u0026lsquo;a\u0026rsquo; and \u0026lsquo;b\u0026rsquo; variables are randomized using class_handle.randomize function during this randomization, the cover group is triggered using the sample function, and functional coverage is displayed using the group_handle.get_inst_coverage() function.\nOutput Snap Figure.2. Output of Covergroup defined inside a module Here variable a can have 4 values that are [0-3] and variable \u0026lsquo;b\u0026rsquo; can have 8 values that are [0-7].\nDuring 1st iteration a=0 and b=0; coverage of c1 is (1/4)*100 = 25% and coverage of c2 is (1/8)*100 = 12.5% ; therefore average of c1 and c2 is (25+ 12.5)/2 = 18.75%.\nDuring 2nd iteration a=0 and b=2; coverage of c1 is (1/4)*100 = 25% and coverage of c2 is (2/8)*100 = 25% ; therefore average of c1 and c2 is (25+ 25)/2 = 25%.\nDuring 3rd iteration a=1 and b=1; coverage of c1 is (2/4)*100 = 50% and coverage of c2 is (3/8)*100 = 37.5% ; therefore average of c1 and c2 is (50+ 37.5)/2 = 43.75%.\nDuring 4th iteration a=0 and b=2; coverage of c1 is (2/4)*100 = 50% and coverage of c2 is (3/8)*100 = 37.5% ; therefore average of c1 and c2 is (50+ 37.5)/2 = 43.75%.\nDuring 5th iteration a=2 and b=7; coverage of c1 is (3/4)*100 = 75% and coverage of c2 is (4/8)*100 = 50% ; therefore average of c1 and c2 is (75+ 50)/2 = 62.50%.\nCoverage report\nFigure.2. Coverage Report of Covergroup defined inside a module. GitHub lab file link :https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/covergroup/covergrp_declaration/cvgrp_inside_mod/cvgrp_inside_mod.sv\nGitHub log file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/covergroup/covergrp_declaration/cvgrp_inside_mod/cvgrp_inside_mod.log 2. Covergroup defined inside a class# A cover group inside a class can sample variables in that class as well as data values from embedded objects. If the covergroup is defined in a class, it is known as the embedded cover group. Embedded covergroup can be called outside the class with class_handle.covergroup_name .\nSyntax: class class_name; data_type var; covergroup covergroup_instantiate; label: coverpoint var; endgroup endclass Example: class pack; rand bit [1:0] a; rand bit [1:0] b; covergroup cg; c1: coverpoint a; c2: coverpoint b; endgroup cg =new(); endclass pack p = new(); Here the cover group is defined inside the class. . A handle is created for covergroup with a user-defined name \u0026lsquo;cg\u0026rsquo;. Instancing covergroup with a handle name is not required inside the class and module, instead, you can directly use the cover group name. An object is created using the new function. During randomization, \u0026lsquo;a\u0026rsquo; and \u0026lsquo;b\u0026rsquo; variables are randomized using the class_handle.randomize function and the cover group is triggered using the sample function.\nOutput snap Figure.3. Output of Covergroup defined inside a class Here variables a and b can have 4 values that are [0-3].\nDuring 1st iteration a=0 and b=2; coverage of c1 is (1/4)*100 = 25% and coverage of c2 is (1/4)*100 = 25% ; therefore average of c1 and c2 is (25+ 25)/2 = 25%.\nDuring 2nd iteration a=0 and b=1; coverage of c1 is (1/4)*100 = 25% and coverage of c2 is (2/4)*100 = 50% ; therefore average of c1 and c2 is (25+ 50)/2 = 37.50%.\nDuring 3rd iteration a=1 and b=0; coverage of c1 is (2/4)*100 = 50% and coverage of c2 is (3/4)*100 = 75% ; therefore average of c1 and c2 is (50+ 75)/2 = 62.50%.\nDuring 4th iteration a=0 and b=2; coverage of c1 is (2/4)*100 = 50% and coverage of c2 is (3/4)*100 = 75% ; therefore average of c1 and c2 is (50+ 75)/2 = 62.50%.\nDuring 5th iteration a=2 and b=0; coverage of c1 is (3/4)*100 = 75% and coverage of c2 is (3/4)*100 = 75% ; therefore average of c1 and c2 is (75+ 75)/2 = 75%.\nCoverage report\nFigure.3 Coverage Report of Covergroup defined inside a class GitHub lab file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/covergroup/covergrp_declaration/cvgrp_inside_class/cvgrp_inside_class.sv GitHub log file link :https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/covergroup/covergrp_declaration/cvgrp_inside_class/cvgrp_inside_class.log\n3. Covergroup defined outside class and module# The cover group can be defined anywhere within the program, if we are defining covergroup outside a module or class we need to instantiate it with a handle name, and can be used anywhere inside a program by creating an object to the handle using the new function.\nIn general, the Syntax of covergroup\nSyntax: covergroup covergroup_name; label l: coverpoint var 1; ... label N: coverpoint var N; endgroup covergroup_name cg_inst = new(); Example: class cover_group; rand bit [2:0]a; rand bit [1:0]b; endclass cover_group c=new(); covergroup cgrp; c1: coverpoint c.a; c2: coverpoint c.b; endgroup module outside; cgrp cg=new(); initial begin repeat (5)begin void\u0026#39;(c.randomize()); cg.sample(); $display(\u0026#34;a =%d b=%d; coverage %%= %0.2f\u0026#34;,c.a,c.b,cg.get_inst_coverage()); end Here the cover group is defined outside the class and module whereas the variable is declared inside the class. A handle is created for a class with a user-defined name \u0026lsquo;c\u0026rsquo;, Using this handle name(\u0026lsquo;c\u0026rsquo;) an object is created using the new function. Similarly a handle is created for covergroup with a user-defined name \u0026lsquo;cg\u0026rsquo;. Using this handle name an object is created using the new function. Cover group is then triggered using sample function and the variable a and b are randomized using randomize function.\noutput snap Figure.4. Output of over group defined outside class and module Here variable a can have 8 values that is [0-7] and variable \u0026lsquo;b\u0026rsquo; can have 4 values that is [0-3].\nDuring 1st iteration a=0 and b=2; coverage of c1 is (1/8)*100 = 12.5% and coverage of c2 is (1/4)*100 = 25% ; therefore average of c1 and c2 is (12.5+ 25)/2 = 18.75%.\nDuring 2nd iteration a=3 and b=1; coverage of c1 is (2/8)*100 = 25% and coverage of c2 is (2/4)*100 = 50% ; therefore average of c1 and c2 is (25+ 50)/2 = 37.5%.\nDuring 3rd iteration a=0 and b=0; coverage of c1 is (2/8)*100 = 25% and coverage of c2 is (3/4)*100 = 75% ; therefore average of c1 and c2 is (25+ 75)/2 = 50%.\nDuring 4th iteration a=6 and b=2; coverage of c1 is (3/8)*100 = 37.5% and coverage of c2 is (3/4)*100 = 75% ; therefore average of c1 and c2 is (37.5+ 75)/2 = 56.25%.\nDuring 5th iteration a=3 and b=0; coverage of c1 is (3/8)*100 = 37.5% and coverage of c2 is (3/4)*100 = 75% ; therefore average of c1 and c2 is (37.5+ 75)/2 = 56.25%.\nCoverage report\nFigure.4. Coverage report of over group defined outside class and module GitHub lab file link :https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/covergroup/covergrp_declaration/cvgrp_outside_class_mod/cvgrp_outside_class_mod.sv\nGitHub log file link :https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/covergroup/covergrp_declaration/cvgrp_outside_class_mod/cvgrp_outside.log\nTriggering a cover group# Cover groups are generally triggered by the test bench. It is mandatory to trigger cover group for calculating the percentage of the functions covered. In case we don\u0026rsquo;t trigger the cover group the measure of functionality covered will be not calculated and hence by default it will display as (0.00%) zero percent covered. The general way to trigger the cover group explicitly inside the procedural code is by using sample function.\nSL.NO Triggering a cover group 1. Triggering cover group at respective clock edge 2. Mention the event at which the covergroup should be sampled. There are two different methods to trigger coverage collection in a cover group:\n1. Triggering cover group at respective clock edge.# Syntax: covergroup covergroup_name @(clkedge clk) ; // samples coverpoint at respective clk edge coverpoint var; endgroup The cover group is triggered during the respective edge of the clock and the cover points are taken into consideration.\nExample:\nbit clk; always #5 clk=~clk; covergroup cvgp @ (posedge clk); c1: coverpoint a; c2: coverpoint b; endgroup To trigger the cover group we are using clock edges. In this example at every 5ns clock edge varies and during the positive edge of clock the cover group gets triggered and the values of cover points are sampled and randomized.\nOutput snap Figure.5. Output of Triggering cover group at respective clock edge. Here variable a can have 8 values that is [0-7] and variable \u0026lsquo;b\u0026rsquo; can have 2 values that is 0 and 1.\nDuring 1st iteration a=4 and b=1; coverage of c1 is (1/8)*100 = 12.5% and coverage of c2 is (1/2)*100 = 50% ; therefore average of c1 and c2 is (12.5+ 50)/2 = 31.25%.\nDuring 2nd iteration a=1 and b=0; coverage of c1 is (2/8)*100 = 25% and coverage of c2 is (2/2)*100 = 100% ; therefore average of c1 and c2 is (25+ 100)/2 = 62.50%.\nDuring 3rd iteration a=1 and b=0; coverage of c1 is (2/8)*100 = 25% and coverage of c2 is (2/2)*100 = 100% ; therefore average of c1 and c2 is (25+ 100)/2 = 62.50%.\nDuring 4th iteration a=3 and b=0; coverage of c1 is (3/8)*100 = 37.5% and coverage of c2 is (2/2)*100 = 100% ; therefore average of c1 and c2 is (37.5+100)/2 = 68.75%.\nDuring 5th iteration a=5 and b=0; coverage of c1 is (4/8)*100 = 50% and coverage of c2 is (2/2)*100 = 100% ; therefore average of c1 and c2 is (50+ 100)/2 = 75%.\nCoverage report\nFigure.5. Coverage report of Triggering cover group at respective clock edge. GitHub lab file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/covergroup/cvrgrp_triggering/cvgrp_using_clk/cvgrp_using_clk.sv GitHub log file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/covergroup/cvrgrp_triggering/cvgrp_using_clk/cvgrp_clk.log 2. Mention the event at which the covergroup should be sampled.# The coverage event can use a @ to block signals or events. coverage group can be triggered using \u0026ldquo;-\u0026gt; event_name\u0026rdquo; in the procedural code.\nSyntax: covergroup covergroup_name @ e; // e is an event name and can be triggered using -\u0026gt;e label: coverpoint var; endgroup Example: event e; covergroup cgrp @ e; c1 : coverpoint a; endgroup cgrp cg; initial begin cg = new(); repeat (5)begin a=$random; #1 -\u0026gt; e; $display(\u0026#34;a = %0d ; coverage = %0.2f\u0026#34;,a,cg.get_inst_coverage()); end Another method used to trigger the cover group is by using events. In this example, an event \u0026rsquo;e\u0026rsquo; is defined and triggered using -\u0026gt;e(event_name) this in turn triggers the covergroup and samples the values of every cover point. The advantage of using an event over calling the sampling method directly is that you may be able to use an existing event.\noutput snap Figure.6. Output of Mention the event at which the covergroup should be sampled. Here variable a can have 4 values that is [0-3].\nDuring 1st iteration a=0 ; coverage of c1 is (1/4)*100 = 25% .\nDuring 2nd iteration a=1 ; coverage of c1 is (2/4)*100 = 50% .\nDuring 3rd iteration a=1 ; coverage of c1 is (2/4)*100 = 50% .\nDuring 4th iteration a=3 ; coverage of c1 is (3/4)*100 = 75% .\nDuring 5th iteration a=1 ; coverage of c1 is (3/4)*100 = 75% .\ncoverage report\nFigure.6. Coverage Report of Mention the event at which the covergroup should be sampled. GitHub lab file link :https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/covergroup/cvrgrp_triggering/cvgrp_using_event/using_evnt.sv\nGitHub log file link :https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/covergroup/cvrgrp_triggering/cvgrp_using_event/using_evnt.log\nConditional Coverage# Cheat sheet for Conditional Coverage Variations\nSL.No. Conditional Coverage Variations 1. Use iff keyword to add a condition to the coverpoint 2. Use the start and stop functions to control individual instances of cover groups 1. Use iff keyword to add a condition to the coverpoint.# The most common reason for doing so is to turn off coverage till the specified condition is satisfied so that stray triggers are ignored.\nSyntax: covergroup covergroup_name; coverpoint var iff (condition) { //bins for var} endgroup iff is similar to if condition. Whenever the condition inside iff is true then only it enters into the bins and checks for the coverage. If the condition is not satisfied or false the bins are ignored and the entire cover point will have (0.00%)zero coverage.\nExample: covergroup cvgrp @ (posedge clk); c1: coverpoint a iff(b==2) {bins b1 = {4}; bins b2 = {5};} endgroup In this example, the coverpoint is defined for variable \u0026lsquo;a\u0026rsquo; and only if the condition (b==2) is satisfied the coverpoint bins are executed. Here If the b value is 2 then cover point bins are checked for their conditions b1 and b2. Bin b1 is said to be hit/covered only if the variable \u0026lsquo;a\u0026rsquo; is assigned with 4 and similarly bin b2 is said to be hit/covered only if the variable \u0026lsquo;a\u0026rsquo; is assigned with 5. Finally, it averages the coverage percentage of the bins and that is termed as the overall coverage of that particular coverpoint.\noutput snap Figure.7. Output of Use iff keyword to add a condition to the coverpoint Here variable a can have 8 values that is [0-7] and variable \u0026lsquo;b\u0026rsquo; can have 4 values that is [0-3].Coverage depends on explicitly defined bins. bins b1\nDuring 1st iteration a=4 and b=1; checks for \u0026lsquo;b\u0026rsquo; value; iff condition (b==2) is False, hence coverage of b1=0% and coverage of bin b2 =0% ; Average coverage of coverpoint is (0+0)/2 = 0.00%.\nDuring 2nd iteration a=1 and b=3; checks for \u0026lsquo;b\u0026rsquo; value; iff condition (b==2) is False, hence coverage of b1=0% and coverage of bin b2 =0% ; Average coverage of coverpoint is (0+0)/2 = 0.00%.\nDuring 3rd iteration a=5 and b=1; checks for \u0026lsquo;b\u0026rsquo; value; iff condition (b==2) is False, hence coverage of b1=0% and coverage of bin b2 =0% ; Average coverage of coverpoint is (0+0)/2 = 0.00%.\nDuring 4th iteration a=5 and b=2; checks for \u0026lsquo;b\u0026rsquo; value; iff condition (b==2) is True, hence coverage of b1=0% and coverage of bin b2 =100% ; Average coverage of coverpoint is (0+100)/2 = 50%.\nDuring 5th iteration a=1 and b=1; checks for \u0026lsquo;b\u0026rsquo; value; iff condition (b==2) is False, hence coverage of b1=0% and coverage of bin b2 =100% ; Average coverage of coverpoint is (0+100)/2 = 50%.\nDuring 6th iteration a=6 and b=1; checks for \u0026lsquo;b\u0026rsquo; value; iff condition (b==2) is False, hence coverage of b1=0% and coverage of bin b2 =100% ; Average coverage of coverpoint is (0+100)/2 = 50%.\nDuring 7th iteration a=5 and b=0; checks for \u0026lsquo;b\u0026rsquo; value; iff condition (b==2) is False, hence coverage of b1=0% and coverage of bin b2 =100% ; Average coverage of coverpoint is (0+100)/2 = 50%.\nDuring 8th iteration a=1 and b=2; checks for \u0026lsquo;b\u0026rsquo; value; iff condition (b==2) is True, hence coverage of b1=0% and coverage of bin b2 =100% ; Average coverage of coverpoint is (0+100)/2 = 50%.\ncoverage report\nFigure.7.Coverage Report of Use iff keyword to add a condition to the coverpoint GitHub lab file link :https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/covergroup/conditional_coverage/cvgrp_iff/cvgrp_iff.sv\nGitHub log file link :https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/covergroup/conditional_coverage/cvgrp_iff/cvgrp_iff.log\n2. Use the start and stop functions to control individual instances of cover groups.# Covergroup_name cg_inst = new; initial begin if(condition) cg_inst.stop(); else cg_inst.start(); end In the above example if and else statements are used to explain the start and stop functions. These functions can be called anywhere within the procedural code. In general stop and start functions are defined in handle. start() or handle.stop() manner.\nExample: covergroup cgrp; c1: coverpoint s.a; c2: coverpoint s.b; endgroup module cvgrp_start_stop; cgrp cg; initial begin cg = new(); for(int i=0;i\u0026lt;6;i++) begin void\u0026#39;(s.randomize()); cg.sample(); $display(\u0026#34;a=%d ; b=%d ; coverage = %0.2f\u0026#34;,s.a,s.b,cg.get_inst_coverage()); if (cg.get_inst_coverage()\u0026gt;65)begin cg.stop; $display(\u0026#34;if coverage%% is greater than 65%%,stop executing covergroup\u0026#34;); end end In this example, the variables a and b are declared inside the class. To access those variables from the class we created an object with the handle (here handle for the class is \u0026rsquo;s\u0026rsquo;). After triggering the covergroup the coverage percentage is getting displayed. If the coverage is beyond 65% the execution of coverage crop is stopped using cg.stop (group_handle_name.stop) function. Hence the coverage percentage will remain constant, even if new values are assigned to variables the coverpoint ignores those values and shows the previous percentage. Execution can be triggered and continued by using cg.start (group_handle.start) function.\noutput snap Figure.8. Output of Use the start and stop functions to control individual instances of cover groups Here variable a can have 8 values that is [0-7] and variable \u0026lsquo;b\u0026rsquo; can have 2 values that is 0 and 1.\nDuring 1st iteration a=0 and b=0; coverage of c1 is (1/8)*100 = 12.5% and coverage of c2 is (1/2)*100 = 50% ; therefore average of c1 and c2 is (12.5+ 50)/2 = 31.25%.\nDuring 2nd iteration a=1 and b=1; coverage of c1 is (2/8)*100 = 25% and coverage of c2 is (2/2)*100 = 100% ; therefore average of c1 and c2 is (25+ 100)/2 = 62.50%.\nDuring 3rd iteration a=6 and b=0; coverage of c1 is (3/8)*100 = 37.5% and coverage of c2 is (2/2)*100 = 100% ; therefore average of c1 and c2 is (25+ 100)/2 = 68.75%.\nExecution of cover points is stopped and hence the coverage percentage remains unchanged. Even though new values of a and b are assigned they are ignored and coverage will not be calculated.\ncoverage report\nFigure.8. Coverage of Use the start and stop functions to control individual instances of cover groups Git lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/covergroup/conditional_coverage/cvgrp_start_stop/cvgrp_start_stop.sv Git lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/covergroup/conditional_coverage/cvgrp_start_stop/cvgrp_start_stop.log Cross Coverage :# Cross Coverage is specified between the cover points or variables. Cross coverage is specified using the cross construct. Expressions cannot be used directly in a cross. cross coverage can be measured for two or more cover points at the same time. If we are measuring cross coverage of a variable with N values, and of another with M values, internally there will be N * M bins to store all the combinations of \u0026lsquo;NM\u0026rsquo;.\nSyntax:\ncovergroup covergroup_name; label1: coverpoint var1; label2: coverpoint var2; label3:cross label1,label2; endgroup Example - 1:\ncovergroup cg; c1: coverpoint a; c2: coverpoint b; c3: cross c1,c2; endgroup cg = new(); In this example the cross coverage is carried out between coverpoint c1 and c2. variable a and b are of single bit and hence it can have values either 0 or 1. After execution of c1 and c2, cross of those cover points are calculated by using cross keyword. Since variable \u0026lsquo;a\u0026rsquo; and \u0026lsquo;b\u0026rsquo; each can have 2 values, the cross of this can have combination of a and b i,e { {0,1} , {0,1} , {1,0}, {1,1} }.\nExample 2:\ncovergroup cvgrp; c1:cross a,b; endgroup cvgrp cg = new(); Instead of writing 3 lines of code for cross coverage on cover points(cross c1,c2), we can directly write that in one code using cross of variable names(cross a,b). Using cross construct for variables will implicitly creates an individual cover points on variable \u0026lsquo;a\u0026rsquo;, on variable \u0026lsquo;b\u0026rsquo; and a cross of variable a and b. This is just similar to the previous example 1. Hence the output of example 1 and example 2 remains same.\nHere variable a and b can have 2 values that is either 0 or 1 and the cross values are the combination of two coverpoint values, they are {0,0}, {0,1}, {1,0} and {1,1}.\nDuring 1st iteration a=1 and b=0; coverage of c1 is (1/2)*100 = 50% ; coverage of c2 is (1/2)*100 = 50% ; coverage of c3 is (1/4)*100 = 25% ; therefore average of c1, c2 and cross c3 is (50+50+25)/3 = 41.67%.\nDuring 2nd iteration a=1 and b=0; coverage of c1 is (1/2)*100 = 50% ; coverage of c2 is (1/2)*100 = 50% ; coverage of c3 is (1/4)*100 = 25% ; therefore average of c1, c2 and cross c3 is (50+50+25)/3 = 41.67%.\nDuring 3rd iteration a=0 and b=1; coverage of c1 is (2/2)*100 = 100% ; coverage of c2 is (2/2)*100 = 100% ; coverage of c3 is (2/4)*100 = 50% ; therefore average of c1, c2 and cross c3 is (100+100+50)/3 = 83.33%.\nDuring 4th iteration a=1 and b=0; coverage of c1 is (2/2)*100 = 100% ; coverage of c2 is (2/2)*100 = 100% ; coverage of c3 is (2/4)*100 = 50% ; therefore average of c1, c2 and cross c3 is (100+100+50)/3 = 83.33%.\nDuring 5th iteration a=1 and b=1; coverage of c1 is (2/2)*100 = 100% ; coverage of c2 is (2/2)*100 = 100% ; coverage of c3 is (3/4)*100 = 75% ; therefore average of c1, c2 and cross c3 is (100+100+75)/3 = 91.67%.\nNOTE : If we define cover points on some variables, and a cross on that variables, then there arises a warning.\nWarning Example:\ncovergroup cvgrp; c1: coverpoint a; c2: coverpoint b; c3: cross a,b; endgroup In this example both coverpoint and cross are carried out on same variables. Earlier we have seen cross between cover points and cross between the variables but here we are performing cross on variables whose cover points are already defined explicitly.\nNow here a conflict arises in the simulator. The conflict is variable \u0026lsquo;a\u0026rsquo; and \u0026lsquo;b\u0026rsquo; are already defined in cover points, hence we can directly write cross on those cover points c1 and c2. Other wise if we don\u0026rsquo;t need to use that c1 and c2 then, the simulator will implicitly create another cover points on a and b along with cross of those variables. Therefore in total we will have 5 cover points.\nHere variable a and b can have 2 values that is either 0 or 1. Inside covergroup c1,c2 and c3 are cover points. c3 will generate 3 coverpoint c3[0] , c3[1] and c3[2] implicitly.\nDuring 1st iteration a=0 and b=1; coverage of c1 is (1/2)*100 = 50% ; coverage of c2 is (1/2)*100 = 50% ;In coverage of c3 implicitly coverpoints for a and b are generated. Hence, cover point c3 will split into 3 seperate parts, c3[0] is for a variable \u0026lsquo;a\u0026rsquo; , c3[1] is for a variable \u0026lsquo;b\u0026rsquo; and c3[2] is for cross of a and b. coverage of c3: c3[0] is (1/2)*100 = 50% ; c3[1] is (1/2)*100 = 50% ; c3[2] is (1/4)*100 = 25% ; The overall average for first iteration is (c1+c2+c3[0]+c3[1]+c3[2])/5; that is (50+50+50+50+25)/5 = 45%.\nDuring 2nd iteration a=1 and b=1; coverage of c1 is (2/2)*100 = 100% ; coverage of c2 is (1/2)*100 = 50% ; coverage of c3: c3[0] is (2/2)*100 = 100% ; c3[1] is (1/2)*100 = 50% ; c3[2] is (2/4)*100 = 50% ;\nThe overall average for first iteration is (c1+c2+c3[0]+c3[1]+c3[2])/5; that is (100+50+100+50+50)/5 = 70%.\nDuring 3rd iteration a=1 and b=1; coverage of c1 is (2/2)*100 = 100% ; coverage of c2 is (1/2)*100 = 50% ; coverage of c3: c3[0] is (2/2)*100 = 100% ; c3[1] is (1/2)*100 = 50% ; c3[2] is (2/4)*100 = 50% ;\nThe overall average for first iteration is (c1+c2+c3[0]+c3[1]+c3[2])/5; that is (100+50+100+50+50)/5 = 70%.\nDuring 4th iteration a=1 and b=0; coverage of c1 is (2/2)*100 = 100% ; coverage of c2 is (2/2)*100 = 100% ; coverage of c3: c3[0] is (2/2)*100 = 100% ; c3[1] is (2/2)*100 = 100% ; c3[2] is (3/4)*100 = 75% ;\nThe overall average for first iteration is (c1+c2+c3[0]+c3[1]+c3[2])/5; that is (100+100+100+100+75)/5 = 95%. During 5th iteration a=1 and b=0; coverage of c1 is (2/2)*100 = 100% ; coverage of c2 is (2/2)*100 = 100% ; coverage of c3: c3[0] is (2/2)*100 = 100% ; c3[1] is (2/2)*100 = 100% ; c3[2] is (3/4)*100 = 75% ; The overall average for first iteration is (c1+c2+c3[0]+c3[1]+c3[2])/5; that is (100+100+100+100+75)/5 = 95%.\nCoverpoints can be specified in various ways:\ncoverpoints using value coverpoints using expression coverpoints using function return value coverpoints using part select coverpoints using value# syntax: cover_value: coverpoint value_name;\ncode snippet:\nbit [3:0] a; bit [3:0] arr[4]=\u0026#39;{2,5,0,12}; covergroup cg; //creating covergroup cg a1:coverpoint a; //declaring coverpoint a1 endgroup cg cg_inst; //instantiating covergroup cg initial begin cg_inst = new(); foreach(arr[i]) begin a=arr[i]; //assigning array values to a cg_inst.sample(); //sampling the covergroup cg $display(\u0026#34;a=%d coverage %%=%0.2f\u0026#34;,a,cg_inst.get_inst_coverage()); end end Here in the covergroup \u0026lsquo;cg\u0026rsquo; coverpoint a1 is specified with the value \u0026lsquo;a\u0026rsquo;.The value of \u0026lsquo;a\u0026rsquo; is assigned each time by the array \u0026lsquo;arr\u0026rsquo;. \u0026lsquo;a\u0026rsquo; is the 4 bit number, so there are 16 possible values for \u0026lsquo;a\u0026rsquo;.\nOutput snap:\nFig 10: Output for coverpoint using values. coverage report Fig 10: Coverage report for coverpoint using values. Git lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/coverpoints/simple_coverpoint/cover_point.sv Git lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/coverpoints/simple_coverpoint/cover_point.log In the above example, for 1st iteration, one value is covered so the coverage percentage is equal to (1/16)*100=6.25%. In 2nd iteration, the value of \u0026lsquo;a\u0026rsquo; is covered with two values so the coverage percentage will be (2/16)*100=12.5%. In 3rd iteration, the value of \u0026lsquo;a\u0026rsquo; is covered with three values so the coverage percentage will be (3/16)*100=18.75%. In the 4th iteration, the value of \u0026lsquo;a\u0026rsquo; is covered with four values so the coverage percentage will be (4/16)*100=25%. Here bins are not specified so the system Verilog automatically created bins \u0026lsquo;auto bins\u0026rsquo; for the coverpoint. If the same value occurs more than once then the system Verilog is considered it was covered and doesn\u0026rsquo;t count on the next time, it is just ignored.\ncoverpoints using expression# syntax:\ncover_exp: coverpoint expression; In coverpoints, the coverpoint can be specified with the integral arithmetic expression.\nCode snippet:\nbit [1:0] a; bit [2:0] b; covergroup cg; //created covergroup cg a1:coverpoint a; //declaring coverpoint a1 b1:coverpoint b; //declaring coverpoint b1 axb:coverpoint a*b; //declaring coverpoint axb endgroup:cg cg cg_inst; //covergroup instantiating initial begin cg_inst = new(); repeat(10) begin a=$random; //assigning random values to a b=$random; //assigning random values to b cg_inst.sample(); //sampling the covergroup cg $display(\u0026#34;a=%d b=%d axb=%d coverage %%=%0.2f\u0026#34;,a,b,a*b,cg_inst.get_inst_coverage()); end end Here the coverpoint a x d is specified using the arithmetic expression. The coverpoint a x b is calculated and the number of bits for a x b is equal to the maximum of the number of bits of a \u0026amp; b.\nOutput snap:\nFig 11: Output for coverpoint using expression coverage report Fig 11 : Coverage report for coverpoint using expression Git lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/coverpoints/coverpoint_expression/expression.sv Git lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/coverpoints/coverpoint_expression/expression.log Here \u0026lsquo;a\u0026rsquo; has 2 bits and \u0026lsquo;b\u0026rsquo; has 3 bits, therefore a x b is a 3-bit number. So, for a x b there will be 2^3=8 automatic bins created. If a x b has more than 3 bits it is considered only 3 bits from LSB. Therefore in the coverage report, the automatic bins for a x b are 8 and one is uncovered. The coverage percentage of a,b, and a x b are 75, 87.5, and 87.5 respectively, so the total coverage percentage will be the average of individual coverages i.e., 83.3%.\ncoverpoints using the function return value# Coverpoints can be specified using a function call and the return type must be an integral value.\nsyntax: cover_func:coverpoint func_call();\ncode snippet:\nfunction bit[3:0] sum(int a, int b); //declaring function int c; c=a+b; return c; //returning the sum value endfunction module func_return_value(); class val; //declaring class val randc bit [1:0]a; randc bit [1:0]b; endclass int addition; covergroup cg; //created covergroup cg a: coverpoint v.a; b: coverpoint v.b; func: coverpoint sum(v.a,v.b); //called the function in covergroup endgroup val v; cg cg_inst; //instantiated covergroup cg initial begin v=new(); cg_inst=new(); repeat(5) begin void\u0026#39;(v.randomize()); //randomizing the class variables addition=sum(v.a,v.b); //storing function return value in addition variable cg_inst.sample(); //sampling the covergreoup cg $display(\u0026#34;a = %d, b = %d; add = %d\u0026#34;,v.a,v.b,addition); $display(\u0026#34;\\tcoverage %%=%0.2f\u0026#34;,cg_inst.get_inst_coverage()); end end Here the function func is calling inside the covergroup whenever the covergroup is sampled and then calculates the coverage percentage of the coverpoint func.\noutput snap:\nFig 12: Output for coverpoint using function call. coverage report Fig 12: coverage report for coverpoint using function call In this example the coverpoint is specified using the function call sum(). The return value of the function has 4 bits, therefore the maximum number of possible values will be 2^4=16.The coverpoint func will calculate the coverage percentage of the function call whenever covergroup is sampled.\nGitHub lab file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/coverpoints/func_return_value/func_return_value.sv GitHub log file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/coverpoints/func_return_value/func_return_value_log.log coverpoints using part select# coverpoints can be specified by selecting part of the variable like addr[31:4].\nsyntax: cover_part: coverpoint addr[31:4]; code snippet: bit [2:0] a; covergroup cg; //created covergroup cg a1:coverpoint a[1:0]; //declaring coverpoint a1 with \u0026#39;a\u0026#39; has 2 bits from LSB a2:coverpoint a[0]; //declaring coverpoint a2 only with LSB a3:coverpoint a[2:1]; //declaring coverpoint a3 with \u0026#39;a\u0026#39; has 2 bits from MSB endgroup cg cg_inst; //covergroup cg instance initial begin cg_inst=new(); for(int i=0;i\u0026lt;5;i++) begin a=$random; //assigining random values to a cg_inst.sample(); //sampling the covergroup $display(\u0026#34;a=%d a1=%b a2=%b a3=%b\u0026#34;,a,a[1:0],a[0],a[2:1]); $display(\u0026#34;\\tcoverage %%=%0.2f\u0026#34;,cg_inst.get_coverage()); end end In part select we can check the coverage of the selected part of the variable. Based on the number of bits selected there are 2^n auto bins are created and checks the coverage of the 2^n possible values.\noutput snap: Fig 13: output for coverpoint using part select coverage report Fig 13: coverage report for part select In coverpoint a1, the bits are selected from the last 2 bits of \u0026lsquo;a\u0026rsquo; from LSB. So for coverpoint a1 has 2^2=4 possible values. For coverpoint a2, the [0] bit is selected, therefore a2 has 2^1=2 possible values. For coverpoint a3, the 2 bits are selected from the MSB, therefore it has 4 possible values. Based on the values covered by each covergroup the coverage percentage will be calculated.\nGitHub lab file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/coverpoints/part_select/part_select.sv GitHub log file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/coverpoints/part_select/part_select_log.log Coverage Bins# Coverpoint must be declared inside the cover group, it can contain one or more coverage points. A coverage point can be an integral variable or an expression. Each coverage point is associated with “bins”.\nCoverage-point bin associates a name and a count with a sequence of values or a set of values transitions. If the bin selects a set of values, the count is incremented every time the coverage point matches one of the values in the set. If the bin selects a sequence of value transitions, the count is incremented every time the coverage point matches the entire sequence of value transitions.\nSyntax: Coverpoint_name: coverpoint variable{bins bin 1 = {values}; .... {bins bin N = {values};} Types of Bins Automatic or Implicit bins Explicit bins Transition bins Wildcard bins Ignore bins Illegal bins Cheat sheet for Bins\nSL.No. Bins 1. Automatic or Implicit bins 2. Explicit bins 3. Transition Bins 4. Wildcard bins 5. Ignore bins 6. Illegal bins Bins can be created implicitly(automatic) or explicitly.\n1. Automatic or Implicit bins# While defining cover points, if you are not specifying any bins, then it creates automatic bins for cover points. The number of bins created can be controlled by auto_bin_max parameter.\nSyntax: Coverpoint_name: coverpoint variable; Example:\nLet\u0026rsquo;s take an example of an implicit bin for better understanding. module implicit_bin; bit [2:0] a; covergroup cov_grp; c1 : coverpoint a; endgroup cov_grp cg = new(); initial begin for(int i=1;i\u0026lt;=5;i++) begin a=$random; cg.sample(); $display(\u0026#34;a=%d, coverage = %0.2f %%\u0026#34;,a,cg.get_inst_coverage()); end end endmodule Here variable \u0026lsquo;a\u0026rsquo; can have 8 values that are [0-7]. Here automatic bins are created.\nOutput snap: The below figure shows the output of the implicit bin.\nFig 14: Output Of Automatic or Implicit bins coverage report Fig 14: Coverage Report Of Automatic or Implicit bins\nGitHub lab file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/implicit_bin/implicit_bin.sv GitHub log file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/implicit_bin/implicit_bin.log Here bins will be automatically created, since it has 8 values 8 bins will be created.\nDuring 1st iteration a=4, coverage of c1 is (1/8)*100 = 12.50%. During 2nd iteration a=1, coverage of c1 is (2/8)*100 = 25%. (because in the previous iteration one value has been covered so in this iteration we will consider as 2) During 3rd iteration a=1, coverage of c1 is (2/8)*100 = 25% (because a=1 is already covered). During 4th iteration a=3, coverage of c1 is (3/8)*100 = 37.50%. During 5th iteration a=5, coverage of c1 is (4/8)*100 = 50%. 2. Explicit bins# The bins keyword is used to declare the bins explicitly to a variable.\nExplicit bin creation is recommended method. Not all values are interesting or relevant in a cover point, so when a user knows the exact values going to cover, then a user can use explicit bins. Explicit bins are declared within curly braces { } along with the bins keyword followed by bin name and variable value/range, immediately after the coverpoint identifier.\nSyntax: Coverpoint_name: coverpoint variable{bins bin_name = {values};} Example:\nLet\u0026rsquo;s take an example of an explicit bin for better understanding. module explicit_bin; bit [2:0] a; covergroup cov_grp; c1 : coverpoint a{ bins b1={2}; bins b2={3}; } endgroup cov_grp cg = new(); initial begin for(int i=1;i\u0026lt;=5;i++) begin a=$random; cg.sample(); $display(\u0026#34;a=%d, coverage = %0.2f %%\u0026#34;,a,cg.get_inst_coverage()); end end endmodule Here variable \u0026lsquo;a\u0026rsquo; can have 8 values that are [0-7], for \u0026lsquo;a\u0026rsquo; variable c1 is the cover-point which has two bins- b1=2 and b2=3. When \u0026lsquo;a\u0026rsquo; gets any of this bin value that particular bin is considered a hit.\nOutput Snap: The below figure shows the output of the explicit bin.\nFig 15: Output Of Explicit bins Coverage report\nFig 15:Coverage Report Of Explicit bins\nThe denominator depends on the number of bins, since only 2 bins are given here so the denominator is considered as 2.\nDuring 1st iteration a=4, coverage of b1 is (0/1)*100=0% and b2 is (0/1)=0%, so the average of b1 and b2 is the coverage of c1 that is (0/1+0/1)*100=0%. During 2nd iteration a=1, coverage of b1 is (0/1)*100=0% and b2 is (0/1)=0%, so the average of b1 and b2 is the coverage of c1 that is (0/1+0/1)*100=0%. During 3rd iteration a=1, coverage of b1 is (0/1)*100=0% and b2 is (0/1)=0%, so the average of b1 and b2 is the coverage of c1 that is (0/1+0/1)*100=0%. During 4th iteration a=3, coverage of b1 is (0/1)*100=0% and b2 is (1/1)*100=100%, so the average of b1 and b2 is the coverage of c1 that is (0/1+1/1)*100=50%. During 5th iteration a=5, coverage of b1 is (0/1)*100=0% and b2 is (0/1)=0%, so the average of b1 and b2 is the coverage of c1 that is (0/1+0/1)*100=50%. GitHub lab file link :https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/explicit_bin/explicit_bin.sv\nGitHub log file link :https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/explicit_bin/explicit_bin.log\n3. Transition bins# A transitional functional point bin is used to examine the legal transitions of a value. SystemVerilog allows specifies one or more sets of ordered value transitions of the coverage point.\nSyntax: covergroup cg; c1: coverpoint a; { bins u[] = (value1=\u0026gt;value2); } Type of Transitions: Single Value Transition Sequence Of Transitions Set Of Transitions Consecutive Repetitions Range Of Repetition Goto Repetition Single value transition:\nSingle value transition is specified as \u0026lt; value1 \u0026gt; =\u0026gt; \u0026lt; value2 \u0026gt;,value 1 is followed bt value 2.\nSyntax:\ncoverpoint_name: coverpoint variable {bins bin 1 = (value1 =\u0026gt; value2); ... bins bin N = (value1 =\u0026gt; value2); } Example: Let\u0026rsquo;s take an example of a single value transition bin for better understanding.\nmodule single_val_tran_bin; bit [0:3] a; bit [0:2] values[$]= \u0026#39;{1,2,3,4}; covergroup cov_grp; c1 : coverpoint a{ bins tran_1 = (1=\u0026gt;2); bins tran_2 = (3=\u0026gt;4); } endgroup cov_grp cg = new(); initial begin foreach(values[i]) begin a=values[i]; cg.sample(); $display(\u0026#34;val=%d, cov = %0.2f %%\u0026#34;,a,cg.get_inst_coverage()); end end endmodule In the above example for the \u0026lsquo;a\u0026rsquo; variable, there are two bins trans_1 and trans_2. 2 bins were created for covering the transition of \u0026lsquo;a\u0026rsquo;, from 1 to 2 and 3 to 4.\nOutput snap: The below figure shows the output of the single-value transition bin.\nFig 17: Output Of Single Value Transition coverage report Fig 17: Coverage Report Of Single Value Transition When val=1 then the coverage will be 0% (because still there is no transition completed) When val=2 then the coverage will be 50% (because the transition from 1 to 2 of trans_1 has been completed that is 100, so the average of val 1 and val 2 is 50%) When val=3 then the coverage will be 50% (because still there is no transition, so it takes the coverage of the previous one) When val=4 then the coverage will be 100% (because the transition from 3 to 4 of trans_2 has been completed) GitHub lab file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/transition_bins/single_val_trans/single_val_trans_bin.sv GitHub log file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/transition_bins/single_val_trans/single_val_trans_bin.log Sequence of transition:\nSequence of transitions is specified as \u0026lt; value1 \u0026gt; =\u0026gt; \u0026lt; value2 \u0026gt; =\u0026gt; \u0026lt; value3 \u0026gt; =\u0026gt; \u0026lt; value4 \u0026gt;, value 1 is followed by value 2, followed by value 3 and followed by value 4.\nSyntax:\ncoverpoint_name: coverpoint variable {bins bin 1 = (value 1 =\u0026gt; value 2 =\u0026gt; value 3); ... bins bin N = (value 1 =\u0026gt; value 2 =\u0026gt; value 3 =\u0026gt; value 4); } Example:\nLet\u0026rsquo;s take an example of a sequence of transition bins for better understanding. module sequence_of_trans_bin; bit [0:2] a; bit [0:2] values[$] = \u0026#39;{1,2,3,4}; covergroup cov_grp; c1 : coverpoint a { bins tran_1 = (1=\u0026gt;2=\u0026gt;3); //bins tran_2 = (1=\u0026gt;2=\u0026gt;4); } endgroup cov_grp cg = new(); initial begin foreach(values[i]) begin a = values[i]; cg.sample(); $display(\u0026#34;val=%d,cov = %.2f %%\u0026#34;,a,cg.get_inst_coverage()); end end endmodule In the above example, 2 bins are created for covering the transition of point \u0026lsquo;a\u0026rsquo; from 1 to 2 to 3 and another for 1 to 2 to 4.\nOutput snap: The below figure shows the output of the sequence of the transition bin.\nFig 18: Output Of Sequence Of Transitions coverage report Fig 18: Coverage Report Of Sequence Of Transition GitHub lab file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/transition_bins/sequence_of_trans/sequence_of_trans_bin.sv GitHub log file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/transition_bins/sequence_of_trans/sequence_of_trans_bin.log Set of transition:\nThe set of transitions is specified as \u0026lt;transition_set1\u0026gt; =\u0026gt; \u0026lt;transition_set2\u0026gt;\nSyntax:\ncoverpoint_name: coverpoint variable {bins bin 1[] = (transition_set 1 =\u0026gt; transition_set 2); } Example:\nLet\u0026rsquo;s take an example of a set of transition bins for better understanding. module set_of_trans_bin; bit [0:3] a; bit [0:2] values[$]= \u0026#39;{1,2,3,4,5}; covergroup cov_grp; c1 : coverpoint a { bins tran_1 = (1,2=\u0026gt;3,4); bins tran_2 = (3,4=\u0026gt;5); bins tran_3 = (1,3=\u0026gt;4); } endgroup cov_grp cg = new(); initial begin foreach(values[i]) begin a = values[i]; cg.sample(); $display(\u0026#34;val=%d,cov = %.2f %%\u0026#34;,a,cg.get_inst_coverage()); end end endmodule In the above example, bin trans creates 3 bin for covering 1=\u0026gt;3, 2=\u0026gt;3, 1=\u0026gt;4, 2=\u0026gt;4, 3=\u0026gt;5, 4=\u0026gt;5 and 3=\u0026gt;4. .\nOutput Snap: The below figure shows the output of the set of transition bins. Fig 19: Output Of Set Of Transitions Coverage report Fig 19: Coverage Report of Set Of Transitions When val=1, the coverage will be 0% (because still the bin transition is not completed)\nWhen val=2, the coverage will be 0% (because still the bin transition is not completed)\nWhen val=3, the coverage will be 33.33% (because the bin transition is completed) When val=4, the coverage will be 66.67% (because the bin transition is completed)\nWhen val=5, the coverage will be 100% (because the bin transition is completed)\nGitHub lab file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/transition_bins/set_of_trans/set_of_trans_bin.sv GitHub log file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/transition_bins/set_of_trans/set_of_trans_bin.log Consecutive Repetitions:\nThe range of repetition is specified as \u0026lt;transition_value\u0026gt; [*\u0026lt; repeat_value \u0026gt;]\nSyntax:\ncoverpoint_name: coverpoint variable {bins bin 1[] = (transition_value[*\u0026lt; return_value \u0026gt;]); } Example:\nLet\u0026rsquo;s take an example of consecutive repetitions bin for better understanding. module consec_repeat_bin; bit [0:3] a; bit [0:2] values[$]= \u0026#39;{2,2,4,4,4}; covergroup cov_grp; c1 : coverpoint a { bins tran_1 = (2[*2]); bins tran_2 = (4[*3]); } endgroup cov_grp cg = new(); initial begin foreach(values[i]) begin a = values[i]; cg.sample(); $display(\u0026#34;val=%d,cov = %.2f %%\u0026#34;,a,cg.get_inst_coverage()); end end endmodule Here, trans_item is repeated for repeat_range times, that is 2[*2] is the same as 2=\u0026gt;2 and 4[*3] is the same as 4=\u0026gt;4=\u0026gt;4.\nOutput snap: The below figure shows the output of the consecutive repetitions bin. Fig 20: Output Of Consecutive Repetitions Coverage Report Fig 20:Coverage Report Output Of Consecutive Repetitions\nGitHub lab file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/transition_bins/consec_repeat/consec_repeat_bin.sv GitHub log file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/transition_bins/consec_repeat/consec_repeat_bin.log Range of repetition: The range of repetition can be specified as \u0026lt;transition_value\u0026gt; [*\u0026lt;repeat_range\u0026gt;]\nSyntax:\ncoverpoint_name: coverpoint variable {bins bin 1[] = (transition_value[*\u0026lt; return_value \u0026gt;]); } Example:\nLet\u0026rsquo;s take an example of a range of repetitions bin for better understanding. module range_of_repeat_bin; bit [0:3] a; bit [0:2] values[$]= \u0026#39;{2,3,2,2,2,2,4,4}; covergroup cov_grp; c1 : coverpoint a { bins tran_1 = (2[*3:5]); bins tran_2 = (4[*3]); } endgroup cov_grp cg = new(); initial begin foreach(values[i]) begin a = values[i]; cg.sample(); $display(\u0026#34;val=%d,cov = %.2f %%\u0026#34;,a,cg.get_inst_coverage()); end end endmodule An example of a range of repetition is 2 [* 3:5] is the same as 2=\u0026gt;2=\u0026gt;2, 2=\u0026gt;2=\u0026gt;2=\u0026gt;2, 2=\u0026gt;2=\u0026gt;2=\u0026gt;2=\u0026gt;2\nOutput Snap: The below figure shows the output of the range of repetitions bin. Fig 21: Output Of Range of repetitions bin. Coverage Report Fig 21: Coverage Report Of Range of repetitions bin GitHub lab file link :https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/transition_bins/range_of_repeat/range_of_repeat_bin.sv\nGitHub log file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/transition_bins/range_of_repeat/range_of_repeat_bin.log Goto repetition: The goto repetition is specified using trans_item [-\u0026gt; repeat_range].\nRepeat_range is specified for the required number of occurrences of a particular value. Any number of sample points can occur before the first occurrence of the specified value and any number of sample points can occur between each occurrence of the specified value. The transition following the goto repetition must immediately follow the last occurrence of the repetition.\nSyntax:\ncoverpoint_name: cover-point variable {bins bin 1[] = (transition_item[-\u0026gt;repeat_range]); } Example:\nLet\u0026rsquo;s take an example of the goto repetitions bin for better understanding. module goto_repeat_bin; bit [0:3] a; bit [0:2] values[$]= \u0026#39;{1,2,3,4,3,4,2,3,4,5}; covergroup cov_grp; c1 : coverpoint a { bins tran_1 = (1=\u0026gt;4[-\u0026gt;3]=\u0026gt;5); //bins tran_2 = (1=\u0026gt;3[=3]=\u0026gt;4); } endgroup cov_grp cg = new(); initial begin foreach(values[i]) begin a = values[i]; cg.sample(); $display(\u0026#34;val=%d,cov = %.2f %%\u0026#34;,a,cg.get_inst_coverage()); end end endmodule Output snap: The below figure shows the output of the goto repetitions bin. Fig 22: Output Of goto repetitions bin Coverage report Fig 22: Coverage Report Of goto repetitions bin GitHub lab file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/transition_bins/goto_repeat/goto_repeat_bin.sv GitHub log file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/transition_bins/goto_repeat/goto_repeat_bin.log Non-consecutive repetition: The non-consecutive repetition can be specified as \u0026lt;transition_value\u0026gt; [= \u0026lt;repeat_range\u0026gt;]\nSyntax:\ncoverpoint_name: coverpoint variable {bins bin 1 = (transition_value[= \u0026lt; repeat_range \u0026gt;]=\u0026gt; value); } 4. Wildcard bins# The wildcard keyword is used for creating multiple states and transitions. In the expression, X, Z, or ? are considered wildcards for 0 or 1. Wildcard bins can also be defined as transition bins.\nSyntax: wildcard bins p = {4’b11??}; Example:\nLet\u0026rsquo;s take an example of a wildcard bin for better understanding. module wildcard_bin; bit [0:3] a; bit [0:3] values[$]= \u0026#39;{4\u0026#39;b1000,4\u0026#39;b1001,4\u0026#39;b1010,4\u0026#39;b1011}; covergroup cov_grp; c1 : coverpoint a { wildcard bins b1 ={4\u0026#39;b100x}; wildcard bins b2 ={4\u0026#39;b101x}; } endgroup cov_grp cg = new(); initial begin foreach(values[i]) begin a = values[i]; cg.sample(); $display(\u0026#34;val=%d,cov = %.2f %%\u0026#34;,a,cg.get_inst_coverage()); end end endmodule Output snap:\nThe below figure shows the output of the wildcard bin. Fig 23: Output Of wildcard bin coverage report\nFig 23: Coverage Report Of wildcard bin GitHub lab file link :https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/wildcard_bin/wildcard_bin.sv\nGitHub log file link :https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/wildcard_bin/wildcard_bin.log\n5. Ignore bins# A set of values or transitions related to a coverage point can be explicitly excluded from coverage by specifying them as ignore_bins.\nSyntax: ignore_bins ivals = {value1, value3}; ignore_bins itrans = (value1=\u0026gt;value3=\u0026gt;value5); } Example:\nLet\u0026rsquo;s take the example of ignore bin for better understanding. module ignore_bin; bit [0:1] a; bit [0:1] values[$]= \u0026#39;{0,1,2,3}; covergroup cov_grp; c1 : coverpoint a { ignore_bins b1 ={1,2}; } endgroup cov_grp cg = new(); initial begin foreach(values[i]) begin a = values[i]; cg.sample(); $display(\u0026#34;val=%d,cov = %.2f %%\u0026#34;,a,cg.get_inst_coverage()); end end endmodule In the above example, the total possible values for \u0026lsquo;a\u0026rsquo; are 0 to 3. Ignore_bins specified to ignored values 1 and 2. So the Expected values are 0 and 3. Out of these expected values, only 0 and 3 are generated.\nOutput snap: The below figure shows the output of the ignore bin.\nFig 24: Output Of ignore bin. coverage report*\nFig 24: Coverage Report Of ignore bin. In the above example value 1 and value 2 are considered to be ignored that is whenever \u0026lsquo;a\u0026rsquo; hits that value it will take the previous coverage.\nWhen a = 0, covearge of c1 is (1/2)*100= 50% (value 0 is not ignored) When a = 1, covearge of c1 = 50% (value 1 is ignored, it takes previous coverage) When a = 2, covearge of c1 = 50% (value 2 is ignored, it takes previous coverage) When a = 3, covearge of c1 is (2/2)*100= 100% (value 3 is not ignored) GitHub lab file link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/ignore_bin/ignore_bin.sv\nGitHub log file link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/ignore_bin/ignore_bin.log 6. Illegal bins# A set of values or transitions associated with a coverage point can be marked as illegal by specifying them as illegal_bins. All values or transitions associated with illegal bins are excluded from coverage. If an illegal value or transition occurs, a runtime error is issued.\nSyntax: illegal_bins bad_vals = {value1, value3, value4, value6}; illegal_bins bad_trans = (value2=\u0026gt;value1=\u0026gt;value9, value5=\u0026gt;value3); } Example: Let\u0026rsquo;s take an example of an illegal bin for better understanding. module illegal; bit [0:2] y; bit [0:2] values[$]= \u0026#39;{1,6,3,7,3,4,3,5}; covergroup cg; cover_point_y : coverpoint y {illegal_bins b1 = {7}; } endgroup cg cg_inst = new(); initial begin foreach(values[i]) begin y = values[i]; cg_inst.sample(); $display(\u0026#34;val =%d, cov = %0.2f %%\u0026#34;,y,cg_inst.get_inst_coverage()); end end endmodule Output snap: The below figure shows the output of the illegal bin.\nFig 25: Output Of illegal Bin Coverage report Fig 25: Coverage Report Of illegal Bin In the above example value 7 is considered to be illegal, so when value 7 is hit we will get an error as \u0026ldquo;Illegal state bin was hit at value=1\u0026rdquo;.\nGit lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/illegal_bin/illegal_bin.sv Git lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/bins/illegal_bin/illegal_bin.log Coverage Options:# Coverage options control the behavior of the covergroup, coverpoint, and cross. You can specify additional information in the cover group using options. Option method can be specified either for a particular instance or for the entire instances of the program.\n1. at_least : This is one of the important option that can be defined inside a coverpoint. By using option.at_least we can identify the features which have coveraed for particular number of cycles. Default value of at_# Coverage Options:\nCoverage options control the behavior of the covergroleast is \u0026lsquo;1\u0026rsquo;.\nFor example, if there is a variable whose values ranges from 0-7(3-bit), during cover group execution if a particular value is assigned for 2 cycles and rest all are assigned only once. Then use option.at_least=2, which covers the values which have assigned atleast for 2 cycles.\n2. auto_bin_max This option specifies the number of bins that should be created by coverpoint, only when the bins are not defined explicitly. The default value of auto_bin_max is 64. For example, 128 values are generated for any variable(6- bit data) then it will automatically create only 64 bins and for each bin there will be 2 values assigned they are [0:1],[2:3],[4:5],\u0026hellip;\u0026hellip;..[124:125],[126:127]. You can even create 128 bins using option.auto_bin_max = 128.\nFor example, if there is a variable whose values ranges from 0-7(3-bit), during cover group execution there will be 8 bins generated implicitly. But that can be altered and user can set the number the of bins by using option.auto_bin_max. If option.auto_bin_max=2, only 2 bins are created implicitly instead of 8 bins and whose range are [0:3] for auto[0] and [4:7] for auto[1].\n**NOTE :**You can create any number of bins by option.auto_bin_max.\n3. weight : This options specifies the weightage of a particular coverpoint by multiplying the weight value with the cover point percantage. Using this option accounts for overall coverage percentage but not for coverpoint percentage. If we specify option.weight=0 , we are making that cover point percentage to be multiplied with 0, then that coverpoint percentage will be zero.\nBy default the weight of cover point is 1.\nFormula\noverall percentage = (sum of all cover point)/sum of all weights. Where, sum of all cover point refers to addition of all cover points multiplied with its weight. . sum of all weights refer to the addition of weights of all cover points.\nExample:\ncovergroup cgrp; c1: coverpoint s.a {bins b1 = {1}; bins b2 ={3}; option.at_least=2;} c2: coverpoint s.a {option.weight=2;} c3: coverpoint s.b{option.auto_bin_max=2;} endgroup Here in this snippet the cover group options are defined for some particular cover points. option.at_least considers only that values which have covered atleast for 2 cycles , option.weight is defined for cover point c2 which alters the overall coverage by multiplying the coverpoint percent with 2 and option.auto_bin_max is used to generate only 2 bins for the coverpoint c3. The range of first bin is from [0:7] and second bin is [8:15]. In this example, weight of c1 is 1(default_value) , weight of c2 is 2(specified using option) and the weight of c3 is 1(default_value).\noutput snap:\nFig 26: Output of Coverage Options Here variable a can have 8 values that is [0-7] and variable \u0026lsquo;b\u0026rsquo; can have 16 values that is [0-15].Coverage depends on the options used in different coverpoints.\nDuring 1st iteration a=0 and b=8; For cover point c1, values inside bins must be iterated for atleast 2 cycles till now no bin is covered. Hence coverage of c1 is (0/2)100 = 0% ; coverage of c2 is (1/8) = 12.5% {for over all percentage (12.52) i,e 25%}; coverage of c3 is (auto[0]+auto[1])/2 ,therefore {1/2}*100 = 50% ; overall percentage is sum of coverpoints/sum of weigth ,(0+25+50)/4 = 18.75%\nDuring 2nd iteration a=1 and b=6; coverage of c1 is (0/2) = 0% ; coverage of c2 is (2/8) = 25% {for over all percentage (25*2) i,e 50% }; coverage of c3 is (2/2)*100 = 100 % ; overall percentage is (0+50+100)/4= 37.50% .\nDuring 3rd iteration a=1 and b=8; coverage of c1 is (1/2) = 50% ; coverage of c2 is (2/8) = 25% {for over all percentage (25*2) i,e 50% }; coverage of c3 is (2/2)*100 = 100 % ; overall percentage is (50+50+100)/4= 50% .\nDuring 4th iteration a=3 and b=4; coverage of c1 is (1/2) = 50% ; coverage of c2 is (3/8) = 37.5% {for over all percentage (37.5*2) i,e 75% }; coverage of c3 is (2/2)*100 = 100 % ; overall percentage is (50+75+100)/4 = 56.25%\nDuring 5th iteration a=4 and b=4; coverage of c1 is (1/2) = 50% ; coverage of c2 is (4/8) = 50% {for over all percentage (50*2) i,e 100% }; coverage of c3 is (2/2)*100 = 100 % ; overall percentage is (50+100+100)/4 = 62.50%\nCoverage Report\nFig 26: Coverage Report of Coverage Options Github lab code link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/cvgrp_options/options.sv Github log code link https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/functional_coverages/cvgrp_options/options.log "},{
      "id": "33",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/18.assertion/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / Assertion",
      "title": "Assertion",
      "content":"Assertion# Assertions are primarily used to validate the behavior of a design. An assertion is a check embedded in design or bound to a design unit during the simulation. Warnings or errors are generated on the failure of a specific condition or sequence of events.\n\u0026ldquo;The values of variables used in assertions are sampled in the Preponed region of a time slot, and the assertions are evaluated during the Observed region.\u0026rdquo;\nFigure.1.Types of assertion Advantages of using Assertions\nChecks design specifications and reports errors or warnings in case of failure. It improves debugging time. For example, a bug due to an illegal state transition can propagate to the output. Can be used in formal verification. Assertion cheat sheet# sr. no. Assertion 1. Immediate assertion 2. Concurrent assertion 3. SVA Building Blocks 4. SVA Sequence 5. Implication Operator 6. Repetition Operator 7. SVA Built in methods 8. Disable iff \u0026amp; Ended 9. Variable delay in SVA Tabular column.1. Assertion There are two kinds of assertions:\nImmediate Assertions Concurrent Assertions Immediate Assertion# The immediate assertion statement is a test of an expression performed when the statement is executed in the procedural code. If the expression evaluates to X, Z or 0, then it is interpreted as being false and the assertion is said to fail. Otherwise, the expression is interpreted as being true and the assertion is said to pass.\nSyntax:\nlabel: assert(expression) action_block; Example:\ncondition1:assert (A==0 \u0026amp;\u0026amp; B==0) $display(\u0026#34; %0t, A=0 and B=0, assertion failed\u0026#34; ,$time); The action_block is executed immediately after the evaluation of the assert expression. The action_block specifies what actions are taken upon success or failure of the assertion. action_block\nThe pass statement is executed if the expression evaluates to true.\nThe statement associated with else is called a fail statement and is executed if the expression evaluates to false.\nBoth pass and fail statements are optional.\nSince the assertion is a statement that something must be true, the failure of an assertion shall have a severity associated with it. By default, the severity of an assertion failure is an error.\nOther severity levels can be specified by including one of the following severity system tasks in the fail statement:\n$fatal - It generates a run-time fatal assertion error, which terminates the simulation with an error code.\n$error - It is a simple SystemVerilog construct that emits an error severity message.\n$warning - It is a run-time warning, which can be suppressed in a tool-specific manner.\n$info - It indicates that the assertion failure carries no specific severity.\nIf an assertion fails and no else clause is specified, the tool shall, by default call $error. Below are the different forms of immediate assertion syntax with and without optional items\nWith Pass and Fail statement; Fail verbosity info assert(expression) $display(“expression evaluates to true”); else $info(“expression evaluates to false”); Only With Pass statement assert(expression) $display(“expression evaluates to true”); With Pass and Fail statement; Fail verbosity fatal assert(expression) $display(“expression evaluates to true”); else $fatal(“expression evaluates to false”); Only With Fail statement; Multiple statements in Faile condition and Fail verbosity fatal assert(expression) else begin ……. ……. $fatal(“expression evaluates to false”); end Only With Fail statement; Fail verbosity warning assert(expression) else $warning(“expression evaluates to false”); With Label and Fail statement; Fail verbosity warning label: assert(expression) else $warning(“expression evaluates to false”); Example:\ncode snippet\nalways @(posedge clk) begin assert (A==0 \u0026amp;\u0026amp; B==0) $display(\u0026#34;%0t, A=0 and B=0, assertion failed\\n\u0026#34;,$time); else assert (A==0 \u0026amp;\u0026amp; B==1) $display(\u0026#34;%0t, A=0 and B=1, assertion failed\\n\u0026#34;,$time); else assert (A==1 \u0026amp;\u0026amp; B==0) $display(\u0026#34;%0t, A=1 and B=0, assertion failed\\n\u0026#34;,$time); else assert (A==1 \u0026amp;\u0026amp; B==1) $display(\u0026#34;%0t, A=1 and B=1,assertion Success\\n\u0026#34;,$time); else $display(\u0026#34;%0t fail\\n\u0026#34;,$time); end Below figure shows the Output of Immediate assertion\nFigure.2.Immediate assertion output Here there are four conditions, i.e 00,01,10,11 and the condition will be success when A and B both are high, so at that condition assertion is success and for other condition it is considered as failure.\nGithub lab code link:https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/assertion/immediate_assertion\nGithub lab output link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/immediate_assertion/assertion.log\nConcurrent Assertion# An assertion that checks the sequence of events spread over multiple clock cycles is called a concurrent assertion. They execute in parallel with other always blocks concurrently, hence it is known as a concurrent assertion. Unlike immediate assertion, the concurrent assertion is evaluated only at clock tick. Thus, it is a clock-based evaluation model and an expression used in the concurrent assertion is always tied to a clock definition. The Keyword differentiates the immediate assertion from the concurrent assertion is “property.” Following are the steps to create assertions:\nSVA Building block# Step 1: Create Boolean expressions\nStep 2: Create sequence expressions\nStep 3: Create property\nStep 4: Assert property\nFigure.3.Steps to create assertion 1.Boolean expressions\nThe functionality is represented by the combination of multiple logical events. These events could be simple Boolean expressions.\n2.Sequence\nIn any design model, the functionality is represented by the combination of multiple logical events. These events could be simple Boolean expression that get evaluated on the same clock edge or could be events that evaluate over a period of time involving multiple clock cycles. Systemverilog asserion provides a key word to represent these events called \u0026ldquo;sequence\u0026rdquo;. The basic syntax of a sequence is given below, Syntax\nsequence name_of_sequence; \u0026lt;test expression\u0026gt; endsequence 3.Property\nA number of sequences can be combined logically or sequentially to create more complex sequences. Systemverilog asserion provides a keyword to represent these complex sequential behaviors called “property”. Syntax\nproperty name_of_property; \u0026lt;test expression\u0026gt; or \u0026lt;complex sequence expressions\u0026gt; endproperty 4.Assert\nThe property is the one that is verified during a simulation. It has to be asserted to take effect during a simulation. SVA provides a keyword called “assert” to check the property.\nSyntax\nassertion_ name: assert property( property_name ); Example:\ncode snippet\nsequence seq; @(posedge clk) (A==1 \u0026amp;\u0026amp; B==1); endsequence property ppt; seq; endproperty assert property (ppt) $display(\u0026#34; %0t, A=1 and B=1, assertion success\u0026#34;,$time); else $display(\u0026#34;%0t, A=%0b and B=%0b,assertion failure\u0026#34;, $time,A,B); Below figure shows the Output of Concurrent assertion\nFigure.4.Concurrent assertion output Here there are four conditions, i.e 00,01,10,11 and the condition will be success when A and B both are high, so at that condition, assertion is success and for other condition it is considered as failure.\nGitHub lab code link:https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/assertion/concurrent_assertion\nGitHub lab output link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/concurrent_assertion/assertion.log\nSVA(System Verilog Assertion) Sequence# The expressions expand over more than one clock cycle is called a sequence. Sequences are build over SystemVerilog boolean expressions. If an expression checks properly, then the sequence is to be matched. The expressions evaluate over a period of time that may involve one or more clock cycles.\nA property may involve checking of one or more sequential behaviours beginning at various times. An attempted evaluation of a sequence is a search for a match of the sequence beginning at a particular clock tick. To determine whether such a match exists, appropriate Boolean expressions are evaluated beginning at the particular clock tick and continuing at each successive clock tick until either a match is found or it is deduced that no match can exist.\nSyntax\nsequence \u0026lt;sequence_name\u0026gt;; \u0026lt;test expression\u0026gt;; endsequence Fig 5: SVA Sequence sr. no. Sequence 1. Timing Relationship 2. Logical Relationship 3. Multiple Sequences 4. Formal Argument 1.The sequence with timing relationship\n2.The sequence with a logical expression\n3.Multiple sequences\n4.The sequence with Formal Argument\n1.The Sequence with Timing Relationship# In SVA, clock cycle delays are represented by x “##” sign. For example, ##5 means 5 clock cycles.\nSyntax:\nsequence seq_name; variable_1 ##\u0026lt;delay_value\u0026gt; variable_2 ; endsequence code snippet:\nsequence seqA; x ##5 y ; endsequence property prop; @(posedge clk) seqA; endproperty time_a1:assert property(prop) $info(\u0026#34;assertion passed\u0026#34;); else $error(\u0026#34;assertion failed\u0026#34;); Below sequence checks for the signal “x” being high on a given positive edge of the clock. If signal “x” is high on any given positive edge of the clock and signal “y” should be high after 5 clock cycles . The assertion passed , otherwise assertion fails.\n2.The sequence with a logical expression# Syntax:\nsequence seq_name; variable_1 \u0026lt;logical_operator\u0026gt; variable_2; endsequence code Snippet:\nsequence seqB; x \u0026amp;\u0026amp; y; endsequence property prop; @(posedge clk) seqB; endproperty time_a1:assert property(prop) $info(\u0026#34;assertion passed\u0026#34;); else $error(\u0026#34;assertion failed\u0026#34;); The above sequence, seqB checks that on every positive edge of the clock, both signals “X” and “Y” are high, then assertion will pass. If one of the signals are low, the assertion will fail.\n3.Multiple sequences# Multiple sequences are evaluating and checking two or more sequences using operators, delay, clock etc\u0026hellip;\nHere, two sequences \u0026lsquo;seqA\u0026rsquo; and \u0026lsquo;seqB\u0026rsquo; are shown below:\ncode snippet:\nsequence seqA; x ##5 y ; endsequence sequence seqB; x \u0026amp;\u0026amp; y; endsequence property prop; @(posedge clk) seqA |-\u0026gt; seqB; endproperty time_a1:assert property(prop) $info(\u0026#34;assertion passed\u0026#34;); else $error(\u0026#34;assertion failed\u0026#34;); In seqA, x ##5 y shows the timimg relationship between \u0026lsquo;x\u0026rsquo; and \u0026lsquo;y\u0026rsquo; having five clock ticks. In seqB, x \u0026amp;\u0026amp; y shows logical relationship between \u0026lsquo;x\u0026rsquo; and \u0026lsquo;y\u0026rsquo; having logical AND operator. Inside property(prop), we use overlapped implication operator (|-\u0026gt;) to evaluate the two sequences. In seqA, if x is high, then after 5 clock ticks , the y will be evaluated and it should be high. In seqB, if x and y are both high ,then the seqB is evaluated . Inside the property \u0026lsquo;seqA |-\u0026gt; seqB \u0026rsquo; which indicates if seqA is true, the seqB will be evaluated at the same cycle using overlapped implication operator .If it is true, the assertion will be passed otherwise it fails. output\nThe figure below shows that the output of sequence in assertions.\nFig 6: Sequence output Waveform\nFig 7: Sequence Waveform Explanation\nIn concurrent assertions, the assertions are evaluated only at the clock posedge. And effect of input conditions only reflect at the next posedge. The output shows that in seqA, x=1 at 30ns and after 5 clock cycles, y=1 at 50ns.In seqB, both x and y are high after 50ns. The assertions will be passed after 50ns to 62ns.\nGithub code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/sequence/sequence.sv Github output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/sequence/sequence.log 4.The sequence with Formal Argument# Sequences can have formal arguments in order to make sequences reusable. Formal argument can be represented by two types:\nTyped ( With Datatypes) Untyped (Without datatypes) Code Snippet:\nsequence notype_seq (X,Y); X \u0026amp;\u0026amp; Y; endsequence sequence withtype_seq (bit X, bit Y); X \u0026amp;\u0026amp; Y; endsequence property a_b_notype_prop(a,b); @ (posedge clk) a |-\u0026gt; notype_seq(a,b); endproperty property c_d_type_prop(bit c, bit d); @ (posedge clk) c |-\u0026gt; withtype_seq(c,d); endproperty a_b_notype_assert : assert property (a_b_notype_prop(a,b)) $info(\u0026#34;assertion passed\u0026#34;); else $error(\u0026#34;assertion failed\u0026#34;); c_d_type_assert : assert property (c_d_type_prop(c,d)) $info(\u0026#34;assertion passed\u0026#34;); else $error(\u0026#34;assertion failed\u0026#34;); Explanation\nThe formal argument in SV Assertions example is shown above. In sequence_1 with using untyped formal argument, they were declared variables without data types. In sequence_2, using typed formal argument includes variables with datatypes eg:(bit X, bit Y).Using overlapping implication operator, two property blocks works under initial condition. Using assert property the input conditions were evaluated.\nIn the assertion_1 and assertion_2 if both argument is 1 then assertion is pass otherwise fail because in the both sequence we perform And operation.\nIn the a_b_notype_property if a=1 and in the c_d_type_property if c=1 then check notype sequence and withtype sequence.\nOutput\nFig 8: Formal_argument Output Waveform\nFig 9: Output Waveform Explanation\nAt 25ns a=1 so it will check notype_seq and there a=1 and b=0 so at 25ns a_b_notype_assert is failed and c=0 so it will not check withtype_seq.\nAt 35ns a=1 so it will check notype_seq and there a=1 and b=1 so at 35ns a_b_notype_assert is passed and c=1 so it will check nontype_seq and there c=1 and d=1 so at 35ns c_d_type_assert is passed\nAt 45ns a=1 so it will check notype_seq and there a=1 and b=0 so at 45ns a_b_notype_assert is failed and c=1 so it will check nontype_seq and there c=1 and d=1 so at 45ns c_d_type_assert is passed\nAt 55ns a=1 so it will check notype_seq and there a=1 and b=1 so at 55ns a_b_notype_assert is passed and c=1 so it will check nontype_seq and there c=1 and d=0 so at 55ns c_d_type_assert is failed\nGithub code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/formal_argument/formal_argument.sv Github output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/formal_argument/formal_argument.log Variable Delay in sequence# static delay The static delay means that using \u0026rsquo; ## \u0026rsquo; operator inside the the sequence. It is same as the sequence with timing relationship.\nSyntax:\nvariable_1 ## delay_value variable_2; Example:\na ##5 b; Variable delay The variable delay works as loops. It is the main advantage over static delay.\nparameter_delay = 2; sequence delay_sequence(variable_delay); int delay; (1,delay=variable_delay) ##0 first_match((1,delay=delay-1) [*0:$] ##0 delay \u0026lt;=0); endsequence a_1: assert property(@(posedge clk) a |-\u0026gt; delay_sequence(parameter_delay) |-\u0026gt; b) $info(\u0026#34;assertion passed\u0026#34;); else $error(\u0026#34;assertion failed\u0026#34;); Explanation\nThe above program shows the example of variable delay in assertions. Inside the program we assign parameter delay as \u0026lsquo;2\u0026rsquo;. This parameter_delay is copied to variable_delay, the variable value will be decremented on each clk cycle and checks for the value of ‘delay’ equals to ‘0’ . The sequence delay_sequence has a variable parameter_delay which is passed from the property. That is actually assigned to variable_delay, which is in turn assigned to the local variable delay.\n\u0026lsquo;*0\u0026rsquo; is called an empty match. For example a[*0:$] |-\u0026gt; b means a [*0] or a [*1] or a [*2] .. a [$]\nTo avoid unexpected behaviours because of multiple matches or cause an assertion to never succeed because all threads of antecedent must be tested for property to succeed. The \u0026lsquo;first_match\u0026rsquo; operator matches only the first of possibly multiple matches for an evaluation attempt and causes all the subsequent matches to be discarded.\nOutput\nFig 10: Output Waveform Waveform\nparameter delay -2 Fig 11: Variable_delay Waveform Explanation\nThe output shows that, inside the program we assign parameter delay as \u0026lsquo;2\u0026rsquo;. First we take a = 1 at 5ns,after 2 clock cycles at 15ns b is not high. So the assertion is failed. Between 15ns to 25ns, a and b are same and assertion will not taken because \u0026lsquo;first match\u0026rsquo; avoids duplication. Between 25ns to 35ns,the effect of input a and b is high, so it will pass the assertion. In addition to, between 45ns to 55ns the assertion is passed.\nGithub code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/variable_delay/variable_delay.sv Github output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/variable_delay/variable_delay.log Implication Operator# If we want the sequence to be checked only after “a” is high, this can be achieved by using the implication operator. The implication is equivalent to an if-then structure.\nThe left-hand side of the implication is called the “antecedent” and the right-hand side is called the “consequent.”\nIt can be used only with property definitions not used with sequences.\nThere are two types of implication operators:\nOverlapped implication (|-\u0026gt;) Non-overlapped implication (|=\u0026gt;) Fig.12 Implication Operators in Assertions 1.Overlapped Implication# It is denoted by |-\u0026gt;. If there is a match on the antecedent, then the consequent expression is evaluated in the same clock cycle. Syntax:-\n\u0026lt;Antecedent\u0026gt; |-\u0026gt; \u0026lt;Consequent\u0026gt; Example:-\nproperty p; @(posedge clk) a |-\u0026gt; b; endproperty a: assert property(p); In the above example when \u0026ldquo;a\u0026rdquo; is high on the positive edge of clock cycle then \u0026ldquo;b\u0026rdquo; will be evaluated and based on that assertion will be passed or fail.\nFig.13 Overlapped Implication Code snippet:\nmodule overlapped_assertion; bit clk,a,b,valid; always #5 clk = ~clk; //clock generation //generating \u0026#39;a\u0026#39; initial begin valid=1; a=1; b=1; #15 a=1; b=0; #10 b=1; #12 b=0; #10 a=0; b=1; valid=0; #15 a=1; b=0; #100 $finish; end // property definition property p; @(posedge clk) valid |-\u0026gt; (a ##3 b); endproperty //calling assert property a_1: assert property(p) $info(\u0026#34;pass\u0026#34;); else $info(\u0026#34;fail\u0026#34;); endmodule Output:\nThe below figure will shows the overlapped implication output. here, at 5ns first posedge comes and at that point valid and a both are high so it will check for b after 3 clock cycles at 35ns b is high so assertion passed if b is not high at that point then assertion is fail and this same process will be followed for other posedges till $finish is called.\nFig.14 Output of overlapped implication Output Waveform:\nFig.15 Overlapped Waveform Github lab code link:- https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/assertion/implication_operator/overlapped_implication Github lab output link:- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/implication_operator/overlapped_implication/overlapped.log Overlapped Implication Types:# The implication with a fixed delay on the consequent# Below property checks that, if signal “a” is high on a given positive clock edge, then signal “b” should be high after 2 clock cycles. Fixed delay can be denoted as ##n here n will specify the time. Syntax:-\n\u0026lt;Antecedent\u0026gt; |-\u0026gt; ##\u0026lt;value\u0026gt; \u0026lt;Consequent\u0026gt; Example:-\nproperty p; @(posedge clk) a |-\u0026gt; ##2 b; endproperty a: assert property(p); Fig.16 Fixed Delay The implication with a sequence as an antecedent# Below property checks that, if the sequence seq_1 is true on a given positive edge of the clock, then start checking the seq_2 (“d” should be low, 2 clock cycles after seq_1 is true). Syntax:-\n\u0026lt;Sequence1\u0026gt; |-\u0026gt; \u0026lt;Sequence2\u0026gt; Example:-\nsequence seq_1; (a \u0026amp;\u0026amp; b) ##1 c; endsequence sequence seq_2; ##2 !d; endsequence property p; @(posedge clk) seq_1 |-\u0026gt; seq_2; endpeoperty a: assert property(p); Timing windows in SVA Checkers# Below property checks that, if signal “a” is high on a given positive clock edge, then within 1 to 3 clock cycles, the signal “b” should be high. Syntax\n\u0026lt;Antecedent\u0026gt; |-\u0026gt; ##[1:\u0026lt;value\u0026gt;] \u0026lt;Consequent\u0026gt; Example:-\nproperty p; @(posedge clk) a |-\u0026gt; ##[1:3] b; endproperty a: assert property(p); Fig.17 Timing Window Overlapping timing window# Below property checks that, if signal “a” is high on a given positive clock edge, then signal “b” should be high in the same clock cycle or within 4 clock cycles. Syntax:-\n\u0026lt;Antecedent\u0026gt; |-\u0026gt; ##[0:\u0026lt;value\u0026gt;] \u0026lt;Consequent\u0026gt; Example:-\nproperty p; @(posedge clk) a |-\u0026gt; ##[0:3] b; endproperty a: assert property(p); Fig.18 Overlapping Timing Window Indefinite timing window# The upper limit of the timing window specified in the right-hand side can be defined with a “$” sign which implies that there is no upper bound for timing. This is called the “eventuality” operator. The checker will keep checking for a match until the end of the simulation. Below property checks that, if signal “a” is high on a given positive clock edge, then signal “b” will be high eventually starting from the next clock cycle. Syntax:-\n\u0026lt;Antecedent\u0026gt; |-\u0026gt; ##[1:$] \u0026lt;Consequent\u0026gt; Example:-\nproperty p; @(posedge clk) a |-\u0026gt; ##[1:$] b; endproperty a: assert property(p); Fig.19 Indefinite Timing Window 2.Non-overlapped Implication:# The non-overlapped implication is denoted by the symbol |=\u0026gt;. If there is a match on the antecedent, then the consequent expression is evaluated in the next clock cycle. Syntax:-\n\u0026lt;Antecedent\u0026gt; |=\u0026gt; \u0026lt;Consequent\u0026gt; Example :-\nproperty p; @(posedge clk) a |=\u0026gt;b; endproperty a: assert property( p ); In the above example if signal “a” is high on a given positive clock edge, then signal “b” should be high on the next clock edge.\nFig.20 Non-Overlapped Implication Code snippet:\nmodule nonoverlapped_assertion; bit clk,a,b,valid; always #5 clk = ~clk; //clock generation //generating \u0026#39;a\u0026#39; initial begin valid=1; a=1; b=1; #15 a=1; b=0; #10 b=1; #12 b=0; #10 a=0; b=1; valid=0; #15 a=1; b=0; #100 $finish; end // property definition property p; @(posedge clk) valid |=\u0026gt; (a ##3 b); endproperty //calling assert property a_1: assert property(p) $info(\u0026#34;pass\u0026#34;); else $info(\u0026#34;fail\u0026#34;); endmodule Output:\nThe below figure will shows the nonoverlapped implication output. here, at 5ns first posedge comes and at that point valid is high after one clock cycle at 15ns a is high so it will check for b after 3 clock cycles at 45ns b is low so assertion failed if b is high at that point assertion is pass and this same process will be followed for other posedges till $finish is called.\nFig.21 Output of nonoverlapped implication Output Waveform:\nFig.22 Nonoverlapped Waveform Github lab code link:- https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/assertion/implication_operator/nonoverlapped_implication Github lab output link:- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/implication_operator/nonoverlapped_implication/nonoverlapped.log Repetition Operators:# Figure.23 Types of repetition operator Consecutive repetition# property p; @(posedge clk) a |-\u0026gt; ##1 b ##1 b ##1 b; endproperty a: assert property(p); The above property checks that, if the signal “a” is high on given posedge of the clock, the signal “b” should be high for 3 consecutive clock cycles.\nThe Consecutive repetition operator is used to specify that a signal or a sequence will match continuously for the number of clocks specified.\nSyntax:\nsignal [*n] or sequence [*n] \u0026ldquo;n\u0026rdquo; is the number of repetitions.\nwith repetition operator above sequence can be re-written as,\nproperty p; @(posedge clk) a |-\u0026gt; ##1 b[*3] ##1 c; endproperty a: assert property(p); Example:\nmodule consecutive_repetition; bit clk,a,b; always #5 clk = ~clk; //clock generation initial begin a=0; b=0; #15 a=1; b=0; //15 #10 a=0; b=1; //25 #10 a=0; b=1; //35 #10 a=0; b=1; //45 #10 a=1; b=1; //55 #10 a=0; b=1; //65 #10 a=0; b=1; //75 #10 a=0; b=0; //85 #10 a=1; b=0; //95 #10 a=0; b=0; //105 #10 a=1; b=1; //115 #10 a=0; b=1; //125 #10 a=0; b=1; //135 #10 a=0; b=0; //145 #10 a=0; b=0; //155 #10; $finish; end //property definition property p; @(posedge clk) a |-\u0026gt; ##1 b[*3]; endproperty //calling assert property a_1: assert property(p) $info(\u0026#34;Pass\u0026#34;); else $info(\u0026#34;Fail\u0026#34;); endmodule Output:\nIn below figure,At 25ns a=1, and after 1 clock-cycle(##1) b =1 for 3 consecutive clock cycle.Hence, $info displayed as pass at 55ns. At 65ns a=1, but after 1 clock-cycle b=1 for only 2 cosecutive times. Hence $info displayed fail at 95ns. At 105ns a=1, but b=0 after 1 clock-cycle.Hence $info displayed pass at 115ns.\nFigure.24 Consecutive repetition operator output Waveform Output:\nFigure.25 Consecutive repetition waveform output Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/assertion/repetition_operators/consecutive_repetition Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/repetition_operators/consecutive_repetition/consecutive_repetition.log go to repetition# The go-to repetition operator is used to specify that a signal will match the number of times specified not necessarily on continuous clock cycles.\nSyntax:\nsignal [-\u0026gt;n] property p; @(posedge clk) a |-\u0026gt; ##1 b[-\u0026gt;3] ##1 c; endproperty a: assert property(p); The above property checks that, if the signal “a” is high on given posedge of the clock, the signal “b” should be high for 3 clock cycles followed by “c” should be high after ”b” is high for the third time.\nExample:\nmodule goto_repetition; bit clk,a,b,c; always #5 clk = ~clk; //clock generation initial begin a=0; b=0; #15 a=1; b=0; c=0; //15 #10 a=0; b=1; c=0; //25 #10 a=0; b=1; c=0; //35 #10 a=0; b=0; c=0; //45 #10 a=0; b=1; c=0; //55 #10 a=0; b=0; c=0; //65 #10 a=0; b=0; c=0; //75 #10 a=1; b=0; c=0; //85 #10 a=0; b=1; c=0; //95 #10 a=0; b=0; c=0; //105 #10 a=0; b=1; c=0; //115 #10 a=0; b=0; c=0; //125 #10 a=0; b=1; c=0; //135 #10 a=0; b=0; c=1; //145 #10 a=0; b=0; c=0; //155 #10; $finish; end //property definition property p; @(posedge clk) a |-\u0026gt; b[-\u0026gt;3] ##1 c; endproperty //calling assert property a_1: assert property(p) $info(\u0026#34;Pass\u0026#34;); else $info(\u0026#34;Fail\u0026#34;); endmodule Output:\nIn below figure, at 25ns a=1, b can be 1 on any clock-cycle for 3 times, not necesserily on consecutive clock-cycle and c=1 after 1 clock-cycle follwed by b, but c=0 at 75ns. Hence, $info displayed fail at 75ns. At 95ns a=1, and b=1 for 3 times then c=1 after 1 clock-cycle(##1) i.e at 155ns. Hence, $info displayed pass at 155ns.\nFigure.26 go to repetition operator output Waveform Output:\nFigure.27 go to repetition waveform output Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/assertion/repetition_operators/goto_repetition Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/repetition_operators/goto_repetition/goto_repetition.log Nonconsecutive repetition# This is very similar to “go to” repetition except that it does not require that the last match on the signal repetition happens in the clock cycle before the end of the entire sequence matching.\nSyntax:\nsignal [=n] Only expressions are allowed to repeat in “go to” and “nonconsecutive” repetitions. Sequences are not allowed.\nExample:\nmodule nonconsecutive_repetition; bit clk,a,b,c; always #5 clk = ~clk; //clock generation initial begin a=0; b=0; #15 a=1; b=0; c=0; //15 #10 a=0; b=1; c=0; //25 #10 a=0; b=1; c=0; //35 #10 a=0; b=0; c=0; //45 #10 a=0; b=1; c=0; //55 #10 a=0; b=0; c=0; //65 #10 a=0; b=0; c=1; //75 #10 a=0; b=0; c=0; //85 #10 a=1; b=1; c=0; //95 #10 a=0; b=0; c=0; //105 #10 a=0; b=1; c=0; //115 #10 a=0; b=0; c=0; //125 #10 a=0; b=1; c=0; //135 #10 a=0; b=0; c=1; //145 #10 a=0; b=0; c=0; //155 #10; $finish; end //property definition property p; @(posedge clk) a |-\u0026gt; b[=3] ##1 c; endproperty //calling assert property a_1: assert property(p) $info(\u0026#34;Pass\u0026#34;); else $info(\u0026#34;Fail\u0026#34;); endmodule Output:\nIn below figure, at 25ns a=1, b=1 for 3rd time at 65ns(not necessarily on consecutive clock-cycle) and c can be 1 at any clock-cycle after 1 clock-cycle(##1) delay.Hence, $info displayed Pass at 85ns. At 105ns a=1 and b=1 for 3rd time at 145ns and c=1 at 155ns.Hence $info displayed Pass at 155ns.\nFigure.28 nonconsecutive repetition operator output Waveform Output:\nFigure.29 nonconsecutive repetition waveform output Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/assertion/repetition_operators/nonconsecutive_repetition Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/repetition_operators/nonconsecutive_repetition/nonconsecutive_repetition.log SVA Methods# Figure.30 Types of SVA Methods $rose# Syntax:\n$rose(boolean expression or signal name) returns true if the least significant bit of the expression changed to 1. Otherwise, it returns false.\nproperty p; @(posedge clk) $rose(a) endproperty property p checks that the signal “a” transitions to a value of 1 on every positive edge of the clock. If the transition does not occur, the assertion will fail.\nExample:\nmodule rose; bit clk,a,b; always #5 clk = ~clk; //clock generation initial begin a=0; b=0; #15 a=1; b=0; //15 #10 a=0; b=0; //25 #10 a=1; b=1; //35 #10 a=0; b=0; //45 #10 a=1; b=1; //55 #10 a=0; b=0; //65 #10 a=1; b=1; //75 #10 a=1; b=1; //85 #10 a=1; b=0; //95 #10 a=0; b=0; //105 #10 a=1; b=0; //115 #10 a=0; b=0; //125 #10 a=1; b=0; //135 #10 a=1; b=0; //145 #10; $finish; end //property definition property p; @(posedge clk) a |-\u0026gt; $rose(b); endproperty //calling assert property a_1: assert property(p) $info(\u0026#34;Pass\u0026#34;); else $info(\u0026#34;Fail\u0026#34;); endmodule Output:\nIn below figure, a=1 at 25ns but b=0 as it was before.Hence, $info displayed Fail at 25ns. At 45ns a=1 and b transitioned to 1 (previously b=0 at 35ns, it will check previous cycle). Hence, $info displayed Pass at 45ns. At 65ns a=1 and b transitioned to 1 (previously b=0 at 55ns). Hence, $info displayed Pass at 65ns. At 95ns a=1 but b stable 1 its not transitioned. Hence, $info displayed failed at 95ns.\nFigure.31 $rose method output Waveform Output:\nFigure.32 $rose waveform output Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/assertion/SVA_Methods/rose Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/SVA_Methods/rose/rose.log $fell# Syntax:\n$fell(boolean expression or signal name) returns true if the least significant bit of the expression changed to 0. Otherwise, it returns false.\nproperty p; @(posedge clk) $fell(a); endproperty property p checks that the signal “a” transitions to a value of 0 on every positive edge of the clock. If the transition does not occur, the assertion will fail.\nExample:\nmodule fell; bit clk,a,b; always #5 clk = ~clk; //clock generation initial begin a=0; b=0; #15 a=1; b=0; //15 #10 a=0; b=1; //25 #10 a=1; b=0; //35 #10 a=0; b=0; //45 #10 a=1; b=1; //55 #10 a=0; b=0; //65 #10 a=1; b=1; //75 #10 a=1; b=0; //85 #10 a=1; b=0; //95 #10 a=0; b=0; //105 #10 a=1; b=0; //115 #10 a=0; b=0; //125 #10 a=1; b=0; //135 #10 a=1; b=0; //145 #10; $finish; end //property definition property p; @(posedge clk) a |-\u0026gt; $fell(b); endproperty //calling assert property a_1: assert property(p) $info(\u0026#34;Pass\u0026#34;); else $info(\u0026#34;Fail\u0026#34;); endmodule Output:\nIn below figure, a=1 at 25ns but b=0 its stable(check previous cycle at 15ns b=0) it is not transitioned.Hence $info displayed as Fail at 25ns. At 45ns a=1 and b transitioned from 1 to 0 (previously b=1 at 35ns).Hence, $info displayed as Pass at 45ns.\nFigure.33 $fell method output Waveform Output:\nFigure.34 $fell waveform output Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/assertion/SVA_Methods/fell Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/SVA_Methods/fell/fell.log $stable# Syntax:\n$stable(boolean expression or signal name) returns true if the value of the expression did not change. Otherwise, it returns false.\nproperty p; @(posedge clk) $stable(a); endproperty property p checks that the signal “a” is stable on every positive edge of the clock. If there is any transition occurs, the assertion will fail\nExample:\nmodule stable; bit clk,a,b; always #5 clk = ~clk; //clock generation initial begin a=0; b=0; #15 a=1; b=0; //15 #10 a=0; b=0; //25 #10 a=1; b=1; //35 #10 a=0; b=0; //45 #10 a=1; b=1; //55 #10 a=0; b=0; //65 #10 a=1; b=1; //75 #10 a=1; b=1; //85 #10 a=1; b=0; //95 #10 a=0; b=0; //105 #10 a=1; b=0; //115 #10 a=0; b=1; //125 #10 a=1; b=0; //135 #10 a=1; b=0; //145 #10; $finish; end //property definition property p; @(posedge clk) a |-\u0026gt; $stable(b); endproperty //calling assert property a_1: assert property(p) $info(\u0026#34;Pass\u0026#34;); else $info(\u0026#34;Fail\u0026#34;); endmodule Output:\nIn below figure, a=1 at 25ns and b=0 as it was in previous cycle, it is stable.Hence, $info displayed Pass at 25ns. At 45ns a=1 but b transitioned from 0 to 1.Hence, $info displayed as Fail at 45ns.\nFigure.35 $stable method output Waveform Output:\nFigure.36 $stable waveform output Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/assertion/SVA_Methods/stable Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/SVA_Methods/stable/stable.log $past# Syntax:\n$past(signal_name, number of clock cycles) provides the value of the signal from the previous clock cycle.\nBelow Property checks that, in the given positive clock edge, if the “b” is high, then 2 cycles before that, a was high.\nproperty p; @(posedge clk) b |-\u0026gt; ($past(a,2) == 1); endproperty a: assert property(p); Example:\nmodule past; bit clk,a,b; always #5 clk = ~clk; //clock generation initial begin a=0; b=0; #15 a=1; b=1; //15 #10 a=0; b=0; //25 #10 a=1; b=1; //35 #10 a=0; b=0; //45 #10 a=1; b=1; //55 #10 a=0; b=0; //65 #10 a=1; b=1; //75 #10 a=1; b=1; //85 #10 a=1; b=0; //95 #10 a=0; b=0; //105 #10 a=1; b=0; //115 #10 a=0; b=0; //125 #10 a=1; b=0; //135 #10 a=1; b=0; //145 #10; $finish; end //property definition property p; @(posedge clk) a |-\u0026gt; ($past(b,2) == 1); endproperty //calling assert property a_1: assert property(p) $info(\u0026#34;Pass\u0026#34;); else $info(\u0026#34;Fail\u0026#34;); endmodule Output:\nIn below figure, a=1 at 25ns,but b was not 1 in 2 clock-cycles before that. Hence, $info displayed as Fail at 25ns. At 45ns a=1 and 2 clock-cycles before that b=1 i.e at 25ns. Hence, $info displayed Pass at 45.\nFigure.37 $past method output Waveform Output:\nFigure.38 $past waveform output Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/assertion/SVA_Methods/past Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/SVA_Methods/past/past.log Built-in system functions# $onehot(expression)# checks that only one bit of the expression can be high on any given clock edge. Syntax:\na_1: assert property( @(posedge clk) $onehot(state) ); Assert statement a_1 checks that the bit vector “state” is one-hot.\nExample:\nmodule onehot; bit clk,a; logic [4:0] b; always #5 clk = ~clk; //clock generation initial begin a=0; b=5\u0026#39;b00000; #15 a=1; b=5\u0026#39;b00100; //15 #10 a=0; b=5\u0026#39;b01000; //25 #10 a=1; b=5\u0026#39;b01000; //35 #10 a=0; b=5\u0026#39;b01000; //45 #10 a=1; b=5\u0026#39;b10000; //55 #10 a=0; b=5\u0026#39;b10000; //65 #10 a=1; b=5\u0026#39;b11000; //75 #10 a=0; b=5\u0026#39;b01100; //85 #10 a=1; b=5\u0026#39;b01100; //95 #10 a=0; b=5\u0026#39;b01000; //105 #10 a=1; b=5\u0026#39;b11100; //115 #10 a=0; b=5\u0026#39;b01000; //125 #10 a=1; b=5\u0026#39;b00000; //135 #10 a=1; b=5\u0026#39;b00100; //145 #10; $finish; end //property definition property p; @(posedge clk) a |-\u0026gt; $onehot(b); endproperty //calling assert property a_1: assert property(p) $info(\u0026#34;Pass\u0026#34;); else $info(\u0026#34;Fail\u0026#34;); endmodule Output:\nIn below figure, a=1 at 25ns and only one bit of b is high(i.e b=00100). Hence, $info displayed Pass at 25ns. At 85ns a=1 but two bits of b are high(i.e b=11000). Hence, $info displayed as Fail at 85ns.\nFigure.39 $onehot method output Waveform Output:\nFigure.40 $onehot waveform output Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/assertion/SVA_Methods/onehot Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/SVA_Methods/onehot/onehot.log $onehot0(expression)# checks only one bit of the expression can be high or none of the bits can be high on any given clock edge. Syntax:\na_1: assert property( @(posedge clk) $onehot0(state) ); Assert statement a_1 checks that the bit vector “state” is zero one-hot.\nExample:\nmodule onehot0; bit clk,a; logic [4:0] b; always #5 clk = ~clk; //clock generation initial begin a=0; b=5\u0026#39;b00000; #15 a=1; b=5\u0026#39;b00100; //15 #10 a=0; b=5\u0026#39;b01000; //25 #10 a=1; b=5\u0026#39;b01000; //35 #10 a=0; b=5\u0026#39;b01000; //45 #10 a=1; b=5\u0026#39;b10000; //55 #10 a=0; b=5\u0026#39;b10000; //65 #10 a=1; b=5\u0026#39;b11000; //75 #10 a=0; b=5\u0026#39;b01100; //85 #10 a=1; b=5\u0026#39;b01100; //95 #10 a=0; b=5\u0026#39;b01000; //105 #10 a=1; b=5\u0026#39;b11100; //115 #10 a=0; b=5\u0026#39;b01000; //125 #10 a=1; b=5\u0026#39;b00000; //135 #10 a=1; b=5\u0026#39;b00100; //145 #10; $finish; end //property definition property p; @(posedge clk) a |-\u0026gt; $onehot0(b); endproperty //calling assert property a_1: assert property(p) $info(\u0026#34;Pass\u0026#34;); else $info(\u0026#34;Fail\u0026#34;); endmodule Output:\nIn below figure, a=1 at 25ns and only one bit of b is high (which is allowed in $onehot0). Hence, $info displayed Pass at 25ns. At 85ns a=1 but two bits of b are high, i.e b=11000 (which is not allowed in $onehot0). Hnece, $info displayed as Fail at 85ns.\nFigure.41 $onehot0 method output Waveform Output:\nFigure.42 $onehot0 waveform output Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/assertion/SVA_Methods/onehot0 Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/SVA_Methods/onehot0/onehot0.log $isunknown(expression)# checks if any bit of the expression is X or Z. Syntax:\na_1: assert property( @(posedge clk) $isunknown(bus) ) ; Assert statement a_1 checks if any bit of the vector “bus” is X or Z.\nExample:\nmodule isunknown; bit clk,a; logic [4:0] b; always #5 clk = ~clk; //clock generation initial begin a=0; b=5\u0026#39;b00000; #15 a=1; b=5\u0026#39;b001x0; //15 #10 a=0; b=5\u0026#39;b01000; //25 #10 a=1; b=5\u0026#39;b010z0; //35 #10 a=0; b=5\u0026#39;b01000; //45 #10 a=1; b=5\u0026#39;b10xz0; //55 #10 a=0; b=5\u0026#39;b10000; //65 #10 a=1; b=5\u0026#39;bxxxxx; //75 #10 a=0; b=5\u0026#39;b01100; //85 #10 a=1; b=5\u0026#39;bzzzzz; //95 #10 a=0; b=5\u0026#39;b01000; //105 #10 a=1; b=5\u0026#39;b10100; //115 #10 a=0; b=5\u0026#39;b01000; //125 #10 a=1; b=5\u0026#39;b10000; //135 #10 a=1; b=5\u0026#39;b00100; //145 #10; $finish; end //property definition property p; @(posedge clk) a |-\u0026gt; $isunknown(b); endproperty //calling assert property a_1: assert property(p) $info(\u0026#34;Pass\u0026#34;); else $info(\u0026#34;Fail\u0026#34;); endmodule Output:\nIn below figure, a=1 at 25ns and one bit of b is unknown(i.e 1x0). Hence, $info displayed Pass at 25ns. At 125ns a=1 but none of the bits of b are unkown (i.e 10100). Hence, $info displayed Fail at 125ns.\nFigure.43 $isunknown method output Waveform Output:\nFigure.44 $isunknown waveform output Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/assertion/SVA_Methods/isunknown Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/SVA_Methods/isunknown/isunknown.log $countones(expression)# counts the number of bits that are high in a vector. Syntax:\na_1: assert property( @(posedge clk) $countones(bus)\u0026gt; 1 ); Assert statement a_1 checks that the number of ones in the vector “bus” is greater than one.\nExample:\nmodule countones; bit clk,a; logic [4:0] b; always #5 clk = ~clk; //clock generation initial begin a=0; b=5\u0026#39;b00000; #15 a=1; b=5\u0026#39;b001x0; //15 #10 a=0; b=5\u0026#39;b01000; //25 #10 a=1; b=5\u0026#39;b11011; //35 #10 a=0; b=5\u0026#39;b01000; //45 #10 a=1; b=5\u0026#39;b10xz0; //55 #10 a=0; b=5\u0026#39;b10000; //65 #10 a=1; b=5\u0026#39;bxxxxx; //75 #10 a=0; b=5\u0026#39;b01100; //85 #10 a=1; b=5\u0026#39;bzzzzz; //95 #10 a=0; b=5\u0026#39;b01000; //105 #10 a=1; b=5\u0026#39;b11110; //115 #10 a=0; b=5\u0026#39;b01000; //125 #10 a=1; b=5\u0026#39;b10000; //135 #10 a=1; b=5\u0026#39;b00100; //145 #10; $finish; end //property definition property p; @(posedge clk) a |-\u0026gt; ($countones(b) == 1); endproperty //calling assert property a_1: assert property(p) $info(\u0026#34;Pass\u0026#34;); else $info(\u0026#34;Fail\u0026#34;); endmodule Output:\nin below figure, a=1 at 25ns and only one of the bits of b is 1 (i.e 1x0). Hence, $info displayed pass at 25ns. At 125 a=1 and more then one bits of b is 1 (i.e 11110). Hence, $info displayed fail at 125ns.\nFigure.45 $countones method output Waveform Output:\nFigure.46 $countones waveform output Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/assertion/SVA_Methods/countones Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/SVA_Methods/countones/countones.log Disable iff# In some design conditions, we don’t want to proceed with the check if some condition is true. this can be achieved by using disable iff. Disable iff disables the property if the expression it is checking is active. This is normally used for reset checking and if reset is active, then property is disabled.\nBelow property(p) checks that, if reset is disable and the signal “a” \u0026amp; \u0026ldquo;b\u0026rdquo; is high on given posedge of the clock the property is asserted, During this entire sequence, if reset is detected high at any point, the checker will stop. property is deasserted.\nSyntax:\nproperty p; @(posedge clk) disable iff (condition); endproperty` Example:\nproperty p; @(posedge clk) disable iff (reset) (a\u0026amp;\u0026amp;b); endproperty The above example we use reset as the checker. The disable iff is used only inside the property. if reset is deasserted i.e \u0026lsquo;0\u0026rsquo; then the property is enabled, the assertion output is obtained. if reset is asserted then the property is disabled, then the assertion output is not obtained/displayed\ncode snippet\n//Design module module andgate( input A, input B, output Y, input clk, input rst); assign Y = A\u0026amp;\u0026amp;B; endmodule:andgate Testbench Code:\n`//module AND_gate_tb; module AND_Gate; reg A; reg B; reg clk; wire Y; reg rst; //Design instantiation andgate inst(.A(A), .B(B), .Y(Y), .clk(clk), .rst(rst)); always #5 clk = ~clk; initial begin rst \u0026lt;=1; //reset is asserted clk\u0026lt;=1; A\u0026lt;=0; B\u0026lt;=0; #10 A\u0026lt;=0; B\u0026lt;=1; #12 rst \u0026lt;=0;//reset is deasserted A\u0026lt;=1; B\u0026lt;=0; #10 A\u0026lt;=1; B\u0026lt;=1; #30 $finish; end //------------------------------------------------------- // Disable iff is used to disable the property when the // reset is active. Assertion output is disable whether it // failure or pass.It is used when we don\u0026#39;t want to check // some conditions //------------------------------------------------------- property p; @(posedge clk) disable iff(rst)//disable if reset is assereted A\u0026amp;\u0026amp;B; endproperty assert property (p) $display(\u0026#34;time=%0t,A=%0b and B=%0b, assertion success\\n\u0026#34;,$time,A,B); else $display(\u0026#34;time=%0t, A=%0b and B=%0b,assertion failure\\n\u0026#34;, $time,A,B); initial begin $dumpfile(\u0026#34;waveform.vcd\u0026#34;); $dumpvars(); end endmodule:AND_Gate output:\nIn the below figure reset is a checker if rst=0, the property is enabled and gives the assertion output while at 40ns rst=1, the property is disabled and the assertion output is not checked. The disable iff is used when we do not want to check some output of assertion.\nFig.47: Disable iff output Fig.48: output waveform Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/assertion/disable_ended_assertion/disable_assertion Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/disable_ended_assertion/disable_assertion/disable.log ended# The keyword \u0026ldquo;ended\u0026rdquo; is attached to the sequence name, while using more than one sequence in the program, the ending point of the sequences can be used as a synchronization point\nBelow in the code snippet, Here in the code we used two sequences seq1 and seq2. The sequence one as the variable d, and sequence two as the variable ‘k’. The two sequences is declare in the property with the implication operator along with the 4 clock cycle delay. Now, by using ended “keyword” with the sequence.Example: seq1 -\u0026gt; ##4 seq2. The seq1 is antecedent and seq2 is consequent. if antecedent is executed i.e the seq1. Then only the consequent part is executed i.e is seq2. In code, the seq1 variable‘d’ is high at posedge of clk, then from the next posedge of clk the seq2 is evaluated then the assertion is passed if \u0026lsquo;k\u0026rsquo; at the 4 clock cycle of delay.\ncode snippet\n`module assertion_ex; bit clk,d,k; always #5 clk = ~clk; //clock generation //generating \u0026#39;a\u0026#39; initial begin d=1; #57 k=1; #10 d=0; #15 k=0; #10 d=1; #10 k=0; #10 d=1; #10 k=1; #200; $finish; end //sequence 1 sequence seq_1; @(posedge clk) d; endsequence //sequence 2 sequence seq_2; @(posedge clk) ##4 k; endsequence property p; @(posedge clk) seq_1.ended |-\u0026gt; ##4 seq_2.ended; endproperty a_1: assert property(p)$info(\u0026#34;passed\u0026#34;); else $info(\u0026#34;failed\u0026#34;); initial begin $dumpfile(\u0026#34;waveform.vcd\u0026#34;); $dumpvars(); end endmodule:assertion_ex output:\nHere, at 5ns d=1, the seq1 is executed from next cycle seq2 execute, it will check for 4cycle cycle from the ending cycle of seq1. here seq2 check the value \u0026lsquo;k\u0026rsquo; until 45ns, at 45ns the \u0026lsquo;k\u0026rsquo; value is low, then the assertion is failed. At 25ns the seq1 as the variable \u0026rsquo;d\u0026rsquo; it value is \u0026lsquo;high\u0026rsquo;, then it will start executing seq2 from next cycle, the seq2 as the variable k, it will check whether the \u0026lsquo;k\u0026rsquo; is high at 4 cycle. it is high in the 4clock cycle so at 65n, the assertion is passed.\nFig.49: Transcript output of ended output Waveform:\nFig.50: waveform of ended Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/assertion/disable_ended_assertion/ended_assertion Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/disable_ended_assertion/ended_assertion/Example.log Without using ended keywordEx:seq1 |-\u0026gt; ##4 seq2 in this example, While without using ended. The below same code the assertion will pass after 125ns. The seq variable‘d’ is high at 45ns then the seq2 is evaluated after the 4 clock cycle delay due to ##4. The variable ‘k’ is then evaluated as the seq2 as the expression ##4 k; if ‘k’ value is high at 4 clock cycle then the assertion is passed. In this case it will take 9 clock cycle to pass assertion where by using the ended keyword the assertion Is passed for 5 clock cycle.\ncode snippet\n`module assertion_ex; bit clk,d,k; always #5 clk = ~clk; //clock generation //generating \u0026#39;a\u0026#39; initial begin d=1; #57 k=1; #10 d=0; #15 k=0; #10 d=1; #10 k=0; #10 d=1; #10 k=1; #200; $finish; end //sequence 1 sequence seq_1; @(posedge clk) d; endsequence //sequence 2 sequence seq_2; @(posedge clk) ##4 k; endsequence property p; @(posedge clk) seq_1 |-\u0026gt; ##4 seq_2; endproperty a_1: assert property(p)$info(\u0026#34;passed\u0026#34;); else $info(\u0026#34;failed\u0026#34;); initial begin $dumpfile(\u0026#34;waveform.vcd\u0026#34;); $dumpvars(); end endmodule:assertion_ex output:\nHere, at 45ns d=1, the seq1 as variable \u0026rsquo;d\u0026rsquo; it is high at 45ns, then seq1 is executed, then now seq2 will start execute the variable \u0026lsquo;k\u0026rsquo; after the 4clock cycle, it will start to check the value of \u0026lsquo;k\u0026rsquo;,after the 4clock cycle of seq2, then seq2 variable \u0026lsquo;k\u0026rsquo; is chck the value at 4th clcok cycle. if it is high it pass the assertion. Total it take 9 clock cycle to execute the seq2 value, at 125ns it will pass the assertion.\nFig.51: output of without_ended output waveform:\nGithub lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/assertion/disable_ended_assertion/without_ended_assertion Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/assertion/disable_ended_assertion/without_ended_assertion/Example.log "},{
      "id": "34",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/19.interprocess-communication/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / Interprocess communication  ",
      "title": "Interprocess communication  ",
      "content":"Interprocess communication# Interprocess communication (IPC) is a set of programming interfaces that allow a programmer to coordinate activities among different program processes that can run concurrently in an operating system. This allows a program to handle many user requests at the same time\nCheat Sheet# Components/Threads Description Events Different threads synchronize with each other via event handles in a testbench Semaphores Different threads might need to access the same resource; they take turns by using a semaphore Mailbox Threads/Components need to exchange data with each other; data is put in a mailbox and sent 1-Events# Event is used for synchronization between two or more concurrently active processes. Initially, we need to declare the event and then it needs to be triggered by using the -\u0026gt; or -\u0026raquo; operator.\nProcesses can wait for the event by using the @ operator or wait(event_name.triggered). when both @ and wait comes at the same point then a race-around condition occurs in between both.\nCreate an event:-\nevent e; Triggering the event:-\n-\u0026gt;e; Wait for the event to be triggered:-\n@e; or wait(e.triggered); Difference between @ and wait operator:# Generally both the @ and wait operators are used to waiting for an event to be triggered. The main difference between @ and wait is that when waiting of an event and triggering of an event takes place at same time then @ cannot detect the triggering where as wait can detect the triggering of the event and then executes .Lets see the difference between @ and wait with a code below .\ncode snippet:\nmodule wait_example; event e; initial begin $display($time,\u0026#34;\\t triggering the event\u0026#34;); -\u0026gt;e; end initial begin $display($time,\u0026#34;\\t waiting for the event using wait\u0026#34;); wait(e.triggered); $display($time,\u0026#34;\\t event is triggered using wait\u0026#34;); end initial begin $display($time,\u0026#34;\\t waiting for the event using @\u0026#34;); @(e.triggered); $display($time,\u0026#34;\\t event is triggered using @\u0026#34;); end endmodule In the code triggering and waiting of an event takes place at same time at 0ns.wait will trigger the event whereas \u0026ldquo;@\u0026rdquo; cannot detect the triggering\ncode output:\nIn the output we can see that triggering and waiting of an event takes place at same time at 0ns then wait can detect the triggering so it displays the statement \u0026rsquo;event is triggered using wait \u0026ldquo;where as @ cannot detect the triggering so the display statement below @ is not executed.\nwait_order():# wait_order() method is used to specify the events to be triggered in a particular order. It block the processes until all the events are triggered in the specified order.\nsyntax:\nwait_order(event_1,event_2\u0026hellip;.event_n);\nExample:\nevent e1; event e2; event e3; wait_order(e1,e3,e2); In the above example the events will get triggered in the order e1 then e3 and then e2 ,then only process gets executed otherwise it block the process. If we have specified the order and events are not executed in the order then run time error is generated. To avoid this error we can use else statement so we can get user message under else if events are not triggered in the order. Lets see with example\nExample:\nwait_order(e1,e3,e2)\nelse display(\u0026quot;events are out of order\u0026quot;); In this example, if events are not triggered in the given order a user message in else statement is displayed, instead of run time error being generated.\ncode snippet:\nmodule wait_order; event e1; //declaring event e1 event e2; //declaring event e2 event e3; //declaring event e3 initial begin fork //process-1, triggers the event e1 begin #6; $display($time,\u0026#34;\\tTriggering The Event e3\u0026#34;); -\u0026gt;e3; end //process-2, triggers the event e2 begin #2; $display($time,\u0026#34;\\tTriggering The Event e1\u0026#34;); -\u0026gt;e1; end //process-3, triggers the event e3 begin #8; $display($time,\u0026#34;\\tTriggering The Event e2\u0026#34;); -\u0026gt;e2; end //process-4, wait for the events to trigger in order of e1,e3 and e2 begin $display($time,\u0026#34;\\tWaiting for the Event\u0026#39;s to trigger\u0026#34;); wait_order(e1,e3,e2) $display($time,\u0026#34;\\tEvent\u0026#39;s triggered Inorder\u0026#34;); else $display($time,\u0026#34;\\tEvent\u0026#39;s triggered Out-Of-Order\u0026#34;); end join end endmodule In the above code events e1,e2,e3 are declared, using wait_order we are specifying the events to be triggered in the order e1,e3,e2.so only if events are trigerred in the given order e1-\u0026gt;,e3-\u0026gt;,e2 then only the statement below wait_order executes otherwise else statement will execute.\ncode output:\nMerging events# In merging events one event variable is assigned to another variable then another event variable is also triggered at same time when first event is triggered due to merging. It means when second event variable is assigned to first event variable then second event variable waits and block the processes until the first event variable is triggered.\nsyntax:\nevent variable 1=event variable 2;\nExample:\nevent a; event b; event b=a; // Merging events a and b code snippet :\nmodule merge_events; event a,b; initial begin fork #50 -\u0026gt;a; #30 -\u0026gt;b; #20 b = a; begin wait(a.triggered); $display(\u0026#34;[%0t] event a is done\u0026#34;,$time); end begin wait(b.triggered); $display(\u0026#34;[%0t] event b is done \u0026#34;,$time); end join end endmodule In the above code events a,b are declared then a,b events are merged by b=a.\ncode output:\nBlocking and Nonblocking events:# Blocking event# Generally blocking events are triggered using -\u0026gt; operator. Blocking events work in active region so when waiting of an event and triggering of an event takes place at same time then @ operator block the process still event is triggered so in this way -\u0026gt; operator block the events when waiting of an event and triggering of an event takes place at same time .But we can use wait operator to avoid this blocking.\nsyntax:\n-\u0026gt; event name\nExample:\nevent BJT; -\u0026gt; BJT; // event triggered using blocking triggering// code snippet:\nmodule blocking_event; event BJT; initial begin $display($time,\u0026#34;\\t triggering the event\u0026#34;); -\u0026gt;BJT; end initial begin $display($time,\u0026#34;\\t waiting for the event using wait\u0026#34;); wait(BJT.triggered); $display($time,\u0026#34;\\t event BJT is triggered using wait\u0026#34;); end initial begin $display($time,\u0026#34;\\t waiting for the event using @\u0026#34;); @(BJT.triggered); $display($time,\u0026#34;\\t event BJT is triggered using @\u0026#34;); end endmodule code output:\nAs event BJT is declared using blocking triggering -\u0026gt; BJT.AS blocking triggering and @ both work in active region so when triggering and waiting of an event takes place at same time at 0ns by using @ operator it block the statement \u0026ldquo;event BJT is triggered using @\u0026rdquo;, below @(BJT.triggered)But we can use wait(BJT.triggered) to detect the triggering so it displays the statement \u0026ldquo;event BJT is triggered using @\u0026rdquo;.\nNon blocking event# Non blocking event is triggered using -\u0026raquo; operator. As non blocking event triggering works in non blocking region and wait or @ works in active region so even though when waiting of an event and triggering of an event takes place at same time so @ does not blocks the process so \u0026ndash;\u0026gt; is called as non blocking triggering. This is the difference between blocking and non blocking events.\nsyntax:\n-\u0026gt;\u0026gt;event name\nExample:\nevent BJT; -\u0026gt;\u0026gt; BJT; // event triggered using non blocking triggering// code snippet\nmodule non_blocking; event BJT; initial begin $display($time,\u0026#34;\\t triggering the event\u0026#34;); -\u0026gt;\u0026gt;BJT; end initial begin $display($time,\u0026#34;\\t waiting for the event using wait\u0026#34;); wait(BJT.triggered); $display($time,\u0026#34;\\t event BJT is triggered using wait\u0026#34;); end initial begin $display($time,\u0026#34;\\t waiting for the event using @\u0026#34;); @(BJT.triggered); $display($time,\u0026#34;\\t event BJT is triggered using @\u0026#34;); end endmodule In the above code event BJT is declared using non blocking triggering -\u0026raquo;BJT so even though when waiting of an event and triggering of an event takes place at same time so @ does not blocks the process as non blocking triggering works in non blocking region where @ works in active region so @ unblock the process below the @(BJT.triggered);\ncode ouput:\n2-Semaphores# Semaphore is a built-in class which is provided in the built-in std package of System Verilog. A semaphore allows you to control access to a resource. Conceptually, a semaphore is a bucket. When a semaphore is allocated, a bucket that contains a fixed number of keys is created. With help of semaphore method key can be gets or puts key into the bucket(semaphores). In an analogy, semaphore can be understood as a bike rentals shop from where we can use bikes(keys) and the other person(thread/process) can only use the bikes if they are available. And they(thread/process) should wait till the previous bikes are returned.\nNow we\u0026rsquo;ll see how to use semaphores in System Verilog.\nSyntax:\nsemaphore semaphore_name;\nMethods:# Semaphore is a built-in class that provides the following methods:\nI. new()\nII. get()\nIII. put()\nIV. try_get()\nI-new() :# This method is used to create a semaphore with particular number of keys.\nSyntax:\nsemaphore_name=new(n);\nHere, key count(i.e., n) is an integer. By default, n=0. If a semaphore is not created properly it returns null.\nKey count is the value that is initially given to the semaphore. If wanted, one can also increase the keys in semaphore by putting more keys (using put() method) into semaphore than the removed number of keys.\nII-get()# get() is used to get specified number of keys from the semaphore.\nSyntax:\nsemaphore_name.get(m);\nBy default, m=1.\nIf the keys are not available for a thread/process(i.e., if any other thread/process is using the keys of semaphore), it will wait till the keys get back to the semaphore and then executes it\u0026rsquo;s action.\nIII-put()# This method is used to return it\u0026rsquo;s keys to the semaphore.\nSyntax:\nsemaphore_name.put(k);\nBy default, k=1.\nExample:\nBelow is the example of how to create a handle of semaphore and keys in it and how to get and put keys into the semaphore using the above mentioned methods.\nCode snippet:\nIn the below example we try to find what would happen if a process returns only some of the keys it procured and put the remaining later.\nmodule semaphore_example_1; semaphore sem=new(6); initial begin :BEGIN_I $display(\u0026#34;In first initial block At time=[%0t] \u0026#34;,$time); sem.get(4); $display(\u0026#34;Thread 1:Accessing 4 keys from semaphore At time=[%0t] \u0026#34;,$time); #5; sem.put(4); $display(\u0026#34;Thread 1:Done using 4 keys At time=[%0t] \u0026#34;,$time); end :BEGIN_I initial begin :BEGIN_II $display(\u0026#34;In second initial block At time=[%0t] \u0026#34;,$time); sem.get(2); $display(\u0026#34;Thread 2:Accessing 2 keys from semaphore At time=[%0t] \u0026#34;,$time); #10; sem.put(2); $display(\u0026#34;Thread 2:Done using 2 keys At time=[%0t] \u0026#34;,$time); end :BEGIN_II endmodule :semaphore_example_1 Output:\nOn above code we create 6 key. At a 0ns time in process-1 get 4 keys from semaphore and in process-2 get 2 keys.Then after time 5ns in process-1 we put 4 keys in semaphore and at time 10ns process-2 put 2 keys in semaphore.\nGithub lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/semaphore/sema_example1/sema_exm1.sv Githhub logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/semaphore/sema_example1/sema_exm1.log Example-2:\ncode snippet:\nIn below code we try to explain what happen if we try to get more key than the available key\nmodule semaphore_exm_2; semaphore sem=new(6); initial begin :BEGIN_I $display(\u0026#34;In first initial block At time=[%0t]\u0026#34;,$time); sem.get(4); $display(\u0026#34;Thread 1:Accessing 4 keys from semaphore At time=[%0t]\u0026#34;,$time); #5; sem.put(2); $display(\u0026#34;Thread 1:Done using 2 keys At time=[%0t]\u0026#34;,$time); #20; $display(\u0026#34;Thread 1:Still using the remaining 2 keys At time=[%0t]\u0026#34;,$time); end :BEGIN_I initial begin :BEGIN_II $display(\u0026#34;In second initial block At time=[%0t]\u0026#34;,$time); sem.get(5); $display(\u0026#34;Thread 2:Accessing 5 keys from semaphore At time=[%0t]\u0026#34;,$time); #10; sem.put(5); $display(\u0026#34;Thread 2:Done using 5 keys At time=[%0t]\u0026#34;,$time); end :BEGIN_II endmodule :semaphore_exm_2 Output:\nOn above code we create 6 keys. At time 0ns process-1 get 4 keys from semaphore and process-2 try to get 5 key from semaphore but at a time only 2 keys are available so it block the next statement until 5 keys are available in semaphore. Then at 5ns time process-1 put 2 keys in semaphore and at time 4 keys are available in semaphore so process-2 again wait. At a 25ns time process-1 still using keys and process-1 is end but in semaphore only 4 keys are available so process-2 can not be execute.\nGithub lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/semaphore/sema_example2/sema_exm2.sv Github logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/semaphore/sema_example2/sema_exm2.log IV-try_get()# This method is also used to get specified number of keys from the semaphore. But unlike get() method, if keys are unavailable it will not wait and returns 0 and the next step executes.\nSyntax:\nsemaphore_name.try_get(j);\nBy default, j=1.\nIf the specified number of keys are available, the method returns 1 and execution continues\nIf the specified number of keys are not available, the method returns 0 and execution continues\ncode snippet:\nThis code helps in understanding how to use try_get() method and what makes it different from get() method.\nmodule semaphore_exa_get_try; semaphore car_key = new(1); initial begin :BEGIN_I fork begin :BEGIN_I_FORK $display(\u0026#34;person A Waiting for car, time=%0t\u0026#34;, $time); car_key.get(1); $display(\u0026#34;person A Got the car, time=%0t\u0026#34;, $time); #10; car_key.put(1); $display(\u0026#34;person A Returning back car, time=%0t\u0026#34;, $time); end :BEGIN_I_FORK begin :BEGIN_II_FORK #1; $display(\u0026#34;person B Waiting for car, time=%0t\u0026#34;, $time); void\u0026#39;(car_key.try_get(1)); $display(\u0026#34;person B Got the car, time=%0t\u0026#34;, $time); #10; car_key.put(1); $display(\u0026#34;person B Returning back car, time=%0t\u0026#34;, $time); end :BEGIN_II_FORK join end :BEGIN_I endmodule:semaphore_exa_get_try Output:\nOn above code we create a 1 key. At time 0ns person A waiting for key and get a key from semaphore. At 1ns time person B waiting for key and 1ns there no key in semphore but here use try_get methos so it do not block the next statement so at 1ns it display person B Got the car.At the 10ns time in process-1 put the key and dispaly Person A returning back car.At 11ns time in process-2 put the key and display person B returning back car.\nGithub lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/semaphore/sema_example3/sema_exm3.sv Github logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/semaphore/sema_example3/sema_exm3.log 3-Mailbox# A System-Verilog mailbox is a way of communication between different processes to exchange data. One process can put data into a mailbox that stores data internally and can be retrieved by another process. Mailbox behaves as first-in, first-out (FIFO).\nTypes in mailbox# Mailbox is classified into two types.\nFig-1 Types in mailbox Based on size, mailbox can take two forms :- 1.Bounded 2.Unbounded\nGeneric Mailbox# The generic mailbox can be put or get data of any data type like int, bit, byte, string, etc. By default, the mailbox is a type-less or generic mailbox.\nSyntax\nmailbox \u0026lt;mailbox_name\u0026gt;; I. Bounded# If the size of the mailbox is defined then it is a bounded mailbox. When the mailbox is full, no further data can be put in the mailbox until an item or data is get from the mailbox.\nSyntax:-\nmailbox \u0026lt;mailbox_name\u0026gt; = new(size); Code snippet:-\nclass A; int a; int i; mailbox m; function new(mailbox m1); this.m = m1; endfunction task tra_data(); for(i =0;i\u0026lt;3;i++)begin:BEGIN_MAIN if(m.num()==2)begin:BEGIN_1 $display(\u0026#34;mailbox is full\u0026#34;); end:BEGIN_1 else begin:BEGIN_2 a++; m.put(a); $display(\u0026#34;[%0t] 1. Transmitter: value of a = %0d\u0026#34;,$time,a); end:BEGIN_2 end:BEGIN_MAIN endtask endclass:A class B; int a; int i; mailbox m; function new(mailbox m2); this.m = m2; endfunction task rec_data(); begin:BEGIN_MAIN m.get(a); $display(\u0026#34;[%0t] 2. Receiver: value of a = %0d\u0026#34;,$time,a); end:BEGIN_MAIN endtask endclass:B module tb(); A a1; B b1; mailbox mb = new(2); initial begin:BEGIN_MAIN a1 = new(mb); b1 = new(mb); repeat(3) begin:BEGIN_1 a1.tra_data(); $display(\u0026#34;...............................................\u0026#34;); b1.rec_data(); end:BEGIN_1 end:BEGIN_MAIN endmodule:tb Output:-\nFig-2 Output of Bounded Mailbox In the above fig, you can see that a Class A was created which transmits 3 data\u0026rsquo;s at a time. We are checking whether the mailbox is full or not by num method. As in module we bounded our mailbox to 2, it will transmit two data, but for third data it shows mailbox is full as there is no space in it. For receiver since we restricted it to receive only one data at a time, it will be receiving only one data.This process repeats for 3 times as we have given repeat(3) in module.\nKnow more about num():- https://github.com/muneeb-mbytes/SystemVerilog_Course/wiki/19.Interprocess-Communication#2-num Github lab link:- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/genric_mailbox/bounded_mailbox/bound.sv Github logfile link:-https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/genric_mailbox/bounded_mailbox/bound_op.log\nII. Unbounded# If the size of the mailbox is not defined then it is a unbounded mailbox.\nSyntax:-\nmailbox \u0026lt;mailbox_name\u0026gt; = new(); Code snippet:-\nclass A; int a; int i; mailbox m; function new(mailbox m1); this.m = m1; endfunction task tra_data(); for(i =0;i\u0026lt;3;i++)begin:BEGIN_MAIN a++; m.put(a); $display(\u0026#34;[%0t] 1. Transmitter: value of a = %0d\u0026#34;,$time,a); end:BEGIN_MAIN endtask endclass:A class B; int a; int i; mailbox m; function new(mailbox m2); this.m = m2; endfunction task rec_data(); begin:BEGIN_MAIN m.get(a); $display(\u0026#34;[%0t] 2. Receiver: value of a = %0d\u0026#34;,$time,a); end:BEGIN_MAIN endtask endclass:B module tb(); A a1; B b1; mailbox main = new(); initial begin:BEGIN_MAIN a1 = new(main); b1 = new(main); repeat(2) begin:BEGIN_1 a1.tra_data(); $display(\u0026#34;...............................................\u0026#34;); b1.rec_data(); end:BEGIN_1 end:BEGIN_MAIN endmodule:tb Output:-\nFig-3 Output of Unbounded Mailbox In the above fig, you can see that a Class A was created which transmits 3 data\u0026rsquo;s at a time. Unlike bounded ,as it will have unlimitted size it can take all the three data at a time and transmit them and the receiver only receive one data and after it receives next set of fresh three data comes in(since used repeat(3)) as it is unbounded.\nGithub lab link:- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/genric_mailbox/unbounded_mailbox/unbound.sv Github logfile link:- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/genric_mailbox/unbounded_mailbox/unbound_op.log Parameterized Mailbox# The parameterized mailbox can be put or get data of particular data type. The parameterized mailbox is useful when data type needs to be fixed. For differences in data type, a compilation error will occur.\nSyntax:-\nmailbox #(\u0026lt;type\u0026gt;) \u0026lt;mailbox_name\u0026gt; Code snippet:-\nclass A; int i; string country; string place; mailbox #(string) m; function new(mailbox m1); this.m = m1; endfunction task tra_data(); country = \u0026#34;India\u0026#34;; place = \u0026#34;Kashmir\u0026#34;; m.put(country); m.put(place); $display(\u0026#34;Transmitter: Country = %0s , must visit place = %0s\u0026#34;,country,place); country = \u0026#34;South Africa\u0026#34;; place = \u0026#34;Cape Town\u0026#34;; m.put(country); m.put(place); $display(\u0026#34;Transmitter: Country = %0s , must visit place = %0s\u0026#34;,country,place); country = \u0026#34;Spain\u0026#34;; place = \u0026#34;Barcelona\u0026#34;; m.put(country); m.put(place); $display(\u0026#34;Transmitter: Country = %0s , must visit place = %0s\u0026#34;,country,place); endtask endclass:A class B; string country; string place; mailbox #(string) m; function new(mailbox m2); this.m = m2; endfunction task rec_data(); m.get(country); m.get(place); $display(\u0026#34;Receiver: Country = %0s , must visit place = %0s\u0026#34;,country,place); m.get(country); m.get(place); $display(\u0026#34;Receiver: Country = %0s , must visit place = %0s\u0026#34;,country,place); m.get(country); m.get(place); $display(\u0026#34;Receiver: Country = %0s , must visit place = %0s\u0026#34;,country,place); endtask endclass:B module tb(); A a1; B b1; int i; mailbox #(string) main = new(6); initial begin:BEGIN_MAIN a1= new(main); b1 = new(main); $display(\u0026#34;\u0026#34;); $display(\u0026#34;\u0026#34;); a1.tra_data(); $display(\u0026#34;.......................................................................\u0026#34;); b1.rec_data(); end:BEGIN_MAIN endmodule:tb Output:-\nFig-4 Output of Parameterized Mailbox In the above fig, you can see that we had fixed our mailbox to string data type. Took two strings country and place and bounded the mailbox to size 6. Since the mailbox is of string type we will pass string values India, kashmir, South Africa ,Cape Town, Spain and Barcelona only. If any other data type it will throw compilation error.\nGithub lab link :- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/parameterized_mailbox/para_mailbox.sv Github logfile link :-https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/parameterized_mailbox/para_op.log\nMethods in Mailbox# S.no Method Name Description 1. new(function) Returns mailbox handle. An argument represents bounded mailbox size otherwise, it is an unbounded mailbox. 2. num(function) Returns number of messages in the mailbox. 3. put(task) Blocking method that stores data in the mailbox. 4. get(task) Blocking method to retrieve data from the mailbox. 5. try_put(function) The non-blocking method that stores data in the mailbox if it is not full and returns 1 else 0. 6. try_get(function) The non-blocking method which returns data if a mailbox is non-empty else returns 0. 7. peek(task) Copies data from the mailbox without removing it from a mailbox. 8. try_peek(function) Tries to copy data from the mailbox without removing it from a mailbox. I. new# Mailboxes are created by this method.\nSyntax:-\nmailbox \u0026lt;mailbox_name\u0026gt; = new(size); // creates a bounded mailbox mailbox \u0026lt;mailbox_name\u0026gt; = new(); // creates an unbounded mailbox Code snippet:-\nclass A; int a; int i; mailbox m; function new(mailbox m1); this.m = m1; endfunction task check(); if(m == null)begin:BEGIN_1 $display(\u0026#34;Mailbox is not created\u0026#34;); end:BEGIN_1 else $display(\u0026#34;Mailbox is created\u0026#34;); for(i=0;i\u0026lt;3;i++)begin:BEGIN_2 a++; m.put(a); $display(\u0026#34;Value of a = %0d\u0026#34;,a); end:BEGIN_2 endtask endclass:A module tb(); A a1; mailbox main = new(3); initial begin:BEGIN_MAIN a1= new(main); $display(\u0026#34;\u0026#34;); $display(\u0026#34;\u0026#34;); a1.check(); end:BEGIN_MAIN endmodule:tb Output:-\nFig-5 Output of new_method In the above fig, we created a bounded mailbox of size 3 and we are checking it whether it has been created or not. Since it has been created we transmitted 3 data into it.\nGithub lab link :- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/methods_in_mailbox/new_method/bounded/new_md.sv Github logfile link :- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/methods_in_mailbox/new_method/bounded/new_op.log II. num# This method returns the no of messages present in a mailbox.\nSyntax:-\n\u0026lt;mailbox_name\u0026gt;.num(); Code snippet:-\nclass A; int a; int i; mailbox m; function new(mailbox m1); this.m = m1; endfunction task tra_data(); for(i =0;i\u0026lt;3;i++)begin:BEGIN_MAIN a++; m.put(a); $display(\u0026#34;[%0t] Transmitter: value of a = %0d\u0026#34;,$time,a); $display(\u0026#34; No of messages in mailbox = %0d\u0026#34;,m.num()); end:BEGIN_MAIN $display(\u0026#34;.....................................................\u0026#34;); endtask endclass:A module tb(); A a1; mailbox main = new(); initial begin:BEGIN_MAIN a1 = new(main); repeat(2) begin:BEGIN_1 a1.tra_data(); end:BEGIN_1 end:BEGIN_MAIN endmodule:tb Output:-\nFig-6 Output of num_method In the above fig, you can see that we had created an unbounded mailbox and we are transmitting three data\u0026rsquo;s at a time. Since it is unbounded we don\u0026rsquo;t have any restrictions we can transmit all the data. Now for the first time of transmission, the passed values of a are 1, 2, 3 and the no of messages are three which can be seen by num() method. We repeated the process for two times so that we are able to pass 4, 5, 6 and now the no of messages in mailbox is 6.\nGithub lab link:- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/methods_in_mailbox/num_method/num.sv Github logfile link:- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/methods_in_mailbox/num_method/num_op.log III. put# This method stores the data into the mailbox in FIFO order. It will block the process if mailbox is full.\nSyntax:-\n\u0026lt;mailbox_name\u0026gt;.put(arguments); Code snippet:-\nclass A; int a; int i; mailbox m; function new(mailbox m1); this.m = m1; endfunction task tra_data(); for(i =0;i\u0026lt;4;i++)begin:BEGIN_MAIN m.put(a); #1 a++; $display(\u0026#34;[%0t] 1. Transmitter: value of a = %0d\u0026#34;,$time,a); end:BEGIN_MAIN $display(\u0026#34;.....................................................\u0026#34;); endtask endclass:A class B; int a; int i; mailbox m; function new(mailbox m2); this.m = m2; endfunction task rec_data(); begin:BEGIN_1 m.get(a); $display(\u0026#34;[%0t] 2. Receiver: value of a = %0d\u0026#34;,$time,a); end:BEGIN_1 endtask endclass:B module tb(); A a1; B b1; mailbox main = new(3); initial begin:BEGIN_MAIN a1 = new(main); b1 = new(main); repeat(2) begin:BEGIN_1 a1.tra_data(); $display(\u0026#34;................................................................\u0026#34;); b1.rec_data(); end:BEGIN_1 end:BEGIN_MAIN endmodule:tb Output:-\nFig-7 Output of put_method In the above fig, you can see that mail box is of size 3 but we are trying to pass 4 data, since put is a blocking task it will not allow other task to perform until or unless it gets the fourth data, which is not possible(since size of mailbox is 3), so the program gets terminated.\nGithub lab link :- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/methods_in_mailbox/put_method/put.sv Github logfile link :- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/methods_in_mailbox/put_method/put_op.log IV. get# This method can retrieve one message from the mailbox, if mailbox is empty it will block the process.\nSyntax:-\n\u0026lt;mailbox_name\u0026gt;.get(arguments); Code snippet:-\nclass A; int a; int i; mailbox m; function new(mailbox m1); this.m = m1; endfunction task tra_data(); for(i =0;i\u0026lt;2;i++)begin:BEGIN_MAIN a++; m.put(a); $display(\u0026#34;[%0t] 1. Transmitter: value of a = %0d\u0026#34;,$time,a); end:BEGIN_MAIN $display(\u0026#34;put successful\u0026#34;); endtask endclass:A class B; int a; int i; mailbox m; function new(mailbox m2); this.m = m2; endfunction task rec_data(); for(i =0;i\u0026lt;3;i++)begin:BEGIN_MAIN m.get(a); $display(\u0026#34;[%0t] 2. Receiver: value of a = %0d\u0026#34;,$time,a); end:BEGIN_MAIN $display(\u0026#34;get successful\u0026#34;); endtask endclass:B module tb(); A a1; B b1; mailbox main = new(2); initial begin:BEGIN_MAIN a1 = new(main); b1 = new(main); repeat(2) begin:BEGIN_1 a1.tra_data(); $display(\u0026#34;...............................................\u0026#34;); b1.rec_data(); end:BEGIN_1 end:BEGIN_MAIN endmodule:tb Output:-\nFig-8 Output of get_method In the above fig, you can see that mail box is of size 2 and we are trying to pass 2 data but at receiver side we are trying to receive 3 data at a time. So it will first receive 2 data as size is 2 and keeps on waiting for the other data. Since it is not possible it will terminate the program and will not print $display(\u0026ldquo;get successful\u0026rdquo;) line.\nGithub lab link:- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/methods_in_mailbox/get_method/get.sv Github logfile link:- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/methods_in_mailbox/get_method/get_op.log V. try_put# This method tries to put the data in a non blocking manner to store a message in the mailbox if not full. If successful returns 1 else 0.\nSyntax:-\n\u0026lt;mailbox_name\u0026gt;.try_put(arguments); Code snippet:-\nclass A; int a; int i; mailbox m; function new(mailbox m1); this.m = m1; endfunction task tra_data(); for(i =0;i\u0026lt;4;i++)begin:BEGIN_MAIN a++; if( m.try_put(a)) $display(\u0026#34;[%0t] 1. Transmitter: value of a = %0d\u0026#34;,$time,a); else $display(\u0026#34;failed while trying to put data=%0d\u0026#34;,a); end:BEGIN_MAIN $display(\u0026#34;.....................................................\u0026#34;); endtask endclass:A class B; int a; int i; mailbox m; function new(mailbox m2); this.m = m2; endfunction task rec_data(); repeat(3) begin m.get(a); $display(\u0026#34;[%0t] 2. Receiver: value of a = %0d\u0026#34;,$time,a); end endtask endclass:B module tb(); A a1; B b1; mailbox main = new(3); initial begin:BEGIN_MAIN a1 = new(main); b1 = new(main); repeat(2) begin:BEGIN_1 a1.tra_data(); b1.rec_data(); end:BEGIN_1 end:BEGIN_MAIN endmodule:tb Output:-\nFig-9 Output of try_put_method In the above fig, you can see that mail box is of size 3 but we are trying to pass 4 data, unlike put_method(which blocks the next set of execution),it will not block, but execute the next set of program. As you can see even though the mailbox is full it will go to next set of statements and prints $display(failed to get the value) statement.\nGithub lab link:- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/methods_in_mailbox/try_put_method/try_put.sv Github logfile link:- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/methods_in_mailbox/try_put_method/try_put_op.log VI. try_get# This is a non-blocking method which tries to get one message from the mailbox, returns 0 if mailbox is empty.\nSyntax:-\n\u0026lt;mailbox_name\u0026gt;.try_get(arguments); Code snippet:-\nclass A; int a; int i; mailbox m; function new(mailbox m1); this.m = m1; endfunction task tra_data(); for(i =0;i\u0026lt;4;i++)begin:BEGIN_MAIN a++; m.put(a); $display(\u0026#34;[%0t] 1. Transmitter: value of a = %0d\u0026#34;,$time,a); end:BEGIN_MAIN $display(\u0026#34;put successful\u0026#34;); endtask endclass:A class B; int a; int i; mailbox m; function new(mailbox m2); this.m = m2; endfunction task rec_data(); repeat(5)begin:BEGIN_MAIN if( m.try_get(a)) $display(\u0026#34;[%0t] 2. Receiver: value of a = %0d\u0026#34;,$time,a); else $display(\u0026#34;Failed while getting the value as mailbox is empty \u0026#34;); end:BEGIN_MAIN $display(\u0026#34;get successful\u0026#34;); endtask endclass:B module tb(); A a1; B b1; mailbox main = new(4); initial begin:BEGIN_MAIN a1 = new(main); b1 = new(main); repeat(2) begin:BEGIN_1 a1.tra_data(); $display(\u0026#34;...............................................\u0026#34;); b1.rec_data(); end:BEGIN_1 end:BEGIN_MAIN endmodule:tb Output:-\nFig-10 Output of try_get_method In the above fig, you can see that mail box is of size 4 but we are trying to pass 4 data, but at receiver side we are trying to get 5 data at a time. So at first we are transmitting a values 1,2,3,4 and at receiver side we are waiting for the fifth data as well. Since it is non blocking method, it will go to the next set of execution and prints (\u0026ldquo;get successful\u0026rdquo;).\nGithub lab link:- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/methods_in_mailbox/try_get_method/try_get.sv Github logfile link:- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/methods_in_mailbox/try_get_method/try_get_op.log VII. peek# This method copies one message from the mailbox without removing the message from the mailbox queue.\nSyntax:-\n\u0026lt;mailbox_name\u0026gt;.peek(arguments); Code snippet:-\nclass A; int a; int i; mailbox m; function new(mailbox m1); this.m = m1; endfunction task tra_data(); for(i=0;i\u0026lt;1;i++)begin:BEGIN_MAIN a++; m.put(a); $display(\u0026#34;[%0t] 1. Transmitter: value of a = %0d\u0026#34;,$time,a); end:BEGIN_MAIN $display(\u0026#34;put successful\u0026#34;); $display(\u0026#34;Messages in mailbox = %0d\u0026#34;,m.num()); endtask endclass:A class B; int a; int i; mailbox m; function new(mailbox m2); this.m = m2; endfunction task rec_data(); for(i =0;i\u0026lt;2;i++)begin:BEGIN_MAIN m.peek(a); $display(\u0026#34;[%0t] Peeking value of a = %0d\u0026#34;,$time,a); $display(\u0026#34;Peek successful\u0026#34;); end:BEGIN_MAIN m.get(a); $display(\u0026#34;[%0t] 2. Receiver: value of a = %0d\u0026#34;,$time,a); $display(\u0026#34;get successful\u0026#34;); $display(\u0026#34;Messages in mailbox = %0d\u0026#34;,m.num()); endtask endclass:B module tb(); A a1; B b1; mailbox main = new(2); initial begin:BEGIN_MAIN a1 = new(main); b1 = new(main); a1.tra_data(); $display(\u0026#34;...............................................\u0026#34;); b1.rec_data(); $display(\u0026#34;...............................................\u0026#34;); b1.rec_data(); $display(\u0026#34;End of program\u0026#34;); end:BEGIN_MAIN endmodule:tb Output:-\nFig-11 Output of peek_method In the above fig, you can see that mail box is of size 2 but we are transmitting only 1 data, but at receiver we are peeking(copy) the transmitted value twice (a =1). Now the mailbox is empty, since Peek is a blocking task, when we tried calling bi.rec_data() again it will block all statements after m.peek(a) and so will not display End of program.\nGithub lab link :- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/methods_in_mailbox/peek_method/peek.sv Github logfile link :- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/methods_in_mailbox/peek_method/peek_op.log VIII. try_peek# This method tries to copy data from mailbox without removing it from mailbox.\nSyntax:-\n\u0026lt;mailbox_name\u0026gt;.try_peek(arguments); Code snippet:-\nclass A; int a; int i; mailbox m; function new(mailbox m1); this.m = m1; endfunction task tra_data(); for(i=0;i\u0026lt;1;i++)begin:BEGIN_MAIN a++; m.put(a); $display(\u0026#34;[%0t] 1. Transmitter: value of a = %0d\u0026#34;,$time,a); end:BEGIN_MAIN $display(\u0026#34;put successful\u0026#34;); $display(\u0026#34;Messages in mailbox = %0d\u0026#34;,m.num()); endtask endclass:A class B; int a; int i; mailbox m; function new(mailbox m2); this.m = m2; endfunction task rec_data(); for(i =0;i\u0026lt;2;i++)begin:BEGIN_MAIN if( m.try_peek(a)) begin:BEGIN_1 $display(\u0026#34;[%0t] Peeking value of a = %0d\u0026#34;,$time,a); $display(\u0026#34;Peek successful\u0026#34;); end:BEGIN_1 else begin $display(\u0026#34;Peek failed as mailbox is empty\u0026#34;); return; end end:BEGIN_MAIN m.get(a); $display(\u0026#34;Receiver: value of a = %0d\u0026#34;,a); $display(\u0026#34;get successful\u0026#34;); endtask endclass:B module tb(); A a1; B b1; mailbox main = new(2); initial begin:BEGIN_MAIN a1 = new(main); b1 = new(main); a1.tra_data(); $display(\u0026#34;...............................................\u0026#34;); b1.rec_data(); $display(\u0026#34;...............................................\u0026#34;); b1.rec_data(); $display(\u0026#34;End of program\u0026#34;); end:BEGIN_MAIN endmodule:tb Output:-\nFig-12 Output of try_peek_method In the above fig, you can see that mail box is of size 2 but we are transmitting only 1 data, but at receiver we are peeking(copy) the transmitted value twice (a =1). Now the mailbox is empty, since try_peek is a blocking task, when we tried calling bi.rec_data() again it will try peeking the value. As the mailbox is empty it will print peek is failed and now End of program will also get executed.\nGithub lab link :- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/methods_in_mailbox/try_peek_method/try_peek.sv Github logfile link :- https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Interprocess_communications/mailbox/methods_in_mailbox/try_peek_method/try_peek_op.log "},{
      "id": "35",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/20.misc-constructs/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / Program Block",
      "title": "Program Block",
      "content":"1.Program Block# The module is the basic building block in Verilog which works well for Design. However, for the testbench, a lot of effort is spent getting the environment properly initialized and synchronized, avoiding races between the design and the testbench, automating the generation of input stimuli, and reusing existing models and other infrastructure. System Verilog adds a new type of block called program block. It is declared using the program and endprogram keywords.\nsyntax:\nprogram program_name(port_list);\ninitial begin\n.....\nend\nendprogram\nAll items defined inside the program block will be performed in the reactive region because of the race-free interaction provided by the program construct. Initial blocks within program blocks are planned in the Reactive region, while non-blocking assignments within the module are scheduled in the Active region and assign value in NBA Region .\nThis Re-Active Region set consists of :\nFig-1: Blocks of Re-Active region set Statements within program blocks that depend on changes in design signals are scheduled in the reactive region. By scheduling the active region before the reactive region, the race condition between the testbench and the design is avoided. -\u0026gt; It does not allow always block. Only initial and methods are allowed, which are more controllable.\n-\u0026gt; Each program can be explicitly exited by calling the $exit system task. Unlike $finish, which exits the simulation immediately, even if there are pending events.\n-\u0026gt; Just like a module, program block has ports. One or more program blocks can be instantiated in a top-level netlist, and connected to the DUT.\nThe following example demonstrates the difference between the module-based testbench and the program-based testbench.\ncode snippet:\nmodule DUT(); reg a = 0; initial begin a\u0026lt;= 1; end endmodule module TB_using_Module(); initial begin $display(\u0026#34;Module_based_TB : a = %b\\n\u0026#34;, DUT.a); end endmodule program TB_using_Program(); initial begin $display(\u0026#34;Program_based_TB : a = %b\\n\u0026#34;, DUT.a); end endprogram output:\nFig-2: output for module and program block Github lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/Program_block/program_block.sv Github logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/Program_block/program.log If we observe that in the module it gives a value of 0, but in the program block, the value of a is 1 . Because it\u0026rsquo;s already assigned a value of \u0026lsquo;a\u0026rsquo; in the active region.\u0026rsquo;\n2.Dynamic Casting# SystemVerilog casting means the conversion of one data type to another datatype.\nIt has two types\ni.static casting\nii.Dynamic casting\nStatic casting is not applicable to OOP so we go for Dynamic casting for OOPs. It is done while run time.\nUsing $cast keyword we can achieve dynamic casting. This $cast can be a function or a task.\nSyntax:\n$cast(destination,source);\ncode snippet:\nclass hyd; string a; int d=8; function display(); $display(\u0026#34;a = %0s\u0026#34;,a); $display(\u0026#34;d=%0d\u0026#34;,d); endfunction endclass class branch extends hyd; string b; function display(); super.display(); $display(\u0026#34;b = %0s\u0026#34;,b); endfunction endclass module casting; hyd p; branch c; branch c1; initial begin:BEGIN_I c = new; c.a = \u0026#34;charminar\u0026#34;; c.b = \u0026#34;cafe\u0026#34;; p = c; $cast(c1,p); $display(\u0026#34;contents of c1\u0026#34;); c1.display(); end:BEGIN_I endmodule:casting output:\nFig-3: output of dynamic casting. Github lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/dynamic_casting/dynamic_casting.sv Github logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/dynamic_casting/dynamic_casting.log 3.File Handling# System verlilog allows us to read and write files in the system or disk.\nWe will have different file operations in system verilog\ncheat sheet:\ns.no system function description 1. $fopen() A file can be opened for either read or write using the $fopen() system task.This task will return a datatype handle called a file descriptor 2. $fclose() The file descriptor(handle) is closed is using $fclose() system task. 3. $fdisplay() This is a system task () used to add the contents into the file. 4. $fgetc() This is a system task used to read character(byte) from the file. 5. $ungetc() This is the system task used to insert the character in the file. 6. $fgets() This is a system task used to read a single line from the file. 7. $fscanf() This is used to reads the data from file 8. $sscanf() sscanf reads the data from the given variable 9. $rewind() $rewind can be used to change the current read or write position within a file 10. $feof() SystemVerilog has another task called $feof() that returns true when end of the file has reached 11. $readmemb() readmemb task reads the binary data 12. $readmemh() readmemh task reads the hexadecimal data 14. $sformatf() $fopen()# A file can be opened for either read or write using the $fopen() system task.This task will return a datatype handle called a file descriptor. This handle should be used to read and write into that file until it is closed.\nWe will have read ,write and append modes in the file operations.\nCheat sheet for working modes:\nArgument Description \u0026ldquo;r\u0026rdquo; Open for reading \u0026ldquo;w\u0026rdquo; Create for writing, overwrite if it exists \u0026ldquo;a\u0026rdquo; Create if file does not exist, else append; open for writing at end of file \u0026ldquo;r+\u0026rdquo; Open for update (reading and writing) \u0026ldquo;w+\u0026rdquo; Truncate or create for update \u0026ldquo;a+\u0026rdquo; Append, open or create for update at EOF(end of file) syntax:\ndatatype file_handle;\nfile_handle = $fopen(\u0026quot;filename\u0026quot;,\u0026quot;working_mode\u0026quot;);\n$fclose()# The file is closed is using $fclose() system task.\nsyntax: $fclose(filehandle);\n$fdisplay()# This is a system task used to add the contents into the file.\nsyntax:\n$fdisplay(filehandle,\u0026quot;content to add into file\u0026quot;);\ncode snippet:\nmodule file_handles; int f; initial begin f=$fopen(\u0026#34;file_handle\u0026#34;,\u0026#34;w\u0026#34;); $fdisplay(f,\u0026#34;fileoperations\u0026#34;); $fdisplay(f,\u0026#34;sv course\u0026#34;); $fclose(f); end endmodule Output:\nFig-4: output for $fopen(), $fclose() and $fdisplay() system task. Github link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/file_handling/file_handles/file_handles.sv\nGithub logfile link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/file_handling/file_handles/file_handles.log\n$fgetc()# This is a system task used to read one character(byte) from the file.\nsyntax:. $fgetc(filehandle);\n$ungetc()# This is the system task used to insert the character in the file.\nsyntax:\n$ungetc(c,f);\n$fgets()# This is a system task used to read a single line from the file.\nsyntax:\n$fgets(variable,filehandle);\ncode snippet:\nmodule f_get; int c; int f; string line; int dummy; initial begin //write operation f=$fopen(\u0026#34;file\u0026#34;,\u0026#34;w\u0026#34;); $fdisplay(f,\u0026#34;sv course\u0026#34;); $fdisplay(f,\u0026#34;filehandling\u0026#34;); $fclose(f); //read operation f=$fopen(\u0026#34;file\u0026#34;,\u0026#34;r\u0026#34;); $display(\u0026#34;\u0026#34;); c = $fgetc(f); $display(\u0026#34;reading one character : %0s\u0026#34;,c); dummy = $ungetc(c,f); $display(\u0026#34;character insert : %0s\u0026#34;,c); dummy = $fgets(line,f); $display(\u0026#34;line read : %0s\u0026#34;,line); $fclose(f); end endmodule Output:\nFig-5: output $fgetc(), $ungetc() and $fgets() system task. Github link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/file_handling/file_get/file_get.sv\nGithub logfile link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/file_handling/file_get/file_get.log\nfscanf()# This is used to reads the data from file.\nsyntax:\n$fscanf(filehandle,\u0026quot;variable = format_specifier\u0026quot;,variable);\nexample:\nFig-6: usage of $fscanf. $sscanf()# sscanf reads the data from the given variable.\nsyntax:\n$fgets(variable,filehandle);\n$sscanf(variable,%0s,variable1);\ncode snippet:\nmodule scanf; int fd; int i; string str,str2; int dummy; initial begin fd = $fopen (\u0026#34;hihihi.sv\u0026#34;, \u0026#34;w\u0026#34;); $fdisplay(fd,\u0026#34;bhavana\u0026#34;); $fdisplay(fd,\u0026#34;Teams\u0026#34;); $fdisplay(fd,\u0026#34;BJT\u0026#34;); $fclose(fd); fd = $fopen(\u0026#34;hihihi.sv\u0026#34;,\u0026#34;r\u0026#34;); //Usage of fscanf dummy = $fscanf(fd,\u0026#34;str=%0s\u0026#34;,str); repeat(2) begin dummy = $fgets(str,fd); $display(\u0026#34;\u0026#34;); $display(\u0026#34;contents of fscanf\u0026#34;); $display(\u0026#34;str = %0s\u0026#34;,str); end //Usage of sscanf $display(\u0026#34;contents of sscanf\u0026#34;); dummy = $fgets(str,fd); dummy = $sscanf(str,\u0026#34;%0s\u0026#34;,str2); $display(\u0026#34;str = %0s\u0026#34;,str); $display(\u0026#34;str2 = %0s\u0026#34;,str2); $display(\u0026#34;\u0026#34;); $fclose(fd); end endmodule Output:\nFig-7: output for $fscanf() and $sscanf(). $sformat()# This system task is used to update a variable with particular content.\nsyntax: data_type var1,var2; $sformat(var2,\u0026quot;content\u0026quot;,var1);\n$sformatf()# This is a system function which returns the updated content to a variable.\nsyntax: data_type var1,var2; var2 = $sformatf(\u0026quot;content\u0026quot;,var1);\ncode snippet:\nmodule format; int a=9; int fd; string b=\u0026#34;hii\u0026#34;; string c; initial begin:BEGIN_I fd=$fopen(\u0026#34;file\u0026#34;,\u0026#34;w\u0026#34;); c = $sformatf(\u0026#34;delta_%0d\u0026#34;,a); $display(\u0026#34;c=%0s\u0026#34;,c); $sformat(b,\u0026#34;delta_%0d\u0026#34;,a); $display(\u0026#34;b=%0s\u0026#34;,b); $fclose(fd); end:BEGIN_I endmodule:format output:\nFig-8: output for $sformat() and $sformatf(). Github link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/file_handling/file_format/file_format.sv\nGithub logfile link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/file_handling/file_format/file_format.log\n$feof# SystemVerilog has another task called $feof() that returns true when end of the file has reached\nsyntax:\n$feof(filehandle);\n$rewind# $rewind can be used to change the current read or write position within a file.We use this $rewind in \u0026ldquo;w+\u0026rdquo; mode to get the write position to the starting.\nsyntax:\n$rewind(filehandle);\ncode snippet :\nmodule tb; int fd; string str1,str2; initial begin //open the file in the write mode fd = $fopen (\u0026#34;hihihi.sv\u0026#34;, \u0026#34;w+\u0026#34;); //displays the contents into the file $fdisplay(fd,\u0026#34;teams\u0026#34;); $fdisplay(fd,\u0026#34;c\u0026#34;); $rewind(fd); //close the file $fclose(fd); //open the file in read mode fd = $fopen(\u0026#34;hihihi.sv\u0026#34;,\u0026#34;r\u0026#34;); $feof(fd); fd =$fopen(\u0026#34;hihihi.sv\u0026#34;,\u0026#34;r\u0026#34;); $fgets(str1,fd); $display(\u0026#34;line:%0s\u0026#34;,str1); $fclose(fd); end endmodule output:\nFig-9: output for $feof() and $rewind(). Github link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/file_handling/file_eof/file_eof.sv\nGithub logfile link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/file_handling/file_eof/file_eof.log\n$readmemb()# readmemb() task reads the binary data.\nsyntax: $readmemb(\u0026quot;filename\u0026quot;,mem);\n$readmemh()# readmemh() task reads the hexadecimal data.\nsyntax: $readmemh(\u0026quot;filename\u0026quot;,mem);\ncode snippet:\nmodule readmem; int fd; int i; int mem[3]; string str; initial begin:BEGIN_I //open the file in write mode fd = $fopen (\u0026#34;hihihi.sv\u0026#34;, \u0026#34;w\u0026#34;); $fdisplay(fd,10000); $fdisplay(fd,11011); $fdisplay(fd,\u0026#34;c\u0026#34;); //close the file in write mode $fclose(fd); $readmemh(\u0026#34;hihihi.sv\u0026#34;,mem); $readmemb(\u0026#34;hihihi.sv\u0026#34;,mem); repeat($size(mem)) begin:BEGIN_II $display(\u0026#34;\u0026#34;); $display(\u0026#34;hexadecimal[%0d] = %0h\u0026#34;,i,mem[i]); $display(\u0026#34;Binary[%0d] = %0b\u0026#34;,i,mem[i]); $display(\u0026#34;\u0026#34;); i++; end:BEGIN_II end:BEGIN_I endmodule:readmem output:\nGithub link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/file_handling/file_readmem/file_readmem.sv\nGithub output link:https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/file_handling/file_readmem/file_readmem.log\n4.Packages# Packages are group of functions ,tasks ,classes that are shareable.Packages are meant for the code reusability similar to functions ,tasks and classes but all under one entity.\nFig.Illustration of a Package In a package we can have classes,functions and tasks but cannot have modules. If there is a requirement of using the same class or function or task or all in multiple modules,instead of writing them again and again,we just put all of them under one identity,package and by importing that package we can use them anywhere in the module. Syntax:\npackage \u0026lt;package_name\u0026gt;; \u0026hellip; \u0026hellip;\nendpackage:\u0026lt;package_name\u0026gt;\nTo use a package in any module we should import the package using import keyword followed by package_name. Syntax :\nimport \u0026lt;package_name\u0026gt;::\u0026lt;method_name\u0026gt;;\nimport \u0026lt;package_name\u0026gt;::*; //to import everything\ncode snippet:\nPackage code:\npackage one; int a; string k; class details; int age; string name; function new(int a,string b); age=a; name=b; endfunction function void getdetails(); $display(\u0026#34;name is %0s\u0026#34;,name,\u0026#34; ,age is %0d\u0026#34;,age); endfunction task t1; $display(\u0026#34;it is in task of class\u0026#34;); endtask: t1 function void hi; $display(\u0026#34;hi\u0026#34;); endfunction endclass function void pack_func; details d; d=new(40,\u0026#34;raj\u0026#34;); a=d.age; k=d.name; $display(\u0026#34;in package function\u0026#34;); $display(\u0026#34;name given is %0s\u0026#34;,k,\u0026#34;, age is %0d\u0026#34;,a); endfunction task pack_task; input int a; output string k=\u0026#34;it is odd\u0026#34;; if(a%2==0)begin k=\u0026#34;it is even\u0026#34;; end endtask endpackage : one In the above code the package one contains a class details with few functions.And along with that we have a function in package pack_func and a task pack_task.\nThe code within the package can only be compiled.\nModule code:\nimport one::*; module mod1; string id1; details emp1=new(21,\u0026#34;kumar\u0026#34;); initial begin string g; $display(\u0026#34;details of id1 are : %0d\u0026#34;,emp1.age); emp1.getdetails(); emp1.t1(); pack_func(); pack_task(10,g); $display(g); end endmodule : mod1 Output:\nFig.Output of the code Here, in the code of the module we would like to use the class details of the package one, and for that we import the package using import keyword.It simply means that all the code written in the package is a part of the module now and can be accessed.Here the class handle emp1 is used to access the class properties and class methods.The package functions and tasks can be accessed as it they were like module functions and tasks.\nGithub lab links:\nPackage lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/Package/package_ex.sv Module lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/Package/package_mod1.sv Github logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/Package/package_mod1.log More about packages# We can have multiple packages in single file. Package cannot be static, extern, virtual, pure. We can import a package within a package but cannot write a package inside a package. If two packages have similar functions,then we use package name followed by scope resolution operator to access that function. Packages cannot be imported with in the scope of the class but can be imported within a function \u0026amp; is valid within that function. Packages can be imported into another package but the imported package must be compiled before use. If two or more packages have same names then the compiler will take the recently compiled package. Importing a package in a file means that pointing to that package whose scope is only visible to the file in which it is imported,means let us have a pkg P1 in which P2 is imported,we will think that importing P1 gives us advantage of using P2 contents but not, as the scope of P2 ends in P1 itself. to use P2 contents again just by importing p1 we use export\nsyntax: export P2; 5.Scope Resolution Operator# Scope Resolution operator is denoted as :: It is used to refer an identifier within the scope of the class. Left side of an scope resolution operator must be class type name, package name, typedef name and right hand side should be like variable name of any method name(task/function).\nIn System Verilog, Scope resolution operator :: being used in following cases :\n1.Defining Extern class methods\nWith help of scope resolution operator we can define a class method outside the body of class\nCode snippet:\nclass my_class; int a=5; int b=10; extern function void sum(); extern function void sub(); endclass:my_class function void my_class::sum(); int result1; result1=a+b; $display(\u0026#34;After summation the result1 is =%0d\u0026#34;,result1); endfunction function void my_class::sub(); int result2; result2=b-a; $display(\u0026#34;After subsration the result2 is =%0d\u0026#34;,result2); endfunction module extern_exm; initial begin:BEGIN_I my_class A1; A1=new(); A1.sum(); A1.sub(); end:BEGIN_I endmodule:extern_exm Output:\nOn above code with help of scope resolution operator we define sum and sub class function outside the class so and inside module after create the object we access the both method then he display result1= 15 and result2=5\nFig: Github lab link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/scope_resolution_operator/sro_extern/sro_extern.sv Github logfile link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/scope_resolution_operator/sro_extern/sro_extern.log 2.Accessing Static methods/properties\nStatic member of the class is accessed outside of the class by using scope resolution operator\nCode snippet:\nclass my_class; int a; static int b; function void display(); $display(\u0026#34;value of a=%0d\u0026#34;,a); $display(\u0026#34;value of b=%0d\u0026#34;,b); endfunction endclass:my_class module static_exm; initial begin:BEGIN_I my_class A1; A1 =new(); A1.a=10; $display(\u0026#34;Using the scope resolution operator we can access the static properties\u0026#34;); my_class::b=20; A1.display(); end:BEGIN_I endmodule:static_exm Output:\nOn above code with help of scope resolution operator we access the static properties (b) of class inside the module in module is assign the value of a and b both so it display value of a=10 and value of b=20\nFig: Github lab link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/scope_resolution_operator/sro_static/sro_static.sv Github logfile link :https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/scope_resolution_operator/sro_static/sro_static.log\n3.Package parameter accessing without import in module\nWithout importing package we can accessed the package parameter here by using scope resolution operator\nCode snippet:\npackage my_pkg; int a= 5; endpackage:my_pkg module pkg_exm; int b; initial begin:BEGIN_I b=my_pkg::a; $display(\u0026#34;Assining the value of a (properties of package) into b without importing package\u0026#34;); $display(\u0026#34;b=%0d\u0026#34;,b); end:BEGIN_I endmodule:pkg_exm Output:\nOn above code we access the package properties inside the module without importing the package with help of scope resolution operator here package properties a assign into b so it display b=5\nFig: Github lab link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/scope_resolution_operator/sro_pkg/sro_pkg.sv Github logfile link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/scope_resolution_operator/sro_pkg/sro_pkg.log 4.To avoid name Space Collision\nIf the package or class properties and module variable is same then with help of scope resolution we can differentiate both\nCode snippet:\npackage my_pkg; int a=5; endpackage :my_pkg module pkg_exm; int a=10; int b=20; int c,d; initial begin:BEGIN_I $display(\u0026#34;value a (package parameter) =%0d and value of a (module variable)=%0d\u0026#34;,my_pkg::a,a); c =my_pkg::a+b; d=a+b; $display(\u0026#34;value c=%0d\u0026#34;,c); $display(\u0026#34;value d=%0d\u0026#34;,d); end:BEGIN_I endmodule:pkg_exm Output:\nOn the above code we display the value of a =5 which is define in package without importing and value of a=10 which is define in module and we assign the sum of a and b into c where a is package properties and assign sum of a and b into d where a is module variable\nFig: Github lab link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/scope_resolution_operator/sro_avoid/sro_avoid.sv Github logfile link : https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/scope_resolution_operator/sro_avoid/sro_avoid.log 6.Command-Line inputs# Command line arguments are used when we want to avoid test bench recompilation. As the name suggests, we can give values to the program mentioning in the command line. The arguments passed in the command line are accessible in our SV code with the help of system functions called plusargs.\nPlusargs# $test$plusargs# This function is used when there is a need to get some instruction from command line precisely a string to perform next lines of code.\nIt is to be noted that all characters of the string mentioned in the function should match the plusarg we provide after + in the command line. When the string matches, the function $test$plusargs returns 1 otherwise it returns 0.\nSyntax:\n$test$plusargs(\u0026quot;string\u0026quot;)\nSimulation command:\nvsim module_name -c -do \u0026quot;run -all;quit\u0026quot; +string\nNote: We are using Mentor Questa simulator in Command Line Interface which explains the above command format.\nCode Snippet 1:\nmodule CLI_testargs; bit x; initial begin:BEGIN-I x=$test$plusargs(\u0026#34;START\u0026#34;); $display(\u0026#34;$test$plusargs returns %d\u0026#34;,x); if(x) $display(\u0026#34;Start process\u0026#34;); else $display(\u0026#34;exit\u0026#34;); end:BEGIN-I endmodule Simulation command:\nvsim CLI_testargs -c -do \u0026quot;run -all;quit\u0026quot; +START\n-\u0026gt; In the above code snippet, if we give START in the CL then we\u0026rsquo;ll get x=1 and Start process is displayed. '\n$test$plusargs returns 1 Start process GitHub lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/Command_Line_Arguments/testargs_1/CLI_testargs.sv GitHub logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/Command_Line_Arguments/testargs_1/CLI_testargs.log -\u0026gt; The below code makes the usage of $test$plusargs in parallel execution of initial blocks.\nCode Snippet 2:\ninitial begin:BEGIN_I x=$test$plusargs(\u0026#34;START\u0026#34;); $display(\u0026#34;@%0dns In first begin block\u0026#34;,$time); $display(\u0026#34;@%0dns $test$plusargs returns %d\u0026#34;,$time,x); if(x) $display(\u0026#34;@%0dns Start process\u0026#34;,$time); else $display(\u0026#34;@%0dns exit\u0026#34;,$time); end:BEGIN_I initial begin:BEGIN_II x=$test$plusargs(\u0026#34;START\u0026#34;); $display(\u0026#34;@%0dns In second begin block\u0026#34;,$time); $display(\u0026#34;@%0dns $test$plusargs returns %d\u0026#34;,$time,x); if(x) $display(\u0026#34;@%0dns Start process\u0026#34;,$time); else $display(\u0026#34;@%0dns exit\u0026#34;,$time); end:BEGIN_II Simulation command:\nvsim CLI_testargs2 -c -do \u0026quot;run -all;quit\u0026quot; +START\n@0ns In first begin block @0ns $test$plusargs returns 1 @0ns Start process @0ns In second begin block @0ns $test$plusargs returns 1 @0ns Start process -\u0026gt;Since the string START is available for both the blocks the functions returns 1 in both at the same timestamp.\nGitHub lab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/Command_Line_Arguments/testargs_2/CLI_testargs.sv GitHub logfile link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/Command_Line_Arguments/testargs_2/CLI_testargs.log $value$plusarg# This function is used when we need to take an input value from user through command line which can be further used or modified in the code.\nIn the simulation (in command line) we should explicitly give the value as string=value which follows +.\nSyntax:\n$value$plusargs(\u0026quot;string=format_specifier\u0026quot;,variable_name)\nHere, format_specifier can be %d, %s etc.\nThe value we give is stored in variable_name and is accessible in the code.\nSimulation command:\nvsim module_name -c -do \u0026quot;run -all;quit\u0026quot; +string=value\nCode Snippet 1\nmodule CLI_valargs; bit x; int y; string message; initial begin:BEGIN_I x=$value$plusargs(\u0026#34;msg=%s\u0026#34;,message); $display(\u0026#34;$value$plusargs used above returns %0d\u0026#34;,x); $display(message); void\u0026#39;($value$plusargs(\u0026#34;value=%d\u0026#34;,y)); y+=1; $display(\u0026#34;Incremeneted value of y:%0d\u0026#34;,y); end:BEGIN_I endmodule -\u0026gt; In the above code we are trying to give two value arguments(one is a string and the other is an integer) in the command line.\nSimulation command:\nvsim CLI_valargs -c -do \u0026quot;run -all;quit\u0026quot; +msg=HEY! +value=2\n$value$plusargs used above returns 1 HEY! Incremeneted value of y:3 GitHub code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/Command_Line_Arguments/valueargs_1/CLI_valueargs.sv GitHub output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/Command_Line_Arguments/valueargs_1/CLI_valueargs.log Code Snippet 2\nmodule CLI_valargs1; bit x; string y; string s; int fd,f; string message; initial begin x=$value$plusargs(\u0026#34;msg=%s\u0026#34;,message); $display(\u0026#34;$value$plusargs used above returns %0d\u0026#34;,x); $display(message); void\u0026#39;($value$plusargs(\u0026#34;file=%s\u0026#34;,y)); fd=$fopen(y,\u0026#34;r\u0026#34;); $fgets(s,fd); $display(s); $fclose(fd); fd=$fopen(y,\u0026#34;a\u0026#34;); $fdisplay(fd,\u0026#34;Hurray!\u0026#34;); $fclose(fd); end endmodule -\u0026gt; Here, we are trying to add contents to a file which we get from command line.\nFig1. Contents of sample.txt before simulation of code Simulation command:\nvsim CLI_valargs1 -l \u0026quot;CLI_valargs1.log\u0026quot; -c -do \u0026quot;run -all;quit\u0026quot; +msg=HEY! +file=\u0026quot;sample.txt\u0026quot;\n$value$plusargs used above returns 1 HEY! We are trying to open this file using command line arhgument and it worked! Fig2. Contents of sample.txt after simulation of code GitHub code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/Command_Line_Arguments/valueargs_2/CLI_valueargs1.sv GitHub output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/Misc_constructs/Command_Line_Arguments/valueargs_2/CLI_valueargs.log Note: Both the functions $test$plusargs and $value$plusargs are case sensitive.\n"},{
      "id": "36",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/choosing-an-array/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / Choosing-an-array",
      "title": "Choosing-an-array",
      "content":"Fixed Arrays/Static Arrays:# 1) Fixed Arrays Over All Arrays:\nFixed Arrays execute faster than all other types of arrays (i.e Associative arrays, dynamic arrays, queues) because it will store in uninitialized data segment (bss segment) of memory, so it will consume less simulation time to execute. And the heap is the segment where dynamic, associative and queue memory allocation takes place.\nThe below figure shows the memory layout. Figure.1. Memory Layout Size is known previously then we can choose fixed arrays over all other types of arrays. Dynamic Arrays:# 1) Dynamic Arrays Over Fixed Arrays:\nMemories allocated at run time, so memory will not be wasted but in fixed array memories would be wasted when we don\u0026rsquo;t know the actual size. We can easily add elements using new() method but in fixed arrays we can\u0026rsquo;t add elements after the declaration. We can delete entire arrays after allocating the memories to it but in fixed arrays we can\u0026rsquo;t delete the memories after declaring array. Note: In fixed arrays, there is no methods like new(),delete().\n2) Dynamic Arrays Over Associative Arrays:\nIndexing is in continues manner but in associative arrays it\u0026rsquo;s non continuous. it\u0026rsquo;s show in below figure. Figure.2. continuous and non continuous indexing We can find relation between indexing so travelling through arrays with ease using loops but in associative arrays keys are required. 3) Dynamic Arrays Over Queues:\nAccording to footprint, dynamic array executes faster and it will required less simulation time but queues will required more time to execute. Figure.3. dynamic array execution time Figure.4. queue execution time Dynamic array used to trace the each and every element in the array using the loops but in queue with pop and push operation. we can\u0026rsquo;t trace the all element of array using fooreach loop. for pop operation the size of the array is decrement and i is increment and for push operation the size of the array is increment and i is also increment it result in Killing process. code:\nmodule dynamic; int dyn []; initial begin dyn = new[8]; dyn = '{2,7,0,6,1,9,9,7}; foreach(dyn[i])begin $display(\u0026quot;verifying the values of each index, dyn[%0d] = %0d\u0026quot;, i, dyn[i]); end end endmodule OUTPUT:\nrun -all verifying the values of each index, dyn[0] = 2 verifying the values of each index, dyn[1] = 7 verifying the values of each index, dyn[2] = 0 verifying the values of each index, dyn[3] = 6 verifying the values of each index, dyn[4] = 1 verifying the values of each index, dyn[5] = 9 verifying the values of each index, dyn[6] = 9 verifying the values of each index, dyn[7] = 7 exit code: using pop operation\n`module queue; int que[$]; initial begin que = '{2,7,0,6,1,9,9,7}; foreach(que[i])begin $display(\u0026quot;verifying the values of each index, que[%0d] = %0d\u0026quot;, i, que[i]); que.pop_back(); end end endmodule\nOUTPUT:\nrun -all verifying the values of each index, que[0] = 2 verifying the values of each index, que[1] = 7 verifying the values of each index, que[2] = 0 verifying the values of each index, que[3] = 6 exit code: using push operation in queue\nmodule queue; int que[$]; initial begin que = '{2,7,0,6,1,9,9,7}; foreach(que[i])begin $display(\u0026quot;verifying the values of each index, que[%0d] = %0d\u0026quot;, i, que[i]); que.push_back(6); end end endmodule OUTPUT:\n`run -all verifying the values of each index, que[0] = 2 verifying the values of each index, que[1] = 7 verifying the values of each index, que[2] = 0 verifying the values of each index, que[3] = 6 verifying the values of each index, que[4] = 1 verifying the values of each index, que[5] = 9 verifying the values of each index, que[6] = 9 verifying the values of each index, que[7] = 7 verifying the values of each index, que[8] = 6 verifying the values of each index, que[9] = 6 verifying the values of each index, que[10] = 6 verifying the values of each index, que[11] = 6 verifying the values of each index, que[12] = 6 Result reached the maximum of 5000 lines. Killing process. Execution interrupted or reached maximum runtime. Associative Arrays:# 1) Advantages of Associative array over all arrays:\nThe function exists(input index); method is used in the associative array to find the index element where this method is not used in associative and dynamic array. code:\nmodule associative; int id[int]; int name[string]; int value[int]; initial begin id = '{4275:25, 4278:12}; name = '{\u0026quot;Dilip\u0026quot;:12}; value = '{50000:25}; //check whether the name exist name.exists(\u0026quot;Dilip\u0026quot;); $display(\u0026quot;the element exist= %0p\u0026quot;, name); end endmodule OUTPUT:\nrun -all the element exist= {\u0026quot;Dilip\u0026quot;:12} exit In Dynamic array \u0026amp; queue there is no such method like function exists(input index) to find the array element if we use function exists(input index); in dynamic array the following error is occur Dynamic array:\ncode:\nmodule dynamic; int dyn []; initial begin dyn = new[8]; dyn = '{2,7,0,6,1,9,9,7}; dyn.exists(0); $display(\u0026quot;the element of the dyn=%0p\u0026quot;, dyn); end endmodule OUTPUT:\n-- Compiling module dynamic ** Error (suppressible): (vlog-13276) testbench.sv(7): Could not find field/method name (exists) in 'dyn' of 'dyn.exists'. ** Error (suppressible): (vlog-13276) testbench.sv(7): Could not find field/method name (exists) in 'dyn' of 'dyn.exists.$0'. End time: 02:35:57 on Sep 03,2022, Elapsed time: 0:00:00 Errors: 2, Warnings: 0 Queue :\ncode:\nmodule queue; int que[$]; initial begin que = '{2,7,0,6,1,9,9,7}; que.exists(0); $display(\u0026quot;the element of the que=%0p\u0026quot;, que); end endmodule\nOUTPUT:\n-- Compiling module queue ** Error (suppressible): (vlog-13276) testbench.sv(6): Could not find field/method name (exists) in 'que' of 'que.exists'. ** Error (suppressible): (vlog-13276) testbench.sv(6): Could not find field/method name (exists) in 'que' of 'que.exists.$0'. End time: 02:43:56 on Sep 03,2022, Elapsed time: 0:00:00 Errors: 2, Warnings: 0 2) Associative array over dynamic array and queue:\nIn Associative array the index type is of any data_type can used but while in dynamic and queue we can\u0026rsquo;t use different data types for indexing. code:\nmodule associative; int id[int]; int name[string]; int value[int]; initial begin id = '{4275:25, 4278:12}; name = '{\u0026quot;Dilip\u0026quot;:12}; value = '{50000:25}; $display(\u0026quot;The id is = {%0p}\u0026quot;, id); $display(\u0026quot;The name is = %0p\u0026quot;, name); $display(\u0026quot;The value is = %0p\u0026quot;, value); end endmodule\nOUTPUT:\nrun -all The id is = {{4275:25} {4278:12} } The name is = {\u0026quot;Dilip\u0026quot;:12} The value is = {50000:25} exit 3) Associative array over dynamic array and fixed array:\nWe can delete the particular index element in Associative array by using function void delete(input index); but in dynamic and fixed type we can\u0026rsquo;t use function void delete(input index); to delete the particular index. code:\nmodule associative; int id[int]; int name[string]; int value[int]; initial begin id = '{4275:25, 4278:12}; name = '{\u0026quot;Dilip\u0026quot;:12}; value = '{50000:25}; $display(\u0026quot;The id is = {%0p}\u0026quot;, id); $display(\u0026quot;The name is = %0p\u0026quot;, name); $display(\u0026quot;The value is = %0p\u0026quot;, value); $display(\u0026quot;The size of the id is=%0d\u0026quot;, id.size()); id.delete(4278); $display(\u0026quot;The size of 'id' after deleting = %0d\u0026quot;, id.size()); $display(\u0026quot;The id is = {%0p}\u0026quot;, id); end endmodule OUTPUT:\nrun -all The id is = {{4275:25} {4278:12} } The name is = {\u0026quot;Dilip\u0026quot;:12} The value is = {50000:25} The size of the id is=2 The size of 'id' after deleting = 1 The id is = {{4275:25} } exit The Associative array is memory friendly we can store the value of the array in any memory location. Queues:# 1) Advantages of Queue over all arrays\nIn queue the main advantage is push \u0026amp; pop operation. The push used to insert the element in to queue. The push as two methods function push_back(input element_t); \u0026amp; function push_front(input element_t); The pop as two methods function pop_front(); \u0026amp; function pop_back(); code:\n`module queue_data_type; string queue1[$]; initial begin queue1 = {\u0026quot;manipal\u0026quot;, \u0026quot;banglaore\u0026quot;, \u0026quot;udupi\u0026quot;}; $display(\u0026quot;\\nRemove the array element at first index position of queue1:%p\u0026quot;,queue1.pop_front()); $display(\u0026quot;\\n After removing the 'manipal' from queue1 is :%p\u0026quot;, queue1); $display(\u0026quot;\\nRemove the array element at last index position of queue1: %p\u0026quot;, queue1.pop_back()); $display(\u0026quot;\\n After removing the 'udupi' from queue1 is :%p\u0026quot;, queue1); queue1.push_front(\u0026quot;Yelahanka\u0026quot;); $display(\u0026quot;\\ninsert the array element at first index position of queue1:output\u0026quot;); $display(\u0026quot;\\n queue1: %p\u0026quot;, queue1); queue1.push_back(\u0026quot;udupi\u0026quot;); $display(\u0026quot;\\ninsert the array element at last index position of queue1: ouptut\u0026quot;); $display(\u0026quot;\\n queue1 : %p\u0026quot;, queue1); end endmodule\nOUTPUT:\n`run -all // Remove the array element at first index position of queue1:\u0026quot;manipal\u0026quot; // After removing the 'manipal' from queue1 is :'{\u0026quot;banglaore\u0026quot;, \u0026quot;udupi\u0026quot;} // Remove the array element at last index position of queue1: \u0026quot;udupi\u0026quot; // After removing the 'udupi' from queue1 is :'{\u0026quot;banglaore\u0026quot;} // insert the array element at first index position of queue1:output // queue1: '{\u0026quot;Yelahanka\u0026quot;, \u0026quot;banglaore\u0026quot;} // insert the array element at last index position of queue1: ouptut // queue1 : '{\u0026quot;Yelahanka\u0026quot;, \u0026quot;banglaore\u0026quot;, \u0026quot;udupi\u0026quot;} exit 2) Advantages of Queue over Dynamic \u0026amp; Associative Array:\nIn queue we can insert the element at any index position using the method function insert(index , queue_element);. So we can say inserting is easy. Thus the queue length increases and shrinks even if we remove or add elements from the middle, but in dynamic and associative array we can\u0026rsquo;t insert the element in the array. code:\n`module queue_data_type; string queue1[$]; int queue2[$]; initial begin queue1 = {\u0026quot;banglaore\u0026quot;, \u0026quot;udupi\u0026quot;}; queue1.insert(0, \u0026quot;manipal\u0026quot;); $display(\u0026quot;Insert the array element at 0 index position of queue1: {%0p}\u0026quot;, queue1); end endmodule OUTPUT:\n`run -all // Insert the array element at 0 index position of queue1: {{manipal} {banglaore} {udupi}} exit "},{
      "id": "37",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/control-flow-interview-questions/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / Control-Flow-Interview-questions",
      "title": "Control-Flow-Interview-questions",
      "content":"1. How to call the task inside a function? giving example with code.\nAnswer: Normally a function can be called inside the task. but calling the task inside the function is illegal because task has delay elements and the function does not have any delay elements but there is an exceptional case for it, by using the fork and join_none inside the function to call the task is possible.\nPlease refer to the below code for a better understanding.\nmodule test; initial begin void\u0026#39;(function_name); end function function_name; $display($time, \u0026#34;\\t I\u0026#39;m in function\u0026#34;); fork $display(\u0026#34;\\t calling task inside a function\u0026#34;); task_name; join_none endfunction task task_name; #5 $display($time,\u0026#34;\\t Now I\u0026#39;m in task\u0026#34;); endtask endmodule The below figure shows the output of calling a task inside a function. Figure.1. output of calling a function inside a task. In the above screenshot calling a task inside a function. In the initial module, function is called and printed I\u0026rsquo;m in function and called task inside fork join_none and in task printed I\u0026rsquo;m in task after 5 ns and returned back to function and then to initial block.\n2. What is the output of the following snippet?\nint x=2; repeat(x); begin x++; $display(\u0026quot;The value of x is %0d\u0026quot;, x); end Answer: Repeat loop is used for repeating statements or operations for a fixed number of times. Here initially they give the value of x is 2 and later x value changed inside repeat, In repeat once x is taken and doesn\u0026rsquo;t bother if x value changes i.e., initially x value evaluates and and doesn\u0026rsquo;t evaluate again. So Statements will be repeated 2 times\nPlease refer to the below code for a better understanding.\nmodule test; int x=2; initial begin $display(\u0026quot;output of repeat(x=2) is \u0026quot;); repeat(x) begin $display(\u0026quot;The value of x is %0d\u0026quot;, x); x++; end end endmodule The below figure shows the output of the Repeat loop.\nFigure.2. the output of the Repeat loop. 3. What is a dead code in System Verilog? Answer: Dead code is a piece of code that doesn\u0026rsquo;t run at all \u0026amp; which doesn\u0026rsquo;t affect your simulation or synthesis.\nThe code which has code coverage of 0% i.e., the final product chip there will be some hardware generated in the chip which has never been used in the lifetime.\nExamples of dead code are signals that are never used or conditions that are never triggered in code.\n4. Can we use a local variable of the foreach loop outside of the loop as shown in following snippet ? why?\nint array[5] foreach(array[i]) begin array[i]=i; $display(\u0026quot;\\tarray[%0d]=%0d\u0026quot;,i,array[i]); end $display(\u0026quot;value of i out of loop: %0d\u0026quot;,i); $display(\u0026quot; out of loop \u0026quot;); Answer : No\nIn the foreach loop we can use some random variable let\u0026rsquo;s say i as a variable and i variable can\u0026rsquo;t be used outside the inside module because i refers to only foreach block itself (using the scope resolution operator is also not possible). It will show the error as shown in the following fig.\n5.How to use the forever loop using for loop ?\nNormally As the name says forever loop will execute the statements inside the loop forever.\nIt can be said as infinite iterations. so if we use that simulator will hang.\nBut there are 2 ways to stop the forever loop.\nusing if conditions and break statements inside the for a loop. $finish. using if conditions and break statements to terminate the loop\nmodule forever_for; initial begin $display(\u0026quot;-----forever loop output ---\u0026quot;); for (int i=0;1;i++) begin #4 $display(\u0026quot;\\t value of i = %0d\u0026quot;, i); if(i==5) break; end end endmodule In the above code we use the for loop syntax to do the forever loop and inside the for loop i=0;1;i++ The condition is 1 which means true all the time. so for loop never terminate means for is acting as forever loop. so to stop it we are using the if condition and break statements in if condition when i=5 then break so it will work from 0 to 5 iterations and then exits the loop.\nusing $finish to terminate the forever loop\nmodule forever_for;` initial begin $display(\u0026quot;-----forever loop output ---\u0026quot;); for (int i=0;1;i++) begin #4 $display(\u0026quot;\\t value of i = %0d\u0026quot;, i); end end initial begin #21 $finish; end endmodule Here also the same example as we used in the previous example but here we are using a $finish statement to terminate the loop.\nThe below figure shows the output of the forever loop\nFigure.3. the output of the forever loop. 6.What is difference between pre-increment(++i) and post-increment(i++) in SV ?\nAnswer :\nlet\u0026rsquo;s say we are assigning a variable j with the use of i variable incrementing by post and pre-increment methods.\nIn pre-increment(++i) will increment the value of i and then the assignment will happen to the LHS i.e., to j.\nIn post-increment(i++) will increment the value of i and after the assignment to LHS.\nfor a better understanding look at the below code\npre-increment code\nmodule pre_increment; int i=1; int j; initial begin $display(\u0026quot;\\t the value of i is %0d\u0026quot;,i); $display(\u0026quot;\\t the value of j is %0d\u0026quot;,j); $display(\u0026quot;\\t assigning i value to j\u0026quot;); j=++i; $display(\u0026quot;\\t after pre-increment the value j is %0d\u0026quot;,j); end endmodule In the above code, i value is initially 1 and we assign i value to j with pre-incrementing (++i).\npost increment code\nmodule post_pre; int i=1; int j; initial begin $display(\u0026quot;\\t the value of i is %0d\u0026quot;,i); $display(\u0026quot;\\t the value of j is %0d\u0026quot;,j); $display(\u0026quot;\\t assigning i value to j\u0026quot;); j=i++; $display(\u0026quot;\\t after post-increment the value j is %0d\u0026quot;,j); end endmodule In the above code, i value is initially 1 and we assign i value to j with post-incrementing (i++);\nThe below figure shows the output of both pre-increment and post-increment\nFigure.4. the output of both pre-increment and post-increment. 7. How will the break keyword work inside the repeat loop?\nAnswer :\nwe use the break keyword inside the repeat loop it will terminate the loop. and based on certain conditions.\nfor a better understanding look at the below code\nmodule repeat_break; int b; initial begin repeat(5) begin $display(\u0026quot;\\tVlaue of b=%0d\u0026quot;,b); b++; if(b==3) break; end end endmodule In the above code is repeat loop with a break keyword, we are declaring the repeat loop it will be executed 5 times but using the break keyword to terminate the loop in a 3rd iteration and comes out of the repeat loop completely.\nThe below figure shows the output of the repeat loop with the break keyword.\nFigure.5. the output of the repeat loop with the break keyword. 8.what is the difference between If and unique if statements? Answer :\nSL.No condition if unique if 1. only one conditional expression is true execute the set of statements inside the true conditional block execute the set of statements inside the true conditional block 2. more than one conditional expression is true executes the first true conditional block statements executes the first true conditional block statements and also displays a warning that multiple conditions were true which leads to a dead code 3. none of the conditional expressions is true without else comes out of the if-else block comes out of the unique if block and shows a warning that none of the conditions is true 9. what is the difference between If and priority if statements?\nAnswer :\nSL.No condition if priority if 1. only one conditional expression is true execute the set of statements inside the true conditional block execute the set of statements inside the true conditional block 2. more than one conditional expression is true executes the first true conditional block statements, no warning display executes the first true conditional block statements, no warning display 3. none of the conditional expressions is true without else execute the statements out from the conditional block, no warning display execute the statements out from the conditional block, a warning display "},{
      "id": "38",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/data-type-interview-questions/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / Data-type-Interview-questions",
      "title": "Data-type-Interview-questions",
      "content":"1.Is there any difference between reg and logic in SystemVerilog?\nAnswer:\nBefore system verilog ,verilog is mainly used for synthesis and verification purposes. In verilog there are two main data type\nreg\n2)net\nReg is mainly used when we want to store values in the variable .It is mainly used inside procedural block .mainly it is used for designing of sequential circuit .net variable are mainly continuously driven .In net type variable it is not possible to store value . So ,there is lots of confusion for designer ,where to use reg and where to use net.This problem is solved in system verilog .System verilog introduced a new data type called as “logic”. This data type can be use at both the places. It can be use for net as well as reg.\n2.What is the difference between logic[7:0] and byte variable in System Verilog?\nAnswer:\nThe \u0026lsquo;byte\u0026rsquo; is a signed variable which means it can only be used to count values till 127. A logic[7:0] variable can be used for an unsigned 8 bit variable that can count up to 255. 3.What are the difference between 2 state and 4 state?\nAnswer:\n4 state includes logic 0, logic 1, logic X where it is related to registers, in real world it is declared as 0 or 1 it is based on the simulators we\u0026rsquo;re using and logic Z, which is related to wires. 2 state includes of logic 1 and logic 0. 4.Difference between packed and unpacked arrays\nAnswer: Refer the below link\nhttps://github.com/muneeb-mbytes/SystemVerilog_Course/wiki/02.Array#static-arrays-has-two-types 5.Comparision between fixed, dynamic, associative array and queue.\nAnswer:\nRefer the below link https://github.com/muneeb-mbytes/SystemVerilog_Course/wiki/Choosing-an-array 6.Given a dynamic array of size 100, how can the array be re-sized to hold 200 elements while the lower 100 elements are preserved as original?\nAnswer: A dynamic array needs memory allocation using new[] to hold elements. Here is an example with an integer array that grows from an initial size of 100 elements to 200 elements.\n// Declare the dynamic array. integer addr[]; // Create a 100-element array. addr = new[100]; ……… // Double the array size, preserving previous values. addr = new[200](addr); 7.Difference between packed and unpacked structure\nAnswer:\nRefer the below link\nhttps://github.com/muneeb-mbytes/SystemVerilog_Course/wiki/03.Structure-and-Union#types-of-structure 8.What happens if we give same value for different names in enumeration data type?\nAnswer:\ncode:\nmodule set_value_enum; //set same value for MONDAY and TUESDAY. enum {MONDAY=2, TUESDAY=2, WEDNESDAY=5, THURSDAY, FRIDAY=10, SATURDAY, SUNDAY }days; output :\nError: Enum member 'TUESDAY' does not have unique value. 9.What is the output if you declare bit as signed and assign value as 11xz11x1 ?\nAnswer:\ncode:\nmodule data_type_bit; // declare bit signed type 8 bit variable bit signed [7:0] data = 8'b11xz11x1; initial begin $display(\u0026quot;\\nValue of bit signed data in binary = %0b\u0026quot;,data); $display(\u0026quot;Value of bit signed data in decimal = %0d\\n\u0026quot;,data); end endmodule: data_type_bit output :\nValue of bit signed data in binary = 11001101 Value of bit signed data in decimal = -51 In the above code, we declared bit as 11xz11x1, here bit is 2 state, so x and z are converted to 0 and it will become 11001101. Since it is signed bit it gives -51 in decimal format.\n10.What is the output if you declare byte as unsigned and assign value as 11101001 ?\nAnswer:\ncode:\nmodule data_type_byte; // declare byte unsigned type 8 bit variable byte unsigned data = 8'b11101001; initial begin $display(\u0026quot;\\nValue of byte unsigned data in binary = %0b\u0026quot;,data); $display(\u0026quot;Value of byte unsigned data in decimal = %0d\\n\u0026quot;,data); end endmodule: data_type_byte output :\nValue of byte unsigned data in binary = 11101001 Value of byte unsigned data in decimal = 233 In the above code, we declared byte as 11101001. Since it is unsigned byte it gives 233 in decimal format.\n"},{
      "id": "39",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/differences-between-macros-and-parameters/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / Differences-between-macros-and-parameters",
      "title": "Differences-between-macros-and-parameters",
      "content":" Macros Parameters macros are replaceable parameters are like variables macros works in pre-compilation state parameters works in Elaboration state syntax : `define macro_name value syntax : parameter parameter_name=value We can use `define in any file we can use parameter within the file we can\u0026rsquo;t give datatypes in macros we can use and change datatype in parameters Macros can have multiple lines multiple lines cannot be possible here because parameter is just like declaring variables We can give value for a macro in command line parameters value can\u0026rsquo;t be changed in command line Execution stage of macros and parameters# Parameters used in macros# parameter data = 5; // data will be replaced by value 5 in Elaboration `define DATA data // in pre-compilation `DATA will be replaced with data module tb(); int a,b; initial begin $display(\u0026#34;DATA=%0d\u0026#34;,`DATA); b= `DATA + 2; $display(\u0026#34; b=%0d\u0026#34;,b); end endmodule In the above code the parameter value of data =5 is used in the macro `DATA\nMacros used in parameters# `define DATA 25 parameter data = `DATA; module tb(); int a,b; initial begin $display(\u0026#34;data=%0d\u0026#34;,data); // in pre-compilation `DATA will be replaced with 25. $display(\u0026#34;DATA=%0d\u0026#34;,`DATA); // data will be replaced by value 25 in Elaboration a = data +5; b= `DATA + 2; $display(\u0026#34;a=%0d b=%0d\u0026#34;,a,b); end endmodule In the above code the macro value of `DATA 25 is used in the parameter data.\nMacros(`define) can be used in command line\n-timescale 1ns/1ns +define+name=20\n`define name 10 module hi; int a; initial begin $display(\u0026#34;[%0t] a = %0d\u0026#34;,$time,a); #1 a = `name; $display(\u0026#34;[%0t] a = %0d\u0026#34;,$time,a); end endmodule We can give inputs to macros in command line interface using -timescale 1ns/1ns +define+name=20 in compile options .\n"},{
      "id": "40",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/interface-interview-questions/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / Interface-Interview-Questions",
      "title": "Interface-Interview-Questions",
      "content":"1. How does the clocking block handles synchronous reset?\nSolution:\nSynchronous reset is sampled only with respect to clock event. When reset is enabled, it will be effective only after next active clock edge.\nclockingblock TB_CB @(posedge clk) default input #1step output #0; input rst; output a,b; input y; Note: The clocking block is only designed to handle synchronous reset - it should happen only be based on clock event. Reset in clocking block should be handled elsewhere. If the clocking block outputs are variables, you can procedurally assign them outside of a clocking block on a reset.\n2. How does the modport handle asynchronous reset?\nSolution:\nAsynchronous Reset\nIn asynchronous reset sampling is done by independent of clk. When reset is enabled ,it will be effective immediately within the same the clock edges.\nFig 1: Design example Here, in this example there are three signals a,b and c. \u0026lsquo;a\u0026rsquo; is continuous signal and asynchronous. \u0026lsquo;b\u0026rsquo; and \u0026lsquo;c\u0026rsquo; are synchronous signals. Using modport we can change the asynchronous signal \u0026lsquo;a\u0026rsquo; to synchronous signal.\nmodport TB_MP(TB_CB , output a);\nNote: In Modport, the design can handled with asynchronous reset. The asynchronous reset will be happen at any time.\n3.What is synchronous and asynchronous reset?\nSolution:\nSynchronous reset means reset is sampled with respect to clock. In other words, when reset is enabled, it will not be effective till the next active clock edge.\nmodule synchronous_reset_test (input logic clk, reset, in1, output logic out1)\nalways @(posedge clk)\nif(reset) out1 \u0026lt;= 1\u0026rsquo;b0;\nelse out1 \u0026lt;= in1;\nendmodule\nThe out1 will be changed only with the posedge of clk. To get the effect of reset, reset should be wide enough to be captured by the next posedge of clk.\nFig 2: Synchronous Reset Asynchronous Reset\nIn asynchronous reset, reset is sampled independent of clk. That means, when reset is enabled it will be effective immediately and will not check or wait for the clock edges.\nmodule asynchronous_reset (input logic clk, reset, in1, output logic out1);\nalways @(posedge clk or posedge reset)\nif(reset) out1 \u0026lt;= 1\u0026rsquo;b0;\nelse out1 \u0026lt;= in1;\nendmodule\nFig 3: Asynchronous Reset 4.What is the usage of blocking and non blocking assignments in sampling and driving signals?\nSolution:\nThe blocking assignment (=) used for sampling signals in active region.\nThe non blocking assignment (\u0026lt;=)used for driving signals in active-NBA region.\nSo we can avoid the race condition in verilog.\n5. Access restriction of signals using modport\nSolution:\nCode Snippet:\ninterface.sv file:\n// interface defination for and gate interface and_intr; //input and output signals declaration for design logic p,q; logic r; // modport declaration for design file modport DUT_MP(input q,output r); // modport declaration for testbench file modport TB_MP(output p,output q,input r); endinterface : and_intr tb.sv file:\n// testbench file for and gate design // module defination for testbench with interface instanciation module tb(and_intr inf);\ninitial begin $display(\u0026quot;// and gate output using modports\\n\u0026quot;); repeat(5) begin inf.TB_MP.p = $random; #1; inf.TB_MP.q = $random; #1; $display(\u0026quot;input_p=%b\\t input_q=%b\\t output_r=%b\u0026quot;,inf.TB_MP.p,inf.TB_MP.q,inf.TB_MP.r); end end endmodule : tb design.sv file:\n// and gate design file // module defination for and gate with interface instanciation module and_gate(and_intr inf); // assign the output using continuous assignment assign inf.DUT_MP.r = (inf.DUT_MP.p) \u0026amp; (inf.DUT_MP.q); endmodule : and_gate Output:\nwhen the input signal \u0026lsquo;p\u0026rsquo; is not there in the DUT_MP(design modport) but that signal is called in testbench to generate the output at that time it will give an error which is shown in below snapshot.\nLab link:- https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/interface/interface_error/modport_error 6. What happens if we assign value to output in test module, while doing interface?\nsolution: We get a warning as one of the assignment is implicit , but we\u0026rsquo;ll get proper output.\nLab link: https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/interface/interface_error/interface_example "},{
      "id": "41",
      "rootTitleIndex": "1",
      "rootTitle": "数字电路基础",
      "rootTitleIcon": "fa-solid fa-microchip fa-lg",
      "rootTitlePath": "/digital/",
      "rootTitleTitle": "主页 / 数字电路基础",
      "permalink": "/digital/systemverilog/processes-interviewquestions/",
      "permalinkTitle": "主页 / 数字电路基础 / SystemVerilog 详细教程 / Processes-InterviewQuestions",
      "title": "Processes-InterviewQuestions",
      "content":"1.Difference between fork_join,fork_join_any and fork_join_none ?\nfork_join fork_join_any fok_join_none In fork_join the main(parent) threads will execute after all the threads(child threads) in the fork_join is executed In fork_join_any the main(parent) threads executes if any one of the child threads excecutes In fork_join_none child threads and main(parent) threads are executed parallely 2.Can we use wait_fork in fork_join ?\nWe know that in fork_join the main thread is executed only when all the threads in fork_join is executed so here no need of using wait_fork. We can use wait fork after the fork_join_any or fork_join_none statement to wait for all the threads in the fork-join_any or fork_join_none to complete. So here in fork_join wait_fork is not required.\n3.Difference between Blocking and Non-Blocking Assignments ?\nblocking Non-Blocking In Blocking Assignment one statement is executed then the next statement will executed i.e first expression of right hand side is evaluated and immediately assigned to the left hand side variable In Non-Blocking assignment evaluated all the right hand side expression for the current time unit and assigned to left-hand side variable at the end of the time unit Represented by \u0026quot; = \u0026quot; Represented by \u0026quot; \u0026lt;= \u0026quot; It executes sequentially It executes parallely Blocking is used in combinational Non-Blocking is used in sequential 4.Difference between wait event and @ event ?\nIf we triggered wait and @ in the same delay then wait statement is executed because the wait catches fast then @ event.\nExample:\nmodule tb; event e; initial begin #20 -\u0026gt;e; $display($time,\u0026quot;thread1\u0026quot;); end initial begin #20 @e; $display($time,\u0026quot;thread2\u0026quot;); end initial begin #20 wait(e.triggered); $display($time,\u0026quot;thread3\u0026quot;); end endmodule In the above example we can see that we have same delay for the event,wait and @ but after executing the event wait is executed eventhough we declared \u0026lsquo;@\u0026rsquo; in between, its because wait catches the fast then the @ so as a output we can only see thread1 and thread3.\n5.Can we execute wait and @ with different delays ?\nmodule tb; event e; initial begin #20 -\u0026gt;e; $display($time,\u0026quot;thread1\u0026quot;); end initial begin #25 @e; $display($time,\u0026quot;thread2\u0026quot;); end initial begin #15 wait(e.triggered); $display($time,\u0026quot;thread3\u0026quot;); end endmodule In the above example we can see that delays are different for event ,wait and @.We can also see that here @ delay is more than the event delay and wait delay is less than the event delay so here it executes only the wait statement with the event delay.So in the below figure we can see that thread 1 and thread 3 is executed with same delay(#20)\n"},{
      "id": "44",
      "rootTitleIndex": "0",
      "rootTitle": "主页",
      "rootTitleIcon": "fa-solid fa-house-chimney fa-lg",
      "rootTitlePath": "/",
      "rootTitleTitle": "主页",
      "permalink": "/",
      "permalinkTitle": "主页",
      "title": "主页",
      "content":"asdfas# SystemVerilog adds the interface construct which encapsulates the communication between blocks. An interface is a bundle of signals or nets through which a testbench communicates with a design.\n342323# SystemVerilog adds the interface construct which encapsulates the communication between blocks. An interface is a bundle of signals or nets through which a testbench communicates with a design.\nhjryj# SystemVerilog adds the interface construct which encapsulates the communication between blocks. An interface is a bundle of signals or nets through which a testbench communicates with a design.\n"}]